{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"COMP2801 - Application Development with C Overview For full course information bcit.ca . Course taken in Fall 2025 term ( outline ) with Bob Langelaan . Midterm and Final in-person 4 quizzes, one each in weeks 3, 5, 8, and 11 right at the start of class 8 labs must be submitted to get a mark for labs There will be 4 assignments The course continues from COMP2701 and just follows C How to Program -- Ninth Edition .","title":"Home"},{"location":"#comp2801-application-development-with-c","text":"","title":"COMP2801 - Application Development with C"},{"location":"#overview","text":"For full course information bcit.ca . Course taken in Fall 2025 term ( outline ) with Bob Langelaan . Midterm and Final in-person 4 quizzes, one each in weeks 3, 5, 8, and 11 right at the start of class 8 labs must be submitted to get a mark for labs There will be 4 assignments The course continues from COMP2701 and just follows C How to Program -- Ninth Edition .","title":"Overview"},{"location":"wk_four/","text":"","title":"Wk four"},{"location":"wk_one/","text":"Week 1 This week covers the first half of Chapter 9 in the text. We look in depth at printf formatting including specifiers , field widths , formatting flags , and escape sequences which all help control how output is displayed. Streams Streams are sequences of bytes used for input and output. Input : Data flows from a device (keyboard, disk, network, etc.) into main memory. Output : Data flows from main memory to a device (screen, printer, disk, network, etc.). At program start, three standard streams are available: Standard input ( stdin ) \u2013 usually from the keyboard. Standard output ( stdout ) \u2013 usually to the screen. Standard error ( stderr ) \u2013 also to the screen, for error messages. Redirection : Operating systems allow these streams to be redirected to other devices or files. printf Formatting As we learned in the previous course, printf can be used to format output to stdout using conversion specifications . Type Specifiers Integers There are a number of different conversion specifiers for integers. Specifier Description %d Signed decimal integer %i Signed decimal integer (same as %d ) %o Unsigned octal integer %u Unsigned decimal integer %x Unsigned hexadecimal integer (lowercase a\u2013f) %X Unsigned hexadecimal integer (uppercase A\u2013F) %hd / %ld / %lld Short, long, or long long integers (length modifiers) Note: if you are using any of the unsigned specifiers, don't pass it any negative numbers. If you are using any of the long length modifiers you should add a corresponding literal suffix ( L , LL ) to the value that you pass to printf . printf(\"%ld\\n\", 5000000000L); // long (suffix L required) printf(\"%lld\\n\", 9000000000000LL); // long long (suffix LL required) Floating-Point Numbers Specifier Description %e / %E Exponential (scientific) notation (e.g., 1.23e+02 or 1.23E+02 ) %f / %F Fixed-point notation %g / %G Uses either %f or %e ( %E ) depending on value\u2019s magnitude, with no trailing zeros %Lf / %Le / %Lg Long double (length modifier L ) The default precision is 6 digits after the decimal (for %f ) or 6 significant digits (for %g / %G ). Rounding : %e , %E , and %g perform rounding; %f shows exact decimals. %g / %G automatically chooses the shortest visual representation for a given number: Chooses %e if the exponent is < -4 or \u2265 precision. Otherwise chooses %f . Removes trailing zeros. Omits the decimal point if the fractional part is zero. #include <stdio.h> int main(void) { printf(\"%g\\n\", 87.0); // 87 // whole number, fractional part is zero so \".0\" is suppressed printf(\"%g\\n\", 87.50); // 87.5 // fractional part kept, trailing zero removed printf(\"%g\\n\", 87.25); // 87.25 // fractional part kept, no trailing zeros to remove printf(\"%g\\n\", 0.0000875); // 8.75e-05 // exponent < -4, so %e format is chosen printf(\"%g\\n\", 8750000.0); // 8.75e+06 // exponent \u2265 precision (6), so %e format is chosen printf(\"%#g\\n\", 87.0); // 87.0000 // '#' flag forces decimal point and trailing zeros up to precision return 0; } Strings and Characters %c prints a single char %s prints a null-terminated string ( char* ), stops at '\\0' Missing null terminator or wrong format specifier (e.g., %s with a char ) undefined behavior, often a crash Compilers usually don\u2019t catch format string errors \u2014 they show up only at runtime. Pointers Specifier Description %p Displays a pointer (address) in an implementation-defined way (commonly hexadecimal) %p expects a pointer argument (e.g., &x , or a char* , int* , etc.). The exact format of the address depends on the system, but is typically hexadecimal. Useful for debugging to confirm memory addresses. Field Width You can control the minimum number of characters used when printing a value by specifying a field width . If the value has fewer characters than the field width then it is padded (by default with spaces). Note : If the value has more characters than the field width then the full value is printed (field width is ignored). That is to say, it does not truncate the output. #include <stdio.h> int main(void) { printf(\"%4d\\n\", 1); // 1 printf(\"%4d\\n\", 12); // 12 printf(\"%4d\\n\", 123); // 123 printf(\"%4d\\n\", 1234); // 1234 printf(\"%4d\\n\", 12345); // 12345 (too wide, prints fully) printf(\"%4d\\n\", -1); // -1 printf(\"%4d\\n\", -12); // -12 printf(\"%4d\\n\", -123); // -123 printf(\"%4d\\n\", -1234); // -1234 printf(\"%4d\\n\", -12345); // -12345 } Negative Values If the value has a negative sign, it will use up one of the field width characters: #include <stdio.h> int main(void) { printf(\"BEFORE%4dAFTER\\n\", 1); //BEFORE 1AFTER printf(\"BEFORE%4dAFTER\\n\", -1); //BEFORE -1AFTER // In the second example, there are only 2 spaces. } Dynamic Widths Instead of providing a number, you can pass * instead and then supply the width as one of the values passed instead. This works for precision as well. printf(\"BEFORE%*.*fAFTER\", 7, 2, 98.736); // BEFORE 98.74AFTER // 7 \u2192 total field width (minimum size, includes digits, decimal point, and padding) // 2 \u2192 precision (number of digits after the decimal point) Format Flags Alignment By default, values are right-aligned in the field. To make them left-aligned , add a - before the field width: #include <stdio.h> int main(void) { printf(\"BEFORE%4dAFTER\\n\", 1); //BEFORE 1AFTER printf(\"BEFORE%-4dAFTER\\n\", 1); //BEFORE1 AFTER } Sign Control (for numbers) By default, only negative numbers are printed with a sign ( - ). You can control how positive numbers appear using flags: + : always print a sign ( + for positive, - for negative). space ( ' ' ): print a space in front of positive numbers (negative numbers still get - ). This can be useful for aligning columns of positive and negative numbers. #include <stdio.h> int main(void) { printf(\"%d\\n\", 42); // 42 printf(\"%+d\\n\", 42); // +42 printf(\"% d\\n\", 42); // 42 (leading space) printf(\"%d\\n\", -42); // -42 printf(\"%+d\\n\", -42); // -42 printf(\"% d\\n\", -42); // -42 } Alternate Form (# Flag) The # flag modifies how certain values are displayed: Octal ( %o ) : prefixes the value with 0 . Hexadecimal ( %x / %X ) : prefixes the value with 0x or 0X . Floating-point ( %f , %e , %E , %g , %G ) : forces a decimal point to appear, even if the fractional part is zero. For %g / %G , it also prevents trailing zeros from being removed. #include <stdio.h> int main(void) { int c = 1427; double p = 1427.0; printf(\"%o\\n\", c); // 2623 printf(\"%#o\\n\", c); // 02623 printf(\"%x\\n\", c); // 593 printf(\"%#x\\n\", c); // 0x593 printf(\"%X\\n\", c); // 593 printf(\"%#X\\n\", c); // 0X593 printf(\"%g\\n\", p); // 1427 printf(\"%#g\\n\", p); // 1427.00 (decimal point forced, trailing zeros kept) } Zero Padding (0 Flag) By default, extra space in a field width is filled with spaces. The 0 flag changes this so that extra space is filled with leading zeros . Works with integers and floating-point numbers. Often combined with the + flag to show signs with padded numbers. Padding occurs after the sign, not before. Example #include <stdio.h> int main(void) { printf(\"%9d\\n\", 452); // \" 452\" (spaces) printf(\"%09d\\n\", 452); // \"000000452\" (zeros) printf(\"%+09d\\n\", 452); // \"+00000452\" printf(\"%09d\\n\", -452); // \"-00000452\" } Literals and Escape Sequences Characters in a format string that are not part of a conversion specification are printed literally. Escape sequences allow you to include special characters in strings that cannot be typed directly or would otherwise be ambiguous. Escape Description \\' Single quote ( ' ) \\\" Double quote ( \" ) \\? Question mark ( ? ) \\\\ Backslash ( \\ ) \\a Alert (bell/flash) \\b Backspace \\f Form feed (new page) \\n Newline \\r Carriage return \\t Horizontal tab \\v Vertical tab %% Percent symbol ( % ) #include <stdio.h> int main(void) { printf(\"Hello\\tWorld\\n\"); // tab between words, newline at end printf(\"Path: C:\\\\temp\\n\"); // prints: Path: C:\\temp printf(\"Beep!\\a\\n\"); // may cause a sound or window flash printf(\"CPU usage: 95%%\\n\"); // CPU usage: 95% } Why %% isn\u2019t like \\n (click to expand) Backslash escapes (like \\n , \\t , \\? ) are language features handled at compile time, because they solve parsing or representation issues in string literals. Percent escapes (like %d , %% ) are library features , defined only for functions such as printf / scanf and interpreted at runtime. In short: \\n is replaced by the compiler, while %% is handled later by printf .","title":"Week 1 - Formatted Output in C"},{"location":"wk_one/#week-1","text":"This week covers the first half of Chapter 9 in the text. We look in depth at printf formatting including specifiers , field widths , formatting flags , and escape sequences which all help control how output is displayed.","title":"Week 1"},{"location":"wk_one/#streams","text":"Streams are sequences of bytes used for input and output. Input : Data flows from a device (keyboard, disk, network, etc.) into main memory. Output : Data flows from main memory to a device (screen, printer, disk, network, etc.). At program start, three standard streams are available: Standard input ( stdin ) \u2013 usually from the keyboard. Standard output ( stdout ) \u2013 usually to the screen. Standard error ( stderr ) \u2013 also to the screen, for error messages. Redirection : Operating systems allow these streams to be redirected to other devices or files.","title":"Streams"},{"location":"wk_one/#printf-formatting","text":"As we learned in the previous course, printf can be used to format output to stdout using conversion specifications .","title":"printf Formatting"},{"location":"wk_one/#type-specifiers","text":"","title":"Type Specifiers"},{"location":"wk_one/#integers","text":"There are a number of different conversion specifiers for integers. Specifier Description %d Signed decimal integer %i Signed decimal integer (same as %d ) %o Unsigned octal integer %u Unsigned decimal integer %x Unsigned hexadecimal integer (lowercase a\u2013f) %X Unsigned hexadecimal integer (uppercase A\u2013F) %hd / %ld / %lld Short, long, or long long integers (length modifiers) Note: if you are using any of the unsigned specifiers, don't pass it any negative numbers. If you are using any of the long length modifiers you should add a corresponding literal suffix ( L , LL ) to the value that you pass to printf . printf(\"%ld\\n\", 5000000000L); // long (suffix L required) printf(\"%lld\\n\", 9000000000000LL); // long long (suffix LL required)","title":"Integers"},{"location":"wk_one/#floating-point-numbers","text":"Specifier Description %e / %E Exponential (scientific) notation (e.g., 1.23e+02 or 1.23E+02 ) %f / %F Fixed-point notation %g / %G Uses either %f or %e ( %E ) depending on value\u2019s magnitude, with no trailing zeros %Lf / %Le / %Lg Long double (length modifier L ) The default precision is 6 digits after the decimal (for %f ) or 6 significant digits (for %g / %G ). Rounding : %e , %E , and %g perform rounding; %f shows exact decimals. %g / %G automatically chooses the shortest visual representation for a given number: Chooses %e if the exponent is < -4 or \u2265 precision. Otherwise chooses %f . Removes trailing zeros. Omits the decimal point if the fractional part is zero. #include <stdio.h> int main(void) { printf(\"%g\\n\", 87.0); // 87 // whole number, fractional part is zero so \".0\" is suppressed printf(\"%g\\n\", 87.50); // 87.5 // fractional part kept, trailing zero removed printf(\"%g\\n\", 87.25); // 87.25 // fractional part kept, no trailing zeros to remove printf(\"%g\\n\", 0.0000875); // 8.75e-05 // exponent < -4, so %e format is chosen printf(\"%g\\n\", 8750000.0); // 8.75e+06 // exponent \u2265 precision (6), so %e format is chosen printf(\"%#g\\n\", 87.0); // 87.0000 // '#' flag forces decimal point and trailing zeros up to precision return 0; }","title":"Floating-Point Numbers"},{"location":"wk_one/#strings-and-characters","text":"%c prints a single char %s prints a null-terminated string ( char* ), stops at '\\0' Missing null terminator or wrong format specifier (e.g., %s with a char ) undefined behavior, often a crash Compilers usually don\u2019t catch format string errors \u2014 they show up only at runtime.","title":"Strings and Characters"},{"location":"wk_one/#pointers","text":"Specifier Description %p Displays a pointer (address) in an implementation-defined way (commonly hexadecimal) %p expects a pointer argument (e.g., &x , or a char* , int* , etc.). The exact format of the address depends on the system, but is typically hexadecimal. Useful for debugging to confirm memory addresses.","title":"Pointers"},{"location":"wk_one/#field-width","text":"You can control the minimum number of characters used when printing a value by specifying a field width . If the value has fewer characters than the field width then it is padded (by default with spaces). Note : If the value has more characters than the field width then the full value is printed (field width is ignored). That is to say, it does not truncate the output. #include <stdio.h> int main(void) { printf(\"%4d\\n\", 1); // 1 printf(\"%4d\\n\", 12); // 12 printf(\"%4d\\n\", 123); // 123 printf(\"%4d\\n\", 1234); // 1234 printf(\"%4d\\n\", 12345); // 12345 (too wide, prints fully) printf(\"%4d\\n\", -1); // -1 printf(\"%4d\\n\", -12); // -12 printf(\"%4d\\n\", -123); // -123 printf(\"%4d\\n\", -1234); // -1234 printf(\"%4d\\n\", -12345); // -12345 }","title":"Field Width"},{"location":"wk_one/#negative-values","text":"If the value has a negative sign, it will use up one of the field width characters: #include <stdio.h> int main(void) { printf(\"BEFORE%4dAFTER\\n\", 1); //BEFORE 1AFTER printf(\"BEFORE%4dAFTER\\n\", -1); //BEFORE -1AFTER // In the second example, there are only 2 spaces. }","title":"Negative Values"},{"location":"wk_one/#dynamic-widths","text":"Instead of providing a number, you can pass * instead and then supply the width as one of the values passed instead. This works for precision as well. printf(\"BEFORE%*.*fAFTER\", 7, 2, 98.736); // BEFORE 98.74AFTER // 7 \u2192 total field width (minimum size, includes digits, decimal point, and padding) // 2 \u2192 precision (number of digits after the decimal point)","title":"Dynamic Widths"},{"location":"wk_one/#format-flags","text":"","title":"Format Flags"},{"location":"wk_one/#alignment","text":"By default, values are right-aligned in the field. To make them left-aligned , add a - before the field width: #include <stdio.h> int main(void) { printf(\"BEFORE%4dAFTER\\n\", 1); //BEFORE 1AFTER printf(\"BEFORE%-4dAFTER\\n\", 1); //BEFORE1 AFTER }","title":"Alignment"},{"location":"wk_one/#sign-control-for-numbers","text":"By default, only negative numbers are printed with a sign ( - ). You can control how positive numbers appear using flags: + : always print a sign ( + for positive, - for negative). space ( ' ' ): print a space in front of positive numbers (negative numbers still get - ). This can be useful for aligning columns of positive and negative numbers. #include <stdio.h> int main(void) { printf(\"%d\\n\", 42); // 42 printf(\"%+d\\n\", 42); // +42 printf(\"% d\\n\", 42); // 42 (leading space) printf(\"%d\\n\", -42); // -42 printf(\"%+d\\n\", -42); // -42 printf(\"% d\\n\", -42); // -42 }","title":"Sign Control (for numbers)"},{"location":"wk_one/#alternate-form-flag","text":"The # flag modifies how certain values are displayed: Octal ( %o ) : prefixes the value with 0 . Hexadecimal ( %x / %X ) : prefixes the value with 0x or 0X . Floating-point ( %f , %e , %E , %g , %G ) : forces a decimal point to appear, even if the fractional part is zero. For %g / %G , it also prevents trailing zeros from being removed. #include <stdio.h> int main(void) { int c = 1427; double p = 1427.0; printf(\"%o\\n\", c); // 2623 printf(\"%#o\\n\", c); // 02623 printf(\"%x\\n\", c); // 593 printf(\"%#x\\n\", c); // 0x593 printf(\"%X\\n\", c); // 593 printf(\"%#X\\n\", c); // 0X593 printf(\"%g\\n\", p); // 1427 printf(\"%#g\\n\", p); // 1427.00 (decimal point forced, trailing zeros kept) }","title":"Alternate Form (# Flag)"},{"location":"wk_one/#zero-padding-0-flag","text":"By default, extra space in a field width is filled with spaces. The 0 flag changes this so that extra space is filled with leading zeros . Works with integers and floating-point numbers. Often combined with the + flag to show signs with padded numbers. Padding occurs after the sign, not before.","title":"Zero Padding (0 Flag)"},{"location":"wk_one/#example","text":"#include <stdio.h> int main(void) { printf(\"%9d\\n\", 452); // \" 452\" (spaces) printf(\"%09d\\n\", 452); // \"000000452\" (zeros) printf(\"%+09d\\n\", 452); // \"+00000452\" printf(\"%09d\\n\", -452); // \"-00000452\" }","title":"Example"},{"location":"wk_one/#literals-and-escape-sequences","text":"Characters in a format string that are not part of a conversion specification are printed literally. Escape sequences allow you to include special characters in strings that cannot be typed directly or would otherwise be ambiguous. Escape Description \\' Single quote ( ' ) \\\" Double quote ( \" ) \\? Question mark ( ? ) \\\\ Backslash ( \\ ) \\a Alert (bell/flash) \\b Backspace \\f Form feed (new page) \\n Newline \\r Carriage return \\t Horizontal tab \\v Vertical tab %% Percent symbol ( % ) #include <stdio.h> int main(void) { printf(\"Hello\\tWorld\\n\"); // tab between words, newline at end printf(\"Path: C:\\\\temp\\n\"); // prints: Path: C:\\temp printf(\"Beep!\\a\\n\"); // may cause a sound or window flash printf(\"CPU usage: 95%%\\n\"); // CPU usage: 95% } Why %% isn\u2019t like \\n (click to expand) Backslash escapes (like \\n , \\t , \\? ) are language features handled at compile time, because they solve parsing or representation issues in string literals. Percent escapes (like %d , %% ) are library features , defined only for functions such as printf / scanf and interpreted at runtime. In short: \\n is replaced by the compiler, while %% is handled later by printf .","title":"Literals and Escape Sequences"},{"location":"wk_three/","text":"Week 3 This week covers structures and typedefs . Structures A structure is a collection of related variables grouped under one name. In the C standard, structures are referred to as aggregates . The struct keyword is used to define a structure type: // A structure for representing a playing card. struct card { const char *face; const char *suit; }; // Note: a semicolon is required after the closing brace. The example above defines a new structure type named card . The variables declared inside the braces ( face and suit ) are called members . Since this type definition is a declaration , a semicolon must follow the closing brace. Member Types Structures can contain members of different types. However, a structure cannot contain a member that is an instance of its own type. For example, the following is invalid: // Invalid: a structure cannot contain an instance of itself. struct card { const char *face; const char *suit; struct card nextCard; // Invalid }; To work around this, use a pointer to the same type: // Valid: a structure can contain a pointer to its own type. struct card { const char *face; const char *suit; struct card *nextCard; // Valid }; This pattern is commonly used for creating nodes in a linked list. Defining Variables of Structure Types Structure definitions alone only create a new type that can be used later in code; they do not reserve any space in memory. A structure definition is essentially a blueprint. To begin reserving memory for variables, use the following syntax: // create a new card struct struct card myCard; // or create an array of card structs struct card deck[52]; // or create a pointer to a card struct struct card *cardPtr; You can also create variables of a struct during the definition of the struct by providing a comma-separated list of variable names after the closing brace of the struct but before the ending semicolon of the declaration: struct card { const char *face; const char *suit; } myCard, deck[52], *cardPtr; Structures without Tag Names You can define a struct without a tag name: struct { // NOTE: no \"card\" tag name const char *face; const char *suit; } exampleCard; However, without a tag name, you cannot declare additional variables of this type later in the program. Therefore, you must provide variable names during the declaration to use them. Example // This defines and declares two variables immediately. struct { int x; int y; } point1, point2; Comparing Structure Objects Structures cannot be compared using the operators == or != because structure members may not be stored in consecutive bytes of memory. Compilers often insert padding bytes (known as holes ) to align data members according to their type\u2019s alignment requirements. These holes can contain garbage values, which would cause comparisons between two otherwise identical structures to fail. Example of holes Suppose we have a struct defined as follows, with two variables of that type named sample1 and sample2 . struct example { char c; int i; } sample1, sample2; Initially, the variables contain garbage values: We then assign values to the members of sample1 : sample1.c = 'G'; sample1.i = 42069; Notice that the int portion begins at byte 4. This is because integers *must* align on a 4-byte boundary, leaving a gap in bytes 1\u20133. Next, we assign the same values to the members of sample2 : sample2.c = 'G'; sample2.i = 42069; When comparing the two, the visible members appear equivalent, but the hidden padding bytes contain different values. Therefore, the two structs are **not** equal when compared byte-for-byte. More about structure packing When structures are stored in memory, the compiler may insert padding bytes between members to align data according to hardware requirements. This can improve performance but may waste space. You can minimize wasted space by ordering structure members from largest to smallest type (for example, `double` -> `int` -> `char`). Some compilers also support pragmas such as `#pragma pack` to control alignment, though this is compiler-specific and should be used with caution.","title":"Week 3 - Structures and typedef"},{"location":"wk_three/#week-3","text":"This week covers structures and typedefs .","title":"Week 3"},{"location":"wk_three/#structures","text":"A structure is a collection of related variables grouped under one name. In the C standard, structures are referred to as aggregates . The struct keyword is used to define a structure type: // A structure for representing a playing card. struct card { const char *face; const char *suit; }; // Note: a semicolon is required after the closing brace. The example above defines a new structure type named card . The variables declared inside the braces ( face and suit ) are called members . Since this type definition is a declaration , a semicolon must follow the closing brace.","title":"Structures"},{"location":"wk_three/#member-types","text":"Structures can contain members of different types. However, a structure cannot contain a member that is an instance of its own type. For example, the following is invalid: // Invalid: a structure cannot contain an instance of itself. struct card { const char *face; const char *suit; struct card nextCard; // Invalid }; To work around this, use a pointer to the same type: // Valid: a structure can contain a pointer to its own type. struct card { const char *face; const char *suit; struct card *nextCard; // Valid }; This pattern is commonly used for creating nodes in a linked list.","title":"Member Types"},{"location":"wk_three/#defining-variables-of-structure-types","text":"Structure definitions alone only create a new type that can be used later in code; they do not reserve any space in memory. A structure definition is essentially a blueprint. To begin reserving memory for variables, use the following syntax: // create a new card struct struct card myCard; // or create an array of card structs struct card deck[52]; // or create a pointer to a card struct struct card *cardPtr; You can also create variables of a struct during the definition of the struct by providing a comma-separated list of variable names after the closing brace of the struct but before the ending semicolon of the declaration: struct card { const char *face; const char *suit; } myCard, deck[52], *cardPtr;","title":"Defining Variables of Structure Types"},{"location":"wk_three/#structures-without-tag-names","text":"You can define a struct without a tag name: struct { // NOTE: no \"card\" tag name const char *face; const char *suit; } exampleCard; However, without a tag name, you cannot declare additional variables of this type later in the program. Therefore, you must provide variable names during the declaration to use them. Example // This defines and declares two variables immediately. struct { int x; int y; } point1, point2;","title":"Structures without Tag Names"},{"location":"wk_three/#comparing-structure-objects","text":"Structures cannot be compared using the operators == or != because structure members may not be stored in consecutive bytes of memory. Compilers often insert padding bytes (known as holes ) to align data members according to their type\u2019s alignment requirements. These holes can contain garbage values, which would cause comparisons between two otherwise identical structures to fail. Example of holes Suppose we have a struct defined as follows, with two variables of that type named sample1 and sample2 . struct example { char c; int i; } sample1, sample2; Initially, the variables contain garbage values: We then assign values to the members of sample1 : sample1.c = 'G'; sample1.i = 42069; Notice that the int portion begins at byte 4. This is because integers *must* align on a 4-byte boundary, leaving a gap in bytes 1\u20133. Next, we assign the same values to the members of sample2 : sample2.c = 'G'; sample2.i = 42069; When comparing the two, the visible members appear equivalent, but the hidden padding bytes contain different values. Therefore, the two structs are **not** equal when compared byte-for-byte. More about structure packing When structures are stored in memory, the compiler may insert padding bytes between members to align data according to hardware requirements. This can improve performance but may waste space. You can minimize wasted space by ordering structure members from largest to smallest type (for example, `double` -> `int` -> `char`). Some compilers also support pragmas such as `#pragma pack` to control alignment, though this is compiler-specific and should be used with caution.","title":"Comparing Structure Objects"},{"location":"wk_two/","text":"Week 2 This week covers formatted input using scanf and recursion. Formatted Input with scanf scanf statements contain a format control string that specifies how input should be read, followed by pointers to variables where the input will be stored. Key capabilities: Inputting all types of data. Inputting specific characters from an input stream. Skipping specific characters in an input stream. scanf Syntax scanf(format-control-string, other-arguments); format-control-string \u2013 describes input formats using conversion specifiers. other-arguments \u2013 pointers to variables that will receive the input. * Prompt the user for one (or a few) items at a time. * Avoid asking for many inputs in one statement. * Always handle the possibility of incorrect data (e.g., invalid integers or strings with missing punctuation). Conversion Specifiers Like printf , scanf uses conversion specifiers to handle different data types. Some specifiers differ between input ( scanf ) and output ( printf ). Specifier Description Integers %d Reads a signed decimal integer int* %i Reads signed decimal, octal, or hexadecimal int* %o Reads an octal integer unsigned int* %u Reads an unsigned decimal integer unsigned int* %x / %X Reads a hexadecimal integer unsigned int* h , l , ll Length modifiers ( short , long , long long ) for integers Floating-point %e , %E , %f , %F , %g , %G Reads a floating-point value float* / double* l or L Length modifiers for double or long double Characters & Strings %c Reads a single character char* (no \\0 added) %s Reads a string char[] (terminates with \\0 ) Scan set %[...] Reads a set of characters into a string Miscellaneous %p Reads an address (pointer format) %n Stores number of characters read so far int* %% Skips a literal % in input Using Scan Sets A scan set allows input of only certain characters, defined inside square brackets [] after a % in the format string. Input continues until a character not in the scan set is encountered. Example: using %[aeiou] reads only vowels. #include <stdio.h> int main(void) { char z[9] = \"\"; printf(\"%s\", \"Enter string: \"); scanf(\"%8[aeiou]\", z); // only vowels printf(\"The input was \\\"%s\\\"\\n\", z); return 0; } Input: oeeeooahah \u2192 stops at h , outputs oeeeooa . Inverting the Scan Set An inverted scan set matches characters not in the given set. Use a ^ inside the brackets to invert. Example: %[^aeiou] reads only consonants and other non-vowels. #include <stdio.h> int main(void) { char z[9] = \"\"; printf(\"%s\", \"Enter a string: \"); scanf(\"%8[^aeiou]\", z); // non-vowels printf(\"The input was \\\"%s\\\"\\n\", z); return 0; } Input: String \u2192 stops at vowel i , outputs Str . Using Field Widths A field width can be applied in a scanf conversion specifier to control how many characters are read from the input stream. Input is read as groups of digits/characters of the specified width. Useful when parsing fixed-length data such as IDs, phone numbers, or formatted strings. Example: %2d reads exactly 2 digits into one variable, then %d reads the rest. #include <stdio.h> int main(void) { int x = 0; int y = 0; printf(\"%s\", \"Enter a six digit integer: \"); scanf(\"%2d%d\", &x, &y); // first 2 digits go to x, remaining go to y printf(\"The integers input were %d and %d\\n\", x, y); return 0; } Input: 123456 \u2192 output: 12 and 3456 . Skipping Characters in an Input Stream scanf can skip unnecessary characters in the input stream: Whitespace characters (space, tab, newline) are skipped automatically at the beginning of most format specifiers. Literal characters in the format string (like - or / ) must match in the input and are discarded. Example: scanf(\"%d-%d-%d\", &month, &day, &year); Input: 11-10-1999 \u2192 assigns 11, 10, 1999 while skipping the dashes. Assignment Suppression Character The * assignment suppression character allows scanf to read and discard input without storing it in a variable. Example: %*c reads and discards a single character. #include <stdio.h> int main(void) { int month = 0; int day = 0; int year = 0; printf(\"%s\", \"Enter a date in the form mm-dd-yyyy: \"); scanf(\"%d%*c%d%*c%d\", &month, &day, &year); // ignores separators printf(\"month = %d day = %d year = %d\\n\", month, day, year); printf(\"%s\", \"Enter a date in the form mm/dd/yyyy: \"); scanf(\"%d%*c%d%*c%d\", &month, &day, &year); // works with / printf(\"month = %d day = %d year = %d\\n\", month, day, year); return 0; } Input: 07-04-2021 \u2192 output: 7 4 2021 Input: 01/01/2021 \u2192 output: 1 1 2021 Recursion A recursive function is one that calls itself, either directly or indirectly through another function. Recursion is a common but complex topic; here we look at its basic structure. Base Cases and Recursive Calls A recursive function solves problems by dividing them into: A base case \u2013 the simplest case the function knows how to solve directly. A recursive case \u2013 a more complex problem broken down into smaller versions of itself. The recursive case must resemble the original problem but be simpler or smaller, ensuring progress toward the base case. Each recursive call works on the reduced problem until the base case is reached. Recursive Step When a recursive call is made: The function pauses its current execution and launches a fresh copy of itself to handle the smaller problem. This process can repeat many times, generating multiple recursive calls. Each call must eventually converge on the base case, where recursion stops. Returning Results Each recursive call includes a return statement. When the base case is reached, the result is returned back to the previous call. This chain of returns continues until the result reaches the original caller. In summary: Base case: directly solvable, no further recursion. Recursive step: reduces the problem and calls the function again. Convergence: repeated recursion eventually reaches the base case, then unwinds with results. Example: Factorial #include <stdio.h> int factorial(int n) { if (n == 0) { // base case return 1; } else { return n * factorial(n - 1); // recursive case } } int main(void) { int num = 5; printf(\"Factorial of %d is %d\\n\", num, factorial(num)); return 0; } Input: 5 \u2192 Output: 120 Stack Visualization Recursive calls can be visualized as a stack. Each new call is pushed onto the stack showing the pending computation, and results are popped once the base case is reached. Factorial(5): Push (calls): Factorial(5) -> 5 * Factorial(4) Factorial(4) -> 4 * Factorial(3) Factorial(3) -> 3 * Factorial(2) Factorial(2) -> 2 * Factorial(1) Factorial(1) -> 1 * Factorial(0) Factorial(0) -> 1 (base case) Pop (returns): Factorial(1) = 1 * Factorial(0) = 1 * 1 = 1 Factorial(2) = 2 * Factorial(1) = 2 * 1 = 2 Factorial(3) = 3 * Factorial(2) = 3 * 2 = 6 Factorial(4) = 4 * Factorial(3) = 4 * 6 = 24 Factorial(5) = 5 * Factorial(4) = 5 * 24 = 120","title":"Week 2 - scanf and Recursion"},{"location":"wk_two/#week-2","text":"This week covers formatted input using scanf and recursion.","title":"Week 2"},{"location":"wk_two/#formatted-input-with-scanf","text":"scanf statements contain a format control string that specifies how input should be read, followed by pointers to variables where the input will be stored. Key capabilities: Inputting all types of data. Inputting specific characters from an input stream. Skipping specific characters in an input stream.","title":"Formatted Input with scanf"},{"location":"wk_two/#scanf-syntax","text":"scanf(format-control-string, other-arguments); format-control-string \u2013 describes input formats using conversion specifiers. other-arguments \u2013 pointers to variables that will receive the input. * Prompt the user for one (or a few) items at a time. * Avoid asking for many inputs in one statement. * Always handle the possibility of incorrect data (e.g., invalid integers or strings with missing punctuation).","title":"scanf Syntax"},{"location":"wk_two/#conversion-specifiers","text":"Like printf , scanf uses conversion specifiers to handle different data types. Some specifiers differ between input ( scanf ) and output ( printf ). Specifier Description Integers %d Reads a signed decimal integer int* %i Reads signed decimal, octal, or hexadecimal int* %o Reads an octal integer unsigned int* %u Reads an unsigned decimal integer unsigned int* %x / %X Reads a hexadecimal integer unsigned int* h , l , ll Length modifiers ( short , long , long long ) for integers Floating-point %e , %E , %f , %F , %g , %G Reads a floating-point value float* / double* l or L Length modifiers for double or long double Characters & Strings %c Reads a single character char* (no \\0 added) %s Reads a string char[] (terminates with \\0 ) Scan set %[...] Reads a set of characters into a string Miscellaneous %p Reads an address (pointer format) %n Stores number of characters read so far int* %% Skips a literal % in input","title":"Conversion Specifiers"},{"location":"wk_two/#using-scan-sets","text":"A scan set allows input of only certain characters, defined inside square brackets [] after a % in the format string. Input continues until a character not in the scan set is encountered. Example: using %[aeiou] reads only vowels. #include <stdio.h> int main(void) { char z[9] = \"\"; printf(\"%s\", \"Enter string: \"); scanf(\"%8[aeiou]\", z); // only vowels printf(\"The input was \\\"%s\\\"\\n\", z); return 0; } Input: oeeeooahah \u2192 stops at h , outputs oeeeooa .","title":"Using Scan Sets"},{"location":"wk_two/#inverting-the-scan-set","text":"An inverted scan set matches characters not in the given set. Use a ^ inside the brackets to invert. Example: %[^aeiou] reads only consonants and other non-vowels. #include <stdio.h> int main(void) { char z[9] = \"\"; printf(\"%s\", \"Enter a string: \"); scanf(\"%8[^aeiou]\", z); // non-vowels printf(\"The input was \\\"%s\\\"\\n\", z); return 0; } Input: String \u2192 stops at vowel i , outputs Str .","title":"Inverting the Scan Set"},{"location":"wk_two/#using-field-widths","text":"A field width can be applied in a scanf conversion specifier to control how many characters are read from the input stream. Input is read as groups of digits/characters of the specified width. Useful when parsing fixed-length data such as IDs, phone numbers, or formatted strings. Example: %2d reads exactly 2 digits into one variable, then %d reads the rest. #include <stdio.h> int main(void) { int x = 0; int y = 0; printf(\"%s\", \"Enter a six digit integer: \"); scanf(\"%2d%d\", &x, &y); // first 2 digits go to x, remaining go to y printf(\"The integers input were %d and %d\\n\", x, y); return 0; } Input: 123456 \u2192 output: 12 and 3456 .","title":"Using Field Widths"},{"location":"wk_two/#skipping-characters-in-an-input-stream","text":"scanf can skip unnecessary characters in the input stream: Whitespace characters (space, tab, newline) are skipped automatically at the beginning of most format specifiers. Literal characters in the format string (like - or / ) must match in the input and are discarded. Example: scanf(\"%d-%d-%d\", &month, &day, &year); Input: 11-10-1999 \u2192 assigns 11, 10, 1999 while skipping the dashes.","title":"Skipping Characters in an Input Stream"},{"location":"wk_two/#assignment-suppression-character","text":"The * assignment suppression character allows scanf to read and discard input without storing it in a variable. Example: %*c reads and discards a single character. #include <stdio.h> int main(void) { int month = 0; int day = 0; int year = 0; printf(\"%s\", \"Enter a date in the form mm-dd-yyyy: \"); scanf(\"%d%*c%d%*c%d\", &month, &day, &year); // ignores separators printf(\"month = %d day = %d year = %d\\n\", month, day, year); printf(\"%s\", \"Enter a date in the form mm/dd/yyyy: \"); scanf(\"%d%*c%d%*c%d\", &month, &day, &year); // works with / printf(\"month = %d day = %d year = %d\\n\", month, day, year); return 0; } Input: 07-04-2021 \u2192 output: 7 4 2021 Input: 01/01/2021 \u2192 output: 1 1 2021","title":"Assignment Suppression Character"},{"location":"wk_two/#recursion","text":"A recursive function is one that calls itself, either directly or indirectly through another function. Recursion is a common but complex topic; here we look at its basic structure.","title":"Recursion"},{"location":"wk_two/#base-cases-and-recursive-calls","text":"A recursive function solves problems by dividing them into: A base case \u2013 the simplest case the function knows how to solve directly. A recursive case \u2013 a more complex problem broken down into smaller versions of itself. The recursive case must resemble the original problem but be simpler or smaller, ensuring progress toward the base case. Each recursive call works on the reduced problem until the base case is reached.","title":"Base Cases and Recursive Calls"},{"location":"wk_two/#recursive-step","text":"When a recursive call is made: The function pauses its current execution and launches a fresh copy of itself to handle the smaller problem. This process can repeat many times, generating multiple recursive calls. Each call must eventually converge on the base case, where recursion stops.","title":"Recursive Step"},{"location":"wk_two/#returning-results","text":"Each recursive call includes a return statement. When the base case is reached, the result is returned back to the previous call. This chain of returns continues until the result reaches the original caller. In summary: Base case: directly solvable, no further recursion. Recursive step: reduces the problem and calls the function again. Convergence: repeated recursion eventually reaches the base case, then unwinds with results.","title":"Returning Results"},{"location":"wk_two/#example-factorial","text":"#include <stdio.h> int factorial(int n) { if (n == 0) { // base case return 1; } else { return n * factorial(n - 1); // recursive case } } int main(void) { int num = 5; printf(\"Factorial of %d is %d\\n\", num, factorial(num)); return 0; } Input: 5 \u2192 Output: 120","title":"Example: Factorial"},{"location":"wk_two/#stack-visualization","text":"Recursive calls can be visualized as a stack. Each new call is pushed onto the stack showing the pending computation, and results are popped once the base case is reached. Factorial(5): Push (calls): Factorial(5) -> 5 * Factorial(4) Factorial(4) -> 4 * Factorial(3) Factorial(3) -> 3 * Factorial(2) Factorial(2) -> 2 * Factorial(1) Factorial(1) -> 1 * Factorial(0) Factorial(0) -> 1 (base case) Pop (returns): Factorial(1) = 1 * Factorial(0) = 1 * 1 = 1 Factorial(2) = 2 * Factorial(1) = 2 * 1 = 2 Factorial(3) = 3 * Factorial(2) = 3 * 2 = 6 Factorial(4) = 4 * Factorial(3) = 4 * 6 = 24 Factorial(5) = 5 * Factorial(4) = 5 * 24 = 120","title":"Stack Visualization"}]}