{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"COMP2801 - Application Development with C Overview For full course information bcit.ca . Course taken in Fall 2025 term ( outline ) with Bob Langelaan . Midterm and Final in-person 4 quizzes, one each in weeks 3, 5, 8, and 11 right at the start of class 8 labs must be submitted to get a mark for labs There will be 4 assignments The course continues from COMP2701 and just follows C How to Program -- Ninth Edition .","title":"Home"},{"location":"#comp2801-application-development-with-c","text":"","title":"COMP2801 - Application Development with C"},{"location":"#overview","text":"For full course information bcit.ca . Course taken in Fall 2025 term ( outline ) with Bob Langelaan . Midterm and Final in-person 4 quizzes, one each in weeks 3, 5, 8, and 11 right at the start of class 8 labs must be submitted to get a mark for labs There will be 4 assignments The course continues from COMP2701 and just follows C How to Program -- Ninth Edition .","title":"Overview"},{"location":"wk_one/","text":"Week 1 Streams Streams are sequences of bytes used for input and output. Input : Data flows from a device (keyboard, disk, network, etc.) into main memory. Output : Data flows from main memory to a device (screen, printer, disk, network, etc.). At program start, three standard streams are available: Standard input ( stdin ) \u2013 usually from the keyboard. Standard output ( stdout ) \u2013 usually to the screen. Standard error ( stderr ) \u2013 also to the screen, for error messages. Redirection : Operating systems allow these streams to be redirected to other devices or files. printf Formatting As we learned in the previous course, printf can be used to format output to stdout using conversion specifications . We will now take a deeper look at some of the tools available to us. Integers There are a number of different conversion specifiers for integers. Specifier Description %d Signed decimal integer %i Signed decimal integer (same as %d ) %o Unsigned octal integer %u Unsigned decimal integer %x Unsigned hexadecimal integer (lowercase a\u2013f) %X Unsigned hexadecimal integer (uppercase A\u2013F) %hd / %ld / %lld Short, long, or long long integers (length modifiers) Note: if you are using any of the unsigned specifiers, don't pass it any negative numbers. If you are using any of the long length modifiers you should add a corresponding literal suffix ( L , LL ) to the value that you pass to printf . printf(\"%ld\\n\", 5000000000L); // long (suffix L required) printf(\"%lld\\n\", 9000000000000LL); // long long (suffix LL required) Floating-Point Numbers Specifier Description %e / %E Exponential (scientific) notation (e.g., 1.23e+02 or 1.23E+02 ) %f / %F Fixed-point notation %g / %G Uses either %f or %e ( %E ) depending on value\u2019s magnitude, with no trailing zeros %Lf / %Le / %Lg Long double (length modifier L ) The default precision is 6 digits after the decimal (for %f ) or 6 significant digits (for %g / %G ). Rounding : %e , %E , and %g perform rounding; %f shows exact decimals. %g / %G automatically chooses the shortest visual representation for a given number: Chooses %e if the exponent is < -4 or \u2265 precision. Otherwise chooses %f . Removes trailing zeros. Omits the decimal point if the fractional part is zero. #include <stdio.h> int main(void) { printf(\"%g\\n\", 87.0); // 87 // whole number, fractional part is zero so \".0\" is suppressed printf(\"%g\\n\", 87.50); // 87.5 // fractional part kept, trailing zero removed printf(\"%g\\n\", 87.25); // 87.25 // fractional part kept, no trailing zeros to remove printf(\"%g\\n\", 0.0000875); // 8.75e-05 // exponent < -4, so %e format is chosen printf(\"%g\\n\", 8750000.0); // 8.75e+06 // exponent \u2265 precision (6), so %e format is chosen printf(\"%#g\\n\", 87.0); // 87.0000 // '#' flag forces decimal point and trailing zeros up to precision return 0; } Strings and Characters (Review) %c \u2192 prints a single char %s \u2192 prints a null-terminated string ( char* ), stops at '\\0' Missing null terminator or wrong format specifier (e.g., %s with a char ) \u2192 undefined behavior, often a crash Compilers usually don\u2019t catch format string errors \u2014 they show up only at runtime.","title":"Week 1 - Introduction to C & Data Types"},{"location":"wk_one/#week-1","text":"","title":"Week 1"},{"location":"wk_one/#streams","text":"Streams are sequences of bytes used for input and output. Input : Data flows from a device (keyboard, disk, network, etc.) into main memory. Output : Data flows from main memory to a device (screen, printer, disk, network, etc.). At program start, three standard streams are available: Standard input ( stdin ) \u2013 usually from the keyboard. Standard output ( stdout ) \u2013 usually to the screen. Standard error ( stderr ) \u2013 also to the screen, for error messages. Redirection : Operating systems allow these streams to be redirected to other devices or files.","title":"Streams"},{"location":"wk_one/#printf-formatting","text":"As we learned in the previous course, printf can be used to format output to stdout using conversion specifications . We will now take a deeper look at some of the tools available to us.","title":"printf Formatting"},{"location":"wk_one/#integers","text":"There are a number of different conversion specifiers for integers. Specifier Description %d Signed decimal integer %i Signed decimal integer (same as %d ) %o Unsigned octal integer %u Unsigned decimal integer %x Unsigned hexadecimal integer (lowercase a\u2013f) %X Unsigned hexadecimal integer (uppercase A\u2013F) %hd / %ld / %lld Short, long, or long long integers (length modifiers) Note: if you are using any of the unsigned specifiers, don't pass it any negative numbers. If you are using any of the long length modifiers you should add a corresponding literal suffix ( L , LL ) to the value that you pass to printf . printf(\"%ld\\n\", 5000000000L); // long (suffix L required) printf(\"%lld\\n\", 9000000000000LL); // long long (suffix LL required)","title":"Integers"},{"location":"wk_one/#floating-point-numbers","text":"Specifier Description %e / %E Exponential (scientific) notation (e.g., 1.23e+02 or 1.23E+02 ) %f / %F Fixed-point notation %g / %G Uses either %f or %e ( %E ) depending on value\u2019s magnitude, with no trailing zeros %Lf / %Le / %Lg Long double (length modifier L ) The default precision is 6 digits after the decimal (for %f ) or 6 significant digits (for %g / %G ). Rounding : %e , %E , and %g perform rounding; %f shows exact decimals. %g / %G automatically chooses the shortest visual representation for a given number: Chooses %e if the exponent is < -4 or \u2265 precision. Otherwise chooses %f . Removes trailing zeros. Omits the decimal point if the fractional part is zero. #include <stdio.h> int main(void) { printf(\"%g\\n\", 87.0); // 87 // whole number, fractional part is zero so \".0\" is suppressed printf(\"%g\\n\", 87.50); // 87.5 // fractional part kept, trailing zero removed printf(\"%g\\n\", 87.25); // 87.25 // fractional part kept, no trailing zeros to remove printf(\"%g\\n\", 0.0000875); // 8.75e-05 // exponent < -4, so %e format is chosen printf(\"%g\\n\", 8750000.0); // 8.75e+06 // exponent \u2265 precision (6), so %e format is chosen printf(\"%#g\\n\", 87.0); // 87.0000 // '#' flag forces decimal point and trailing zeros up to precision return 0; }","title":"Floating-Point Numbers"},{"location":"wk_one/#strings-and-characters-review","text":"%c \u2192 prints a single char %s \u2192 prints a null-terminated string ( char* ), stops at '\\0' Missing null terminator or wrong format specifier (e.g., %s with a char ) \u2192 undefined behavior, often a crash Compilers usually don\u2019t catch format string errors \u2014 they show up only at runtime.","title":"Strings and Characters (Review)"}]}