{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"COMP2801 - Application Development with C","text":""},{"location":"#overview","title":"Overview","text":"<p>For full course information bcit.ca. Course taken in Fall 2025 term (outline) with Bob Langelaan.</p> <ul> <li>Midterm and Final in-person</li> <li>4 quizzes, one each in weeks 3, 5, 8, and 11<ul> <li>right at the start of class</li> </ul> </li> <li>8 labs<ul> <li>must be submitted to get a mark for labs</li> </ul> </li> <li>There will be 4 assignments</li> </ul> <p>The course continues from COMP2701 and just follows C How to Program -- Ninth Edition.</p>"},{"location":"final/","title":"Final Exam Study Notes","text":""},{"location":"final/#complexity-sorting","title":"Complexity &amp; Sorting","text":""},{"location":"final/#big-o-notation","title":"Big O Notation","text":"<p>Big O describes the limiting behaviour or worst-case performance of a function as the number of inputs ($n$) tends toward large values.</p> <p>Common Complexities</p> <ul> <li> <p>$O(1)$ Constant     Time stays the same regardless of $n$ (e.g., array access).</p> </li> <li> <p>$O(\\log n)$ Logarithmic     Doubling $n$ adds constant time (e.g., Binary Search).</p> </li> <li> <p>$O(n)$ Linear     Proportional to $n$ (e.g., simple loop).</p> </li> <li> <p>$O(n \\log n)$ Log Linear     Linear and logarithmic combined (e.g., Merge sort).</p> </li> <li> <p>$O(n^2)$ Quadratic     Grows as square of $n$ (e.g., nested loops).</p> </li> <li> <p>$O(n!)$ Factorial     Work explodes; considers all permutations.</p> </li> </ul> <p>Rules of Thumb: 1.  Drop Constants: $O(2n) \\rightarrow O(n)$. 2.  Add Sequential Operations: $O(n) + O(n) \\rightarrow O(n)$. 3.  Multiply Nested Loops: Inner loop work multiplies outer loop work. 4.  Keep Dominant Term: $O(n^3 + n \\log n) \\rightarrow O(n^3)$.</p>"},{"location":"final/#sorting-algorithms","title":"Sorting Algorithms","text":"Algorithm Process Complexity Selection Sort 1. Find the smallest element in the unsorted region.2. Swap it with the first element of that region.3. Repeat until sorted. $O(n^2)$ Insertion Sort 1. Take next element from unsorted.2. Compare with sorted portion and shift larger elements right.3. Insert into correct position. $O(n^2)$"},{"location":"final/#files-streams","title":"Files &amp; Streams","text":""},{"location":"final/#file-stream-model","title":"File &amp; Stream Model","text":"<p>Files are sequential streams of bytes with no inherent structure. * Standard Streams: <code>stdin</code>, <code>stdout</code>, <code>stderr</code> are opened automatically. * Practical Note: Always check if <code>fopen</code> returns <code>NULL</code> before proceeding.</p> <p>Example: Reading a Text File</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    // 1. Declare the FILE pointer\n    FILE *cfPtr; \n\n    int account;\n    char name[30];\n    double balance;\n\n    // 2. Open the file and check for NULL (Error)\n    // \"r\" mode opens an existing file for reading\n    if ((cfPtr = fopen(\"clients.txt\", \"r\")) == NULL) \n    {\n        printf(\"File could not be opened\\n\");\n    } \n    else \n    {\n        // 3. \"Priming Read\": Read the first item before entering the loop\n        fscanf(cfPtr, \"%d%s%lf\", &amp;account, name, &amp;balance);\n\n        // 4. Loop while the End of File (feof) has NOT been reached\n        while (!feof(cfPtr)) \n        {\n            // Process the data (e.g., print it)\n            printf(\"%-10d%-13s%7.2f\\n\", account, name, &amp;balance);\n\n            // 5. Read the NEXT record at the bottom of the loop\n            fscanf(cfPtr, \"%d%s%lf\", &amp;account, name, &amp;balance);\n        }\n\n        // 6. Close the file to release resources\n        fclose(cfPtr); \n    }\n    return 0;\n}\n</code></pre>"},{"location":"final/#sequential-access-text-files","title":"Sequential Access (Text Files)","text":"<p>Used for processing records in order. Warning: Text files cannot be safely modified in place because changing field lengths shifts all subsequent data.</p> <p>Functions: * <code>fscanf</code>: Parses formatted text. Returns the number of items successfully read. * <code>rewind(fp)</code>: Resets file pointer to the start, allowing you to scan a file multiple times.</p>"},{"location":"final/#random-access-binary-files","title":"Random Access (Binary Files)","text":"<p>Allows jumping to specific positions; ideal for fixed-size records like <code>structs</code>.</p> Mode Text Binary Meaning Read <code>\"r\"</code> <code>\"rb\"</code> Open existing. Fails if missing. Write <code>\"w\"</code> <code>\"wb\"</code> Create new. Overwrites existing. Update <code>\"r+\"</code> <code>\"rb+\"</code> Open existing for read/write. Essential for updating records in place. <p>Record Calculation Logic To find the byte offset of a specific record ID (e.g., account number):</p> <p>Reading a Binary File</p> <pre><code>#include &lt;stdio.h&gt;\n\nstruct clientData {\n    int acctNum;\n    char lastName[15];\n    char firstName[10];\n    double balance;\n};\n\nint main(void) {\n    FILE *cfPtr;\n    struct clientData client;\n\n    // 1. Open with \"rb\" (Read Binary)\n    if ((cfPtr = fopen(\"credit.dat\", \"rb\")) == NULL) {\n        printf(\"File could not be opened.\\n\");\n    } \n    else {\n        // --- WHAT YOU USE INSTEAD OF SCANNING ---\n\n        // A. Calculate the Offset\n        // Since records are fixed-size, Account 3 is located 2 records in.\n        // (Account 1 is at 0, Account 2 is at 1 * sizeof, etc.)\n        long offset = (3 - 1) * sizeof(struct clientData);\n\n        // B. Jump there (fseek)\n        // SEEK_SET means \"from the beginning of the file\"\n        fseek(cfPtr, offset, SEEK_SET);\n\n        // C. Copy the bytes (fread)\n        // Arguments: 1. Where to put it, 2. Size of one item, 3. How many items, 4. File pointer\n        size_t result = fread(&amp;client, sizeof(struct clientData), 1, cfPtr);\n\n        // D. Validation\n        // If result is 1, we found it. If 0, the file might only have 1 record!\n        if (result == 1 &amp;&amp; client.acctNum != 0) {\n            printf(\"Found Account 3: %s %s\\n\", client.firstName, client.lastName);\n        } else {\n            printf(\"Account 3 does not exist or is empty.\\n\");\n        }\n\n        fclose(cfPtr);\n    }\n    return 0;\n}\n</code></pre> <p>The \"Update Record\" Pattern To modify a specific record in a binary file, you must strictly follow this sequence: 1.  <code>fseek</code> to the record location. 2.  <code>fread</code> the record into a struct. 3.  Modify the struct in memory. 4.  <code>fseek</code> back to the start of that same record (often using <code>SEEK_CUR</code> with a negative offset). 5.  <code>fwrite</code> the updated struct over the old data.</p> <p><pre><code>// Move back one record size from current position\nfseek(fPtr, -(long)sizeof(ClientData), SEEK_CUR);\nfwrite(&amp;client, sizeof(ClientData), 1, fPtr);\n</code></pre> **</p>"},{"location":"final/#cli-shell-memory","title":"CLI, Shell &amp; Memory","text":""},{"location":"final/#cli-shell-operators","title":"CLI &amp; Shell Operators","text":"<p>Arguments: <code>int main(int argc, char *argv[])</code> * <code>argc</code>: Argument count (includes program name). * <code>argv</code>: Argument Vector (array of strings).</p> <p>Input Validation &amp; Conversion * Validation: Always check <code>argc</code> first to ensure the user provided the correct number of arguments. * Safe Conversion: Prefer <code>strtol</code> over <code>atoi</code> for converting strings to integers. <code>strtol</code> allows you to detect non-numeric characters via an <code>end</code> pointer.     <pre><code>long parsed = strtol(argv[i], &amp;end, 10);\nif (*end != '\\0') { /* Error: String contained non-digits */ }\n</code></pre> * Error Output: Use <code>fprintf(stderr, ...)</code> for error messages so they separate from standard output.</p> <p>Shell Operators</p> <ul> <li> <p><code>&gt;</code> Redirect (Overwrite)     Sends stdout to file, replacing it.</p> </li> <li> <p><code>&gt;&gt;</code> Redirect (Append)     Appends stdout to end of file.</p> </li> <li> <p><code>&lt;</code> Input Redirection     Uses file as stdin.</p> </li> <li> <p><code>|</code> Pipe     Connects stdout of one program to stdin of another.</p> </li> </ul>"},{"location":"final/#memory-management","title":"Memory Management","text":"<ul> <li><code>calloc(count, size)</code>: Allocates <code>n</code> elements and initializes all bits to zero.</li> <li><code>realloc(ptr, new_size)</code>: Resizes memory.<ul> <li>Doubling Strategy: When a dynamic array fills up, a common strategy is to double its capacity (<code>2 * capacity</code>) to reduce the number of expensive allocation calls.</li> <li>Safety: Never assign the return of <code>realloc</code> directly to your original pointer. If <code>realloc</code> fails (returns <code>NULL</code>), you lose the reference to your original data. <pre><code>int *new_values = realloc(values, sizeof *values * new_capacity);\nif (new_values == NULL) { /* Handle error, free old values */ }\nvalues = new_values;\n</code></pre></li> </ul> </li> </ul>"},{"location":"final/#other-topics","title":"Other Topics","text":"<ul> <li>Variable Arguments (<code>stdarg.h</code>):<ul> <li><code>va_start</code>: Initialize traversal.</li> <li><code>va_arg</code>: Read next argument (must know type).</li> <li><code>va_end</code>: Finalize.</li> </ul> </li> <li>Literal Suffixes: <code>U</code> (Unsigned), <code>L</code> (Long), <code>F</code> (Float) to control type/overflow.</li> <li><code>exit</code> / <code>atexit</code>: <code>exit</code> terminates and flushes streams; <code>atexit</code> registers cleanup functions to run on termination.</li> </ul>"},{"location":"final/#function-pointers-index-files","title":"Function Pointers &amp; Index Files","text":""},{"location":"final/#function-pointers","title":"Function Pointers","text":"<p>Stores the address of a function. * Syntax: <code>int (*fp)(int, int)</code> (Parentheses required to distinguish from function returning pointer).</p>"},{"location":"final/#qsort-and-comparators","title":"<code>qsort</code> and Comparators","text":"<p><code>qsort</code> uses a callback function to compare elements.</p> <p>Comparator Syntax: Must accept two <code>const void *</code> arguments. You must cast them to pointers of your specific data type (e.g., <code>Client *</code>) before accessing members.</p> <p>Advanced Comparison Patterns: 1.  Descending Order: Swap the subtraction order or multiply the result by <code>-1</code>. 2.  Multi-Level Sorting: If the primary field is equal, sort by a secondary field.     <pre><code>int result = strcmp(left-&gt;province, right-&gt;province);\nif (result != 0) return result; // Primary sort\nreturn strcmp(left-&gt;lastName, right-&gt;lastName); // Secondary sort\n</code></pre></p> <ol> <li>Toggling Direction: You can use a global <code>DIRECTION</code> variable or multiplier to toggle between ASC/DESC within the same comparator function.</li> </ol>"},{"location":"final/#index-files","title":"Index Files","text":"<p>Secondary file storing <code>(Key, Offset)</code> pairs to allow random access on data files without scanning.</p> <p>1. Creating an Index 1.  Read data file sequentially. 2.  Store key and file position (offset) in array. 3.  Sort the array by key. 4.  Write header and sorted records to index file.</p> <p>2. Using an Index 1.  Load index records into memory. 2.  Search index (e.g., binary search) for key. 3.  Retrieve <code>offset</code>. 4.  <code>fseek</code> to that offset in the data file and <code>fread</code> the record.</p>"},{"location":"final/#preprocessor-multi-file-programs","title":"Preprocessor &amp; Multi-File Programs","text":""},{"location":"final/#the-preprocessor","title":"The Preprocessor","text":"<p>Processes source code before the compiler. * <code>#include</code>: Inclusion of files (Headers). * <code>#define</code>: Creates symbolic constants or Macros.     * Macros perform text substitution (no type checking).     * !!! warning         Use parentheses around arguments in macros to avoid precedence issues. * <code>#undef</code>: Undefines a macro. * System Specifics: You can use <code>#ifdef</code> to handle OS-specific includes (e.g., <code>_WIN32</code> vs <code>_MSC_VER</code>).</p> <p>Conditional Compilation Used for debugging or header guards. <pre><code>#ifndef MY_HEADER_H // Header Guard\n#define MY_HEADER_H\n...\n#endif\n</code></pre></p>"},{"location":"final/#multi-file-programs","title":"Multi-File Programs","text":"<ul> <li><code>extern</code>: Declares a variable defined in another file (External Linkage).</li> <li><code>static</code> (File Scope): Limits visibility to the current file (Internal Linkage).<ul> <li>Example: In <code>lab9.c</code>, <code>static Direction DIRECTION = ASC;</code> limits the scope of the global variable to that specific file.</li> </ul> </li> <li>Make Utility: Recompiles only changed files in a project.</li> </ul>"},{"location":"final/#storage-classes","title":"Storage Classes","text":"Class Keyword Duration Scope Linkage Automatic <code>auto</code> Block Block None Register <code>register</code> Block Block None Static <code>static</code> Static Block None File Static <code>static</code> Static File Internal External <code>extern</code> Static File External"},{"location":"midterm/","title":"Midterm Study Notes","text":""},{"location":"midterm/#streams","title":"Streams","text":"<p>Streams are sequences of bytes used for input and output.</p> <ul> <li>Input: Data flows from a device (keyboard, disk, network, etc.) into main memory.</li> <li>Output: Data flows from main memory to a device (screen, printer, disk, network, etc.).</li> </ul> <p>At program start, three standard streams are available (which can be redirected to other devices or files):</p> <ol> <li>Standard input (<code>stdin</code>) \u2013 usually from the keyboard.</li> <li>Standard output (<code>stdout</code>) \u2013 usually to the screen.</li> <li>Standard error (<code>stderr</code>) \u2013 also to the screen, for error messages.</li> </ol>"},{"location":"midterm/#printf","title":"printf","text":""},{"location":"midterm/#conversion-specifiers","title":"Conversion Specifiers","text":"<p><code>printf</code> uses conversion specifiers to determine how data is formatted when printed. Each specifier begins with <code>%</code> followed by one or more characters describing type and formatting.</p> Specifier Description Example Output Integers <code>%d</code>, <code>%i</code> Signed decimal integer <code>printf(\"%d\", 42)</code> \u2192 <code>42</code> <code>%u</code> Unsigned decimal integer <code>printf(\"%u\", 42)</code> \u2192 <code>42</code> <code>%o</code> Unsigned octal integer <code>printf(\"%o\", 10)</code> \u2192 <code>12</code> <code>%x</code>, <code>%X</code> Unsigned hexadecimal integer (<code>a\u2013f</code> or <code>A\u2013F</code>) <code>printf(\"%x\", 255)</code> \u2192 <code>ff</code> Floating-point <code>%f</code>* Floating-point decimal (fixed) <code>printf(\"%f\", 3.1416)</code> \u2192 <code>3.141600</code> <code>%e</code>, <code>%E</code>* Floating-point in scientific notation <code>printf(\"%e\", 1234.56)</code> \u2192 <code>1.234560e+03</code> <code>%g</code>, <code>%G</code>** Floating-point (shortest of <code>%f</code> or <code>%e</code>) <code>printf(\"%g\", 0.0000123)</code> \u2192 <code>1.23e-05</code> * default 6 digits of precision after decimal ** 6 significant digits (including before decimal) Characters &amp; Strings <code>%c</code> Single character <code>printf(\"%c\", 'A')</code> \u2192 <code>A</code> <code>%s</code> String of characters <code>printf(\"%s\", \"Hello\")</code> \u2192 <code>Hello</code> Miscellaneous <code>%p</code> Pointer displayed in an implementation defined manner <code>printf(\"%p\", ptr)</code> \u2192 <code>0x7ffeefbff5ac</code> <code>%%</code> Prints a literal percent sign <code>printf(\"%%\")</code> \u2192 <code>%</code>"},{"location":"midterm/#when-to-use-g","title":"When to Use <code>%g</code>","text":"<p>The <code>%g</code> (or <code>%G</code>) specifier automatically chooses between fixed-point (<code>%f</code>) and scientific (<code>%e</code>) notation depending on the value\u2019s magnitude and precision:</p> <ul> <li>If the exponent is less than -4 or greater than or equal to the precision, <code>%e</code> format is used.</li> <li>Otherwise, <code>%f</code> format is used.</li> <li>Trailing zeros are removed, and no unnecessary decimal point is shown.</li> </ul> <pre><code>printf(\"%g\", 0.0000123); // \u2192 1.23e-05\nprintf(\"%g\", 123.456);   // \u2192 123.456\nprintf(\"%g\", 100.0);     // \u2192 100\n</code></pre> <p>Use <code>%g</code> when you want concise output without manually deciding between scientific and decimal notation.</p>"},{"location":"midterm/#field-widths","title":"Field Widths","text":"<p>A field width specifies the minimum number of characters to print. If the value is shorter, it is left-padded with spaces by default (making the  text right-aligned).</p> <pre><code>printf(\"%5d\", 12);         // \"   12\" (left-padded with 3 spaces)\nprintf(\"%-5d\", 12);        // \"12   \" (right-padded with 3 spaces)\nprintf(\"%5d\\n\", 123456);   // \"123456\" (wider than specifier, prints fully)\n</code></pre> <p>Field widths can also apply to floating-point values:</p> <pre><code>printf(\"%0.2f\", 3.14); // \"    3.14\"\n</code></pre> <ul> <li>The number before the decimal controls total width.</li> <li>The number after the decimal controls precision.</li> </ul>"},{"location":"midterm/#flags","title":"Flags","text":"<p>Flags modify alignment, padding, and sign display in formatted output.</p> Flag Meaning Example <code>-</code> Left-justify within the field <code>printf(\"%-5d\", 42)</code> \u2192 <code>42</code> <code>+</code> Always print a sign (<code>+</code> or <code>-</code>) <code>printf(\"%+d\", 42)</code> \u2192 <code>+42</code> space Prefix positive numbers with a space <code>printf(\"% d\", 42)</code> \u2192 <code>42</code> <code>0</code> Pad numeric output with leading zeros <code>printf(\"%05d\", 42)</code> \u2192 <code>00042</code> <code>#</code> Force alternate form (e.g., add <code>0x</code> for hex, decimal point for floats) <code>printf(\"%#x\", 255)</code> \u2192 <code>0xff</code>"},{"location":"midterm/#scanf","title":"scanf","text":""},{"location":"midterm/#conversion-specifiers_1","title":"Conversion Specifiers","text":"Specifier Description Integers <code>%d</code> Reads a signed decimal integer <code>int*</code> <code>%i</code> Reads signed decimal, octal, or hexadecimal <code>int*</code> <code>%o</code> Reads an octal integer <code>unsigned int*</code> <code>%u</code> Reads an unsigned decimal integer <code>unsigned int*</code> <code>%x</code> / <code>%X</code> Reads a hexadecimal integer <code>unsigned int*</code> <code>h</code>, <code>l</code>, <code>ll</code> Length modifiers (<code>short</code>, <code>long</code>, <code>long long</code>) for integers Floating-point <code>%e</code>, <code>%E</code>, <code>%f</code>, <code>%F</code>, <code>%g</code>, <code>%G</code> Reads a floating-point value <code>float*</code> / <code>double*</code> <code>l</code> or <code>L</code> Length modifiers for <code>double</code> or <code>long double</code> Characters &amp; Strings <code>%c</code> Reads a single character <code>char*</code> (no <code>\\0</code> added) <code>%s</code> Reads a string <code>char[]</code> (terminates with <code>\\0</code>) Scan set <code>%[...]</code> Reads a set of characters into a string Miscellaneous <code>%p</code> Reads an address (pointer format) <code>%n</code> Stores number of characters read so far <code>int*</code> <code>%%</code> Skips a literal <code>%</code> in input"},{"location":"midterm/#scan-sets-and-inverted-scan-sets","title":"Scan Sets and Inverted Scan Sets","text":"<p>Scan sets allow <code>scanf</code> to read a group of characters that match a specified set. They are defined using <code>%[ ... ]</code>.</p> <ul> <li><code>%[characters]</code> \u2192 reads only the characters listed.</li> <li><code>%[^characters]</code> \u2192 reads everything except the characters listed.</li> <li>Useful for reading structured data such as comma- or space-separated values.</li> </ul> <pre><code>char word[20];\nscanf(\"%19[A-Za-z]\", word);   // reads only letters\n\nchar untilComma[30];\nscanf(\"%29[^,]\", untilComma);  // reads everything up to the next comma\n</code></pre> <p>Notes:</p> <ul> <li><code>scanf</code> automatically adds a null terminator (<code>'\\0'</code>) at the end.</li> <li>To include <code>]</code> in the scanset, place it first inside the brackets: <code>%[]A-Z]</code>.</li> <li>To include <code>-</code>, place it at the start or end of the set: <code>%[-A-Z]</code>.</li> </ul>"},{"location":"midterm/#field-widths_1","title":"Field Widths","text":"<p>Field widths define how many characters <code>scanf</code> will read for a given conversion. This prevents buffer overflows and controls input precision.</p> <pre><code>char name[11];\nscanf(\"%10s\", name);   // reads at most 10 chars, leaves space for null terminator\n</code></pre> <pre><code>int year, month, day;\nscanf(\"%4d%2d%2d\", &amp;year, &amp;month, &amp;day);\n// Input: 20251028 \u2192 year=2025, month=10, day=28\n</code></pre>"},{"location":"midterm/#skipping-characters-and-assignment-suppression","title":"Skipping Characters and Assignment Suppression","text":"<p>The assignment suppression character (<code>*</code>) allows <code>scanf</code> to skip matched input without storing it.</p> <ul> <li>Any literal in the format string must appear in the input and will be consumed.</li> <li>Whitespace in the format matches any amount of whitespace in the input.</li> </ul> <pre><code>// Skip a single character (like '-') between numbers\nint year, month, day;\nscanf(\"%d%*c%d%*c%d\", &amp;year, &amp;month, &amp;day);\n\n// Skip entire field before comma\nchar name[20];\nscanf(\"%*[^,],%19s\", name);\n</code></pre>"},{"location":"midterm/#formatted-io-variants","title":"Formatted I/O Variants","text":"Function Purpose Typical Use Case <code>fprintf(FILE *fp, const char *format, ...)</code> Prints formatted output to a file stream. Writing data to files. <code>fscanf(FILE *fp, const char *format, ...)</code> Reads formatted input from a file stream. Reading structured file input. <code>sprintf(char *str, const char *format, ...)</code> Writes formatted output into a string buffer. Building formatted strings in memory. <code>sscanf(const char *str, const char *format, ...)</code> Reads formatted input from a string. Parsing string data (e.g., CSV fields). <p>Formatted I/O Variant Use</p> <p>These functions behave like <code>printf</code> and <code>scanf</code>, but redirect input/output to files or strings instead of the console.</p>"},{"location":"midterm/#literals-and-escape-sequences","title":"Literals and Escape Sequences","text":"<p>Characters in a format string that are not part of a conversion specification are printed literally.</p> <p>Escape sequences allow you to include special characters in strings that cannot be typed directly or would otherwise be ambiguous.</p> Escape Description <code>\\'</code> Single quote (<code>'</code>) <code>\\\"</code> Double quote (<code>\"</code>) <code>\\?</code> Question mark (<code>?</code>) <code>\\\\</code> Backslash (<code>\\\\</code>) <code>\\a</code> Alert (bell/flash) <code>\\b</code> Backspace <code>\\f</code> Form feed (new page) <code>\\n</code> Newline <code>\\r</code> Carriage return (does not move to beginning of next line) <code>\\t</code> Horizontal tab <code>\\v</code> Vertical tab <code>%%</code> Percent symbol (<code>%</code>)"},{"location":"midterm/#recursion","title":"Recursion","text":"<p>Recursion occurs when a function calls itself directly or indirectly. Each call creates a new stack frame until a base case is reached, after which calls resolve in reverse order.</p> <ul> <li>Base Case: The simplest form of the problem that can be solved directly.</li> <li>Recursive Case: Reduces the problem toward the base case.</li> <li>Recursion always requires progress toward termination to prevent infinite loops.</li> </ul> <pre><code>int factorial(int n)\n{\n    if (n == 0)  // base case\n        return 1;\n    else          // recursive case\n        return n * factorial(n - 1);\n}\n</code></pre> <ul> <li>For <code>factorial(3)</code> \u2192 calls unfold as <code>3 * factorial(2)</code> \u2192 <code>2 * factorial(1)</code> \u2192 <code>1 * factorial(0)</code>.</li> <li>Base case returns 1, then each call multiplies by the previous <code>n</code> until the result is complete.</li> </ul>"},{"location":"midterm/#structures","title":"Structures","text":"<p>A structure groups related variables under one name. The C standard calls them aggregates. Defined using the <code>struct</code> keyword:</p> <pre><code>struct card {\n    const char *face;\n    const char *suit;\n};\n</code></pre> <p>Semicolon is required after the closing brace. Members can be of different types, but a structure cannot directly contain an instance of itself\u2014only a pointer to its own type.</p> <pre><code>struct card {\n    const char *face;\n    const char *suit;\n    struct card *nextCard;  // Valid\n};\n</code></pre>"},{"location":"midterm/#defining-variables-of-structure-types","title":"Defining Variables of Structure Types","text":"<p>Defining a structure creates a type, not a variable. Variables are declared afterward:</p> <pre><code>struct card myCard;\nstruct card deck[52];\nstruct card *cardPtr;\n</code></pre> <p>You can also define variables inline with the structure:</p> <pre><code>struct card {\n    const char *face;\n    const char *suit;\n} myCard, deck[52], *cardPtr;\n</code></pre>"},{"location":"midterm/#initializing-structures","title":"Initializing Structures","text":"<pre><code>// array-like member initializer lists\nstruct card K = {\"king\", \"clubs\"};\n\n// assigning values to individual data members\nstruct card Q;\nQ.face = \"queen\";\nQ.suit = \"spades\";\n\n// assignment statements (setting one variable to equal another of the same struct)\nstruct card A = {\"Ace\", \"Hearts\"};\nstruct card B;\n\nB = A;   // assignment statement\n</code></pre>"},{"location":"midterm/#accessing-members-of-a-structure","title":"Accessing Members of a Structure","text":"<p>You can access members of a structure using the structure member operator: <code>.</code></p> <pre><code>struct card K = {\"king\", \"clubs\"};`\nchar *Kface = K.face;\n</code></pre> <p>If you are referring to the structure through a pointer, you can use the structure arrow operator to access the members.</p> <pre><code>struct card *KPtr = &amp;K;\nchar *Kface = K-&gt;face;\n\n// Alternatively you can also use the following dereference and dot syntax\nchar *Ksuit = (*KPtr).suit; // note the paranthesis are *required* here.\n</code></pre>"},{"location":"midterm/#structures-without-tag-names","title":"Structures Without Tag Names","text":"<p>Anonymous structs can be declared if variables are defined immediately:</p> <pre><code>struct {\n    int x;\n    int y;\n} point1, point2;\n</code></pre> <p>Without a tag, you can\u2019t reuse the type elsewhere.</p>"},{"location":"midterm/#comparing-structure-objects","title":"Comparing Structure Objects","text":"<p>Structures cannot be compared with <code>==</code> or <code>!=</code> because compilers insert padding bytes for memory alignment, which may hold unspecified garbage values.</p> <p>Even identical structures might differ in padding, making bytewise comparison undefined behaviour.</p> <p>With that said, they could sometimes compare equally (although as noted it is undefined behaviour and can't be relied on).</p>"},{"location":"midterm/#using-sizeof-with-structures","title":"Using <code>sizeof</code> with Structures","text":"<p><code>sizeof(struct_name)</code> gives the memory occupied by a structure, including padding.</p> <pre><code>struct example {\n    char c;\n    int i;\n};\n\nprintf(\"%zu\\n\", sizeof(struct example)); // Likely prints 8, not 5\n</code></pre>"},{"location":"midterm/#passing-structures-and-arrays","title":"Passing Structures and Arrays","text":"<p>Array of structures: passed by reference (decays to a pointer), just like any other array.</p> <ul> <li>The function can modify the original elements.</li> </ul> <p>Array member inside a structure: passed by value when the structure itself is passed by value.</p> <ul> <li>The function receives a copy; modifying it won\u2019t affect the original.</li> </ul>"},{"location":"midterm/#typedef","title":"typedef","text":"<p><code>typedef</code> creates an alias for a type, making code more concise and readable.</p> <pre><code>typedef struct card Card;\nCard newCard;\n</code></pre>"},{"location":"midterm/#combining-typedef-with-struct","title":"Combining <code>typedef</code> with <code>struct</code>","text":"<p>You can combine both in one declaration:</p> <pre><code>typedef struct {\n    const char *face;\n    const char *suit;\n} Card;\n</code></pre> <p>Warning</p> <p>Do not declare variables in the same line when using this form. If you need variables too, use a standard <code>struct</code> definition followed by a separate <code>typedef</code>.</p>"},{"location":"midterm/#unions","title":"Unions","text":"<p>A union is a derived data type similar to a <code>struct</code>, but unlike structures, all members share the same memory space. Only one member can be used at a time, making unions memory-efficient when variables are only relevant at different times during execution.</p> <pre><code>union number {\n    int x;\n    double y;\n};\n</code></pre> <p>Defining a union creates a new type but does not allocate memory until a variable is declared.</p> <ul> <li>The size of a union equals the size of its largest member.</li> <li>Accessing a member different from the one last assigned leads to undefined behavior.</li> <li>Unions save space but require careful type management.</li> </ul>"},{"location":"midterm/#initializing-a-union","title":"Initializing a Union","text":"<p>A union can be initialized only through its first member:</p> <pre><code>union number value = {10}; // assigns 10 to x\n</code></pre> <p>Warning</p> <p>If initialized with a value meant for another member, it will be converted to the first member\u2019s type:</p> <pre><code>union number value = {1.43}; // assigns 1 to x instead of 1.43 to y\n</code></pre>"},{"location":"midterm/#bitwise-operators","title":"Bitwise Operators","text":"<p>Bitwise operations work directly on the binary representation of integer types such as short, int, and long (and their unsigned variants). Each bit in a value represents a power of two.</p> <p>Operators</p> <ul> <li> <p>AND <code>&amp;</code>     Sets a bit to 1 only if both bits are 1.</p> <pre><code>// 1101 (13)\n// 1011 (11)\n// ----\n// 1001 (9)\n</code></pre> </li> <li> <p>OR <code>|</code>     Sets a bit to 1 if either bit is 1.</p> <pre><code>// 1101 (13)\n// 1011 (11)\n// ----\n// 1111 (15)\n</code></pre> </li> <li> <p>XOR <code>^</code>     Sets a bit to 1 if bits differ.</p> <pre><code>// 1101 (13)\n// 1011 (11)\n// ----\n// 0110 (6)\n</code></pre> </li> <li> <p>NOT <code>~</code>     Inverts each bit.</p> <p><pre><code>// 0101 (5)\n// ~\n// ----\n// 1010 (10)\n</code></pre> shown as 4 bits</p> </li> <li> <p>Left shift <code>&lt;&lt;</code>     Moves bits left (fills with 0).</p> <p><pre><code>// 0101 (5)\n// &lt;&lt; 1\n// ----\n// 1010 (10)\n</code></pre> Each shift multiplies by 2.</p> </li> <li> <p>Right shift <code>&gt;&gt;</code>     Moves bits right (fills with 0).</p> <p><pre><code>// 1010 (10)\n// &gt;&gt; 1\n// ----\n//0101 (5)\n</code></pre> Each shift divides by 2.</p> </li> </ul> <p>Note on shifts: Right-shift of signed negative values is implementation-defined; use <code>unsigned</code> integers where possible.</p> Common bit manipulation patterns <p>Even/odd: <code>x &amp; 1</code> <pre><code>if (x &amp; 1) puts(\"Odd\"); else puts(\"Even\");\n</code></pre> Swap without temp (XOR-swap): <pre><code>a ^= b; b ^= a; a ^= b;\n</code></pre> Power of two (exactly one bit set): <pre><code>if (x &gt; 0 &amp;&amp; (x &amp; (x - 1)) == 0) puts(\"Power of 2\");\n</code></pre> Count set bits (Kernighan): <pre><code>int c = 0; for (; x; ++c) x &amp;= (x - 1);\n</code></pre> Set / clear / toggle bit n: <pre><code>x |=  (1u &lt;&lt; n);   // set\nx &amp;= ~(1u &lt;&lt; n);   // clear\nx ^=  (1u &lt;&lt; n);   // toggle\n</code></pre> Lowest set bit: <pre><code>unsigned lowest = x &amp; -x;\n</code></pre> Opposite signs: <pre><code>if ((x ^ y) &lt; 0) puts(\"Opposite signs\");\n</code></pre></p>"},{"location":"midterm/#enums","title":"Enums","text":"<p>An enumeration is a user-defined type consisting of a set of named integer constants. Identifiers must be unique, but they can share the same constant value.</p> <pre><code>enum Day { MON, TUE, WED, THU, FRI, SAT, SUN }; // identifiers (MON\u2013SUN) map to constants 0\u20136\nenum Day today = WED; // WED corresponds to 2\n\n// You can also specify constant values in the definition\nenum SomeDays { MON = 1, TUE = 3, WED = 1 }; // WED shares the same value as MON\n\n// You **cannot** assign to enum constants after definition\nWED = 4;  // &lt;- ERROR: enumeration constants are read-only (compile-time error)\n</code></pre>"},{"location":"midterm/#self-referential-structures","title":"Self-Referential Structures","text":"<ul> <li>Structures can include pointers to their own type, enabling dynamic data structures.</li> </ul> <pre><code>struct node { int data; struct node *nextPtr; };\n</code></pre> <ul> <li>Used for linked lists, stacks, and trees.</li> </ul>"},{"location":"midterm/#linked-lists","title":"Linked Lists","text":"<p>Linear collection of nodes connected by pointers.</p> <ul> <li>Each node contains data and a pointer to the next node.</li> <li>The head pointer references the first node; the last node\u2019s pointer is <code>NULL</code>.</li> </ul> <p></p> <p>Traversals</p> <p>Move through nodes one by one until <code>NULL</code>:</p> <p>Start at <code>head</code> \u2192 process data \u2192 move to <code>nextPtr</code> \u2192 repeat.</p> <p>Insertions (two cases)</p> <ul> <li> </li> <li> </li> </ul> <p>Deletions (two cases)</p> <ul> <li> </li> <li> </li> </ul>"},{"location":"midterm/#1-unsorted-insertion-at-the-beginning","title":"1. Unsorted Insertion (at the beginning)","text":"<ol> <li>Allocate memory for a new node and create a <code>newPtr</code>.</li> <li>Assign the desired value to its data field.</li> <li>Link the new node to the existing list by setting    <code>newPtr-&gt;nextPtr = head;</code></li> <li>Update the head pointer so it points to the new node:    <code>head = newPtr;</code></li> </ol>"},{"location":"midterm/#2-sorted-insertion-maintaining-order","title":"2. Sorted Insertion (maintaining order)","text":"<ol> <li>Allocate and initialize the new node.</li> <li> <p>Set <code>previousPtr = NULL</code> and <code>currentPtr = head</code>.</p> <ul> <li><code>previousPtr</code> will always lag one node behind <code>currentPtr</code></li> </ul> </li> <li> <p>Traverse/walk the links until you find the spot.</p> <ul> <li><code>previousPtr = currentPtr</code></li> <li><code>currentPtr = currentPtr-&gt;nextPtr</code></li> </ul> </li> <li> <p>If <code>previousPtr == NULL</code>, insert at the start (new head).     Otherwise, insert between <code>previousPtr</code> and <code>currentPtr</code>.</p> <ul> <li><code>previousPtr-&gt;nextPtr = newPtr;</code></li> <li><code>newPtr-&gt;nextPtr = currentPtr;</code></li> </ul> </li> </ol>"},{"location":"midterm/#1-delete-the-first-node","title":"1. Delete the First Node","text":"<ol> <li>Store the current head in a temporary pointer.</li> <li>Move <code>head</code> to <code>head-&gt;nextPtr</code>.</li> <li>Free the temporary node.</li> </ol>"},{"location":"midterm/#2-delete-from-middle-or-end","title":"2. Delete from Middle or End","text":"<ol> <li>Use <code>previousPtr</code> and <code>currentPtr</code> to traverse until the node to delete is found.</li> <li>Update <code>previousPtr-&gt;nextPtr</code> to <code>currentPtr-&gt;nextPtr</code>.</li> <li>Free the deleted node.</li> </ol>"},{"location":"midterm/#utility-operations","title":"Utility Operations","text":"<ul> <li>isEmpty: return <code>head == NULL</code>.</li> <li>printList: traverse and print each node\u2019s data until <code>NULL</code>.</li> </ul>"},{"location":"midterm/#stacks","title":"Stacks","text":"<p>A stack is a linear data structure that follows the Last-In, First-Out (LIFO) principle. The most recently added element is removed first.</p> <ul> <li>Insertion and deletion occur only at the top of the stack.</li> <li>Implemented using linked lists or arrays.</li> <li>The stack pointer (<code>topPtr</code>) tracks the current top node.</li> </ul> Operation Description push() Insert an element at the top. pop() Remove the top element and return its value. isEmpty() Check if the stack is empty. <pre><code>struct stackNode {\n    int data;\n    struct stackNode *nextPtr;\n};\n</code></pre>"},{"location":"midterm/#queues","title":"Queues","text":"<p>A queue is a linear data structure that follows the First-In, First-Out (FIFO) principle. The first element added is the first one removed.</p> <ul> <li>Insertion occurs at the rear; deletion occurs at the front.</li> <li>Implemented using linked lists.</li> </ul> <p>Two pointers are used:</p> <ul> <li><code>frontPtr</code> \u2192 points to the first node</li> <li><code>rearPtr</code> \u2192 points to the last node</li> </ul> Operation Description enqueue() Add a new element to the rear. dequeue() Remove an element from the front. isEmpty() Check if the queue is empty. <pre><code>struct queueNode {\n    int data;\n    struct queueNode *nextPtr;\n};\n</code></pre>"},{"location":"midterm/#trees","title":"Trees","text":"<p>Non-linear hierarchical data structure consisting of nodes connected by edges.</p> <ul> <li>Each node may have two or more children.</li> </ul>"},{"location":"midterm/#binary-trees","title":"Binary Trees","text":"<p>A type of tree where each node has at most two children (<code>left</code>, <code>right</code>).</p> <ul> <li>The root is the topmost node; leaf nodes have no children.</li> </ul> <p></p>"},{"location":"midterm/#binary-search-tree-bst","title":"Binary Search Tree (BST)","text":"<p>Special binary tree where:</p> <ul> <li>Left subtree value &lt; Root value &lt; Right subtree value.</li> <li>Enables fast searching, insertion, and deletion.</li> </ul>"},{"location":"midterm/#tree-traversals","title":"Tree Traversals","text":"Type Visit Order Common Use Preorder Root \u2192 Left \u2192 Right Copying the tree Inorder Left \u2192 Root \u2192 Right Produces sorted output Postorder Left \u2192 Right \u2192 Root Deletion or cleanup"},{"location":"midterm/#pointer-to-pointer","title":"Pointer-to-Pointer","text":"<p>When a function needs to modify a pointer (such as a tree\u2019s root or a linked list\u2019s head), it must receive the address of that pointer. This allows the function to update the caller\u2019s pointer directly.</p> <pre><code>void insertNode(TreeNodePtr *treePtr, int value)\n{\n    if (*treePtr == NULL) {\n        *treePtr = malloc(sizeof **treePtr);\n        (*treePtr)-&gt;data = value;\n        (*treePtr)-&gt;leftPtr = NULL;\n        (*treePtr)-&gt;rightPtr = NULL;\n    }\n    else if (value &lt; (*treePtr)-&gt;data)\n        insertNode(&amp;((*treePtr)-&gt;leftPtr), value);  // pass address of left child\n    else if (value &gt; (*treePtr)-&gt;data)\n        insertNode(&amp;((*treePtr)-&gt;rightPtr), value); // pass address of right child\n}\n</code></pre> <ul> <li><code>treePtr</code> is a pointer to a pointer (<code>TreeNode **</code>).</li> <li><code>*treePtr</code> gives the actual node pointer (e.g., the root or a child link).</li> <li><code>&amp;((*treePtr)-&gt;leftPtr)</code> passes the address of the child pointer, allowing recursion to modify that link directly.</li> </ul> <p>Use <code>(*ptr)-&gt;member</code> instead of confusing forms like <code>*(*ptr).member</code>. Parentheses ensure the dereference applies to the pointer, not the struct member.</p>"},{"location":"wk_eight/","title":"Week 8","text":"<p>This week covered reading and writing files and the use of <code>fseek</code>. We used Charlie Blatter's old slides rather than the usual textbook publisher slides.</p>"},{"location":"wk_eight/#files-and-streams","title":"Files and Streams","text":"<p>Files provide us with a long-term way to store large amounts of data.</p> Data Hierarchy <ul> <li>bit is the smallest data item. It can be either a single 0 or a single 1.</li> <li>byte/char is 8 bits. It can be used to store a ascii character.</li> <li>field is a group of bytes/chars which convey a meaning such as a name.</li> <li>record is a group of several related fields, such as a <code>struct</code> or a row.</li> <li>file is a collection of records.</li> <li>database is a group of related files</li> </ul> <p></p> <p>In C, each file is viewed as a sequential stream of bytes. Each file ends with a end-of-file marker or at a specific byte recorded in a system-maintained, administrative data structure (platform-dependent).</p> <p></p> <p>When a file is opened, C associates a stream with it.</p>"},{"location":"wk_eight/#file-struct","title":"<code>FILE</code> struct","text":"<p>Opening a file returns a pointer to a <code>FILE</code> struct which contains the information that the program needs to process the file.</p> <p>This includes a file descriptor which is an index into an operating-system array called the open file table. Each element in that array contains a file control block (FCB) which the OS uses to administer a particular file.</p> <p>When program execution begins, C opens three streams automatically:</p> <ul> <li>The standard input stream receives input from the keyboard.</li> <li>The standard output stream displays output on the screen.</li> <li>The standard error stream displays error messages on the screen.</li> </ul> <p>We can then use the <code>FILE</code> pointers <code>stdin</code>, <code>stdout</code>, and <code>stderr</code> to interact with these streams.</p> <p>Files in C have no inherent concept of structured data or records at the language level; the programmer must explicitly define and manage the file\u2019s structure. </p> <p>Note</p> <p>This \"structure\" refers to the logical organization of file contents and should not be confused with the <code>FILE</code> struct used by the standard I/O library.</p>"},{"location":"wk_eight/#file-access-methods","title":"File Access Methods","text":"<p>In C, there are two primary ways to access data in a file: sequential access and random access. The choice of method depends on how the data is organized and how it needs to be processed.</p>"},{"location":"wk_eight/#sequential-access-files-text","title":"Sequential Access Files (Text)","text":"<p>Sequential access is one of the most common methods used to process files in C, especially when working with text. These files are often structured as a series of records, with each record representing a logical grouping of related data such as a line of comma-separated values.</p>"},{"location":"wk_eight/#file-modes-for-sequential-access","title":"File Modes for Sequential Access","text":"Mode Description Notes / Use Case <code>r</code> Open an existing file for reading. Fails if file doesn't exist. You cannot write to the file in this mode. <code>w</code> Create a file for writing. Discards existing contents if file exists. Use when starting fresh; overwrites any existing file. <code>a</code> Open or create a file for writing at the end of the file. Appends to existing content; creates file if it doesn\u2019t exist. <code>r+</code> Open an existing file for both reading and writing. Allows random-access-like reading and writing. Fails if file doesn't exist. <code>w+</code> Create a file for reading and writing. Overwrites if file exists. Useful when you want both read and write access but don't need existing content. <code>a+</code> Open or create a file for reading and writing. Writes go to the end. You can read anywhere, but writes always append. Useful for logs or journals. <p>Warning</p> <p>Sequential text files cannot be modified safely in place. Changing any part of a record can shift all later data because field lengths vary.</p> <p>Fields may differ in size. For example, these integers:</p> <ul> <li><code>1</code></li> <li><code>34</code></li> <li><code>-890</code></li> </ul> <p>all represent <code>int</code> values in memory but occupy different numbers of characters on disk.</p> <p>Since record boundaries depend on delimiters such as newlines, commas, or tabs, overwriting or removing characters can misalign later records and corrupt the file structure.</p>"},{"location":"wk_eight/#standard-library-readwrite-functions","title":"Standard Library Read/Write Functions","text":"<p><code>fgetc(FILE *fp)</code> Reads a single character from the file.</p> <ul> <li><code>fgetc(stdin)</code> is equivalent to <code>getchar()</code>.</li> </ul> <p><code>fputc(int c, FILE *fp)</code> Writes a single character to the file.</p> <ul> <li><code>fputc('a', stdout)</code> is equivalent to <code>putchar('a')</code>.</li> </ul> <p><code>fgets(char *str, int n, FILE *fp)</code> Reads a line (up to <code>n-1</code> characters or newline).   - Automatically null-terminates the string.</p> <p><code>fputs(const char *str, FILE *fp)</code> Writes a null-terminated string to the file (without appending a newline).</p> <p><code>fscanf(FILE *fp, ...) / fprintf(FILE *fp, ...)</code></p> <ul> <li>File-based versions of <code>scanf</code> and <code>printf</code>.</li> </ul> <p>Sequential access is efficient when you want to process every line or record in order, such as when reading configuration files, logs, or lists of values.</p>"},{"location":"wk_eight/#random-access-files-binary","title":"Random Access Files (Binary)","text":"<p>Random access allows the program to jump directly to any position in the file and read or write data without processing earlier records. This is ideal when working with fixed-size binary records, where each record occupies the same number of bytes.</p> <p>These files are typically used when you need predictable storage layouts, efficient updates, or direct lookups by record number.</p>"},{"location":"wk_eight/#file-modes-for-random-access","title":"File Modes for Random Access","text":"Mode Description Notes / Use Case <code>rb</code> Open an existing binary file for reading. Fails if file doesn\u2019t exist. Reads raw bytes without text translation. <code>wb</code> Create a binary file for writing. Overwrites if file exists. Use when generating a new binary dataset from scratch. <code>ab</code> Open or create a binary file for appending. Writes go to the end. Appending fixed-size records; cannot overwrite previous records. <code>rb+</code> Open an existing binary file for both reading and writing. The standard choice for random access; allows updates to any record. <code>wb+</code> Create a binary file for reading and writing. Overwrites if file exists. Use when you need full read/write support but do not need the old contents. <code>ab+</code> Open/create a binary file for reading and writing; writes append. Allows random reads but appends on writes. Same semantics as <code>a+</code> but binary."},{"location":"wk_eight/#standard-library-random-access-functions","title":"Standard Library Random-Access Functions","text":"<p><code>fseek(FILE *fp, long offset, int origin)</code> Moves the file position indicator to a specific byte offset.</p> <ul> <li><code>offset</code> may be positive or negative.</li> <li> <p><code>origin</code> is one of:</p> </li> <li> <p><code>SEEK_SET</code> \u2014 beginning of file</p> </li> <li><code>SEEK_CUR</code> \u2014 current position</li> <li><code>SEEK_END</code> \u2014 end of file</li> <li>Used to jump directly to a record location in fixed-length files.</li> </ul> <p><code>ftell(FILE *fp)</code> Returns the current byte offset from the beginning of the file.</p> <ul> <li>Returns a <code>long</code>.</li> <li>Works only after successful positioning with <code>fseek</code>.</li> <li>Commonly used to compute record numbers or debug file navigation.</li> </ul> <p><code>rewind(FILE *fp)</code> Resets the file position indicator to byte offset 0 and clears EOF/error flags.</p> <ul> <li>Equivalent to:</li> </ul> <pre><code>fseek(fp, 0, SEEK_SET);\nclearerr(fp);\n</code></pre> <p><code>fread(void *buffer, size_t size, size_t count, FILE *fp)</code> Reads raw bytes from the file into memory.</p> <ul> <li>Reads <code>count</code> items each of <code>size</code> bytes.</li> <li>Does not parse or interpret text; it copies bytes exactly.</li> <li>Ideal for reading fixed-size structs:</li> </ul> <pre><code>fread(&amp;client, sizeof(client), 1, fp);\n</code></pre> <p><code>fwrite(const void *buffer, size_t size, size_t count, FILE *fp)</code> Writes raw bytes from memory to the file.</p> <ul> <li>Writes <code>count</code> items each of <code>size</code> bytes.</li> <li>Commonly used to update an existing record after seeking to its offset:</li> </ul> <pre><code>fwrite(&amp;client, sizeof(client), 1, fp);\n</code></pre>"},{"location":"wk_eleven/","title":"Week 11","text":"<p>This week covers the C preprocessor, conditional compilation, and the basics of multi-file programs. </p>"},{"location":"wk_eleven/#the-c-preprocessor","title":"The C Preprocessor","text":"<p>The C Preprocessor is a program that processes the source code before it is passed to the compiler. Its main functions are:</p> <ul> <li>Inclusion of other files.</li> <li>Definition of symbolic constants and macros.</li> <li>Conditional compilation of program code.</li> <li>Conditional execution of preprocessor directives.</li> </ul> <p>Preprocessor directives always begin with a hash sign (<code>#</code>) and can only have whitespace characters before them on a line.</p>"},{"location":"wk_eleven/#the-build-process","title":"The Build Process","text":"<p>The preprocessor is the first step in converting a source file to an executable.</p> <pre><code>graph TD\n    %% Define Styles - Transparent fill, thick colored strokes\n    %% The text color will inherit from your site theme (Light/Dark)\n    classDef file fill:transparent,stroke:#2196F3,stroke-width:3px;\n    classDef process fill:transparent,stroke:#FF9800,stroke-width:3px,rx:10,ry:10;\n\n    subgraph Preprocessing [Preprocessing Phase]\n        direction TB\n        A[Source File]:::file --&gt; B(Preprocessor):::process\n        B --&gt; C[Preprocessed File]:::file\n    end\n\n    C --&gt; D(Compiler):::process\n    D --&gt; E[Object File]:::file\n\n    subgraph Linking [Linking Phase]\n        direction TB\n        E --&gt; F(Linker):::process\n        G[Library Code]:::file --&gt; F\n    end\n\n    F --&gt; H[Executable File]:::file</code></pre>"},{"location":"wk_eleven/#include-directive","title":"<code>#include</code> Directive","text":"<p>The <code>#include</code> directive causes a copy of the specified file to be included in place of the directive itself. This is typically used to incorporate header files that contain common declarations like function prototypes and <code>struct</code> definitions.</p> Format Search Location Usage <code>#include &lt;filename&gt;</code> Searches standard library for the file. Use for standard library files. <code>#include \"filename\"</code> Searches the current directory, then the standard library. Use for user-defined files."},{"location":"wk_eleven/#define-and-macros","title":"<code>#define</code> and Macros","text":"<p>The <code>#define</code> directive is used to create symbolic constants and macros.</p>"},{"location":"wk_eleven/#symbolic-constants","title":"Symbolic Constants","text":"<p>When the program is compiled, all occurrences of the symbolic constant are replaced with the replacement text. Once a symbolic constant is created, it cannot be redefined.</p> <pre><code>// Format: #define identifier replacement-text\n#define PI 3.14159\n</code></pre>"},{"location":"wk_eleven/#macros-with-arguments","title":"Macros with Arguments","text":"<p>A macro is an operation defined in a <code>#define</code> directive. A macro with arguments has its arguments substituted for the replacement text when the macro is expanded. Macros perform a text substitution, meaning no data type checking is performed. A macro without arguments is treated like a symbolic constant.</p> <p>Macros vs. Functions</p> <p>A macro performs a text substitution and does no data type checking, unlike functions.</p> Area Macro and the Importance of Parentheses <p>Always use parentheses around arguments and the entire macro body to avoid potential precedence issues after substitution.</p> <pre><code>#define PI 3.14159\nint c = 2;\ndouble area;\n\n// --- FAILURE: Missing Parentheses ---\n#define CIRCLE_AREA(x) PI * x * x\n\narea = CIRCLE_AREA(c + 2);\n// Expansion: area = 3.14159 * c + 2 * c + 2; \n// Logic:     (3.14159 * 2) + (2 * 2) + 2\n// Result:    12.28318 (Incorrect)\n\n#undef CIRCLE_AREA // Undefine the macro so we can redefine it\n\n// --- SUCCESS: Correct Parentheses ---\n#define CIRCLE_AREA(x) (PI * (x) * (x))\n\narea = CIRCLE_AREA(c + 2);\n// Expansion: area = (3.14159 * (c + 2) * (c + 2));\n// Logic:     3.14159 * 4 * 4\n// Result:    50.26544 (Correct)\n</code></pre>"},{"location":"wk_eleven/#undef","title":"<code>#undef</code>","text":"<ul> <li><code>#undef</code>: Undefines a symbolic constant or macro. If undefined, it can   later be redefined.</li> </ul>"},{"location":"wk_eleven/#conditional-compilation","title":"Conditional Compilation","text":"<p>Conditional compilation is used to control which parts of the program code or which preprocessor directives are included or excluded before compilation. The structure is similar to the <code>if</code> statement in C.</p>"},{"location":"wk_eleven/#directives","title":"Directives","text":"<p>Every starting <code>#if</code>, <code>#ifdef</code>, or <code>#ifndef</code> must end with an <code>#endif</code>.</p> Directive Equivalent Purpose **<code>#if**</code> constant-expression Compiles the block if the expression is non-zero. **<code>#ifdef**</code> name <code>#if defined(name)</code> Compiles the block if the name is defined. **<code>#ifndef**</code> name <code>#if !defined(name)</code> Compiles the block if the name is not defined. <code>#else</code> Alternative block if the preceding condition is false. <code>#elif</code> Else-if condition for checking multiple conditions. <p>Note on Evaluation</p> <p>Preprocessor directives cannot evaluate complex expressions like <code>sizeof</code>, cast expressions, or enumeration constants.</p> Header Guards (Preventing Multiple Inclusion) <p>This pattern ensures a header file's contents are only processed once, preventing redefinition errors when the header is included in multiple source files.</p> <pre><code>#ifndef MY_HEADER_H\n#define MY_HEADER_H\n\n// ... contents of the header file\n\n#endif\n</code></pre>"},{"location":"wk_eleven/#debugging-with-conditional-compilation","title":"Debugging with Conditional Compilation","text":"<p>A frequent use case is enabling or disabling debug code.</p> <pre><code>#define DEBUG // Define DEBUG to enable the code block below.\n\n// ... some program logic\n\n#ifdef DEBUG\n    // This code only compiles if DEBUG is defined\n    printf(\"DEBUG: Variable x = %d\\n\", x);\n#endif\n\n// ... more program logic\n</code></pre> <p>To turn off the debug statements, simply remove or comment out the initial <code>#define DEBUG</code>. The debugging statements are then ignored by the compiler.</p>"},{"location":"wk_eleven/#multi-source-file-programs","title":"Multi-Source File Programs","text":"<p>Large programs are often split across multiple source files. A function definition must exist entirely within one file (it cannot be split across files), but it can be called from others.</p>"},{"location":"wk_eleven/#sharing-global-variables-extern","title":"Sharing Global Variables: <code>extern</code>","text":"<p>Global variables are accessible to functions within the same file by default. To use a global variable defined in one file in a different file, you must use the <code>extern</code> keyword.</p> <ul> <li><code>extern</code>: Declares that a variable is defined in another file (External   Linkage).</li> <li>Function Prototypes: Can be used in other files without an <code>extern</code>   statement; you simply need a prototype in each file that uses the function   (usually via a header file).</li> </ul> Using <code>extern</code> vs <code>static</code> <p>File 1 (<code>one.c</code>) <pre><code>extern int value; // DECLARATION: Refers to 'value' defined in two.c\nint val2;         // DEFINITION: Global variable with external linkage\n\nint main() {\n    // ...\n}\n</code></pre></p> <p>File 2 (<code>two.c</code>) <pre><code>int value;        // DEFINITION: The actual storage for 'value'\nstatic int val2;  // DEFINITION: Global variable with INTERNAL linkage\n                  // (only visible in two.c)\n</code></pre></p>"},{"location":"wk_eleven/#limiting-scope-static-keyword","title":"Limiting Scope: <code>static</code> Keyword","text":"<p>When the <code>static</code> keyword is used outside of all functions (at file scope), it specifies that the variable or function has internal linkage. This means it can only be used in the file in which it is defined, effectively hiding it from other source files.</p>"},{"location":"wk_eleven/#compiling-multi-file-programs","title":"Compiling Multi-File Programs","text":"<p>Compiling every file in a large project is tedious if small changes have been made to only one file.</p> <ul> <li>Make Utility: On UNIX systems, the <code>make</code> utility is used to manage   multi-file projects. It checks timestamps and recompiles only the files that   have changed, linking them with the existing object files.</li> </ul>"},{"location":"wk_eleven/#storage-classes","title":"Storage Classes","text":"<p>The storage class of a variable determines three key properties:</p> <ol> <li>Duration (Lifetime): When the variable is created and destroyed.</li> <li>Scope: Where the variable can be referenced.</li> <li>Linkage: Whether the variable is accessible across multiple files.</li> </ol> Storage Class Duration Scope Linkage Declaration Location <code>automatic</code> Automatic Block None In a block (keyword <code>auto</code> is optional). <code>register</code> Automatic Block None In a block with keyword <code>register</code>. <code>static</code> (Block) Static Block None In a block with keyword <code>static</code>. <code>static</code> (File) Static File Internal Outside all functions with keyword <code>static</code>. <code>extern</code> Static File External Outside all functions (implied or explicit)."},{"location":"wk_five/","title":"Week 5","text":"<p>This week was an introduction to self-referential structures, linked lists, and trees.</p>"},{"location":"wk_five/#self-referential-structures","title":"Self-Referential Structures","text":"<p>A structure cannot contain a member of its own type directly, because this would require the compiler to know the full size of the structure before its layout is complete. However, a structure can contain a pointer to its own type. This allows structures to reference other structures of the same type.</p> <p>This pattern is called a self-referential structure.</p>"},{"location":"wk_five/#nodes","title":"Nodes","text":"<p>A node is a fundamental building block used in several data structures (including linked lists, stacks, queues, and trees). A node stores its own data and one or more pointers that describe how to reach other nodes.</p> <p>Because these pointers refer to other nodes of the same type, nodes are self-referential.</p> <pre><code>struct node\n{\n    int data;\n    struct node *nextPtr;\n};\n</code></pre>"},{"location":"wk_five/#linked-lists","title":"Linked Lists","text":"<p>A linked list is a linear collection of self-referential nodes connected by pointer links.</p> <p>Unlike an array, a linked list does not require contiguous memory. Each node is allocated separately, and each node stores:</p> <ul> <li>Its data</li> <li>A pointer to the next node in the list (<code>nextPtr</code>)</li> </ul> <p>The list is accessed through a pointer to the first node, commonly called the head. If the list is empty, the head pointer is set to <code>NULL</code>.</p> <pre><code>struct node\n{\n    int data;\n    struct node *nextPtr;\n};\n</code></pre> <p></p> <p>The last node in the list has a <code>nextPtr</code> of <code>NULL</code>, indicating that no further nodes follow.</p>"},{"location":"wk_five/#traversing-a-linked-list","title":"Traversing a Linked List","text":"<p>To process each element, we use a pointer that starts at the head and moves from node to node until <code>NULL</code> is reached.</p> <pre><code>struct node *current = head;\n\nwhile (current != NULL)\n{\n    printf(\"%d \", current-&gt;data);\n    current = current-&gt;nextPtr;\n}\n</code></pre>"},{"location":"wk_five/#arrays-vs-linked-lists","title":"Arrays vs Linked Lists","text":"<p>Both arrays and linked lists store collections of data, but they differ in how memory is managed and how elements are accessed.</p>"},{"location":"wk_five/#when-linked-lists-are-useful","title":"When Linked Lists Are Useful","text":"<ul> <li>A linked list is appropriate when the number of data items is unknown   or changes over time.</li> <li>Linked lists are dynamic: nodes can be added or removed as needed at   runtime.</li> <li>Useful when elements will be frequently inserted or deleted, especially   in the middle of the sequence.</li> </ul>"},{"location":"wk_five/#when-arrays-are-useful","title":"When Arrays Are Useful","text":"<ul> <li>Arrays are fixed-size data structures. The size is determined when the   array is created.</li> <li>Arrays allow direct (constant-time) access to any element because   elements are stored contiguously in memory.</li> <li>Best when the total number of elements is known in advance and fast   indexing is required.</li> </ul>"},{"location":"wk_five/#memory-considerations","title":"Memory Considerations","text":"<ul> <li>Arrays may reserve more space than needed if sized too large.</li> <li>Linked lists only use memory for the nodes currently stored, but each node   requires extra memory for a pointer, and dynamic allocation involves   overhead.</li> </ul>"},{"location":"wk_five/#performance-summary","title":"Performance Summary","text":"Operation / Property Array Linked List Size Fixed at creation Grows and shrinks dynamically Memory Layout Contiguous Distributed (each node separately) Access by Index O(1) direct access O(n) traversal Insert/Delete at Middle Potentially expensive (shift) Efficient with pointer adjustments Extra Memory Required Only for elements Pointer stored in each node"},{"location":"wk_five/#inserting-into-a-linked-list","title":"Inserting into a Linked List","text":"<p>There are two common cases for inserting a new node into a singly linked list:</p> <ol> <li>When the list does not need to maintain sorted order (unsorted insertion)</li> <li>When the list must remain sorted after insertion (sorted insertion)</li> </ol>"},{"location":"wk_five/#1-insertion-in-an-unsorted-list","title":"1. Insertion in an Unsorted List","text":"<p>The simplest approach is to insert the new node at the beginning of the list. This avoids traversal and runs in O(1) time.</p> <p>Steps:</p> <ol> <li>Allocate memory for the new node.</li> <li>Store the data in the new node.</li> <li>Set the new node\u2019s <code>nextPtr</code> to point to the current head.</li> <li>Update the head to point to the new node.</li> </ol> <pre><code>newPtr-&gt;nextPtr = head;\nhead = newPtr;\n</code></pre> Unsorted linked list visual <p> </p>"},{"location":"wk_five/#2-insertion-in-a-sorted-linked-list","title":"2. Insertion in a Sorted Linked List","text":"<p>When the list is sorted, we must find the correct position for the new node so the ordering is preserved.</p> <p>We use two traversal pointers:</p> <ul> <li><code>previousPtr</code> (tracks the node before the insertion point)</li> <li><code>currentPtr</code> (used to walk the list)</li> </ul> <p>Steps:</p> <ol> <li>Allocate memory for the new node. If allocation fails, do not modify the list.</li> <li>Store the new data in the node and set its <code>nextPtr</code> to <code>NULL</code> initially.</li> <li> <p>Initialize traversal pointers:</p> </li> <li> <p><code>previousPtr = NULL</code></p> </li> <li> <p><code>currentPtr = head</code></p> </li> <li> <p>Traverse the list to locate the correct insertion point:</p> </li> <li> <p>While <code>currentPtr != NULL</code> and the new value is greater than      <code>currentPtr-&gt;data</code>:</p> <ul> <li><code>previousPtr = currentPtr</code></li> <li><code>currentPtr = currentPtr-&gt;nextPtr</code></li> </ul> </li> <li> <p>Insert the new node:</p> </li> <li> <p>If <code>previousPtr</code> is <code>NULL</code>, insert at beginning:</p> <pre><code>newPtr-&gt;nextPtr = head;\nhead = newPtr;\n</code></pre> </li> <li> <p>Otherwise, insert between <code>previousPtr</code> and <code>currentPtr</code>:</p> <pre><code>previousPtr-&gt;nextPtr = newPtr;\nnewPtr-&gt;nextPtr = currentPtr;\n</code></pre> </li> </ol> Sorted linked list visual <p> </p>"},{"location":"wk_five/#deleting-a-node-from-a-linked-list","title":"Deleting a Node from a Linked List","text":"<p>Deletion removes a node and reconnects the surrounding nodes so the list remains intact. Two common cases exist: deleting the first node and deleting a node elsewhere in the list.</p>"},{"location":"wk_five/#1-deleting-the-first-node","title":"1. Deleting the First Node","text":"<p>When the first node is removed, the head pointer must be updated to point to the second node.</p> <p>Steps:</p> <ol> <li>Assign a temporary pointer to the current head node.</li> <li>Move the head pointer to the next node.</li> <li>Free the memory of the removed node.</li> </ol> <pre><code>ListNodePtr temp = head;\nhead = head-&gt;nextPtr;\nfree(temp);\n</code></pre> Delete from start (visual) <p> </p>"},{"location":"wk_five/#2-deleting-a-node-elsewhere","title":"2. Deleting a Node Elsewhere","text":"<p>When deleting from the middle or end, traversal pointers are used to find the node preceding the one to remove.</p> <p>Steps:</p> <ol> <li> <p>Traverse the list using two pointers:</p> </li> <li> <p><code>previousPtr</code> tracks the node before the one to delete.</p> </li> <li> <p><code>currentPtr</code> tracks the node being inspected.</p> </li> <li> <p>Stop when <code>currentPtr</code> points to the node to remove.</p> </li> <li>Update <code>previousPtr-&gt;nextPtr</code> to skip over the deleted node.</li> <li>Free the deleted node.</li> </ol> <pre><code>previousPtr-&gt;nextPtr = currentPtr-&gt;nextPtr;\nfree(currentPtr);\n</code></pre> Delete elsewhere (visual) <p> </p> <p>Deleting requires careful pointer management to ensure that the remaining nodes stay properly linked and no memory leaks occur.</p>"},{"location":"wk_five/#checking-if-the-list-is-empty-and-printing-the-list","title":"Checking if the List is Empty and Printing the List","text":"<p>These utility functions help inspect a linked list without modifying it.</p>"},{"location":"wk_five/#checking-if-the-list-is-empty","title":"Checking if the List is Empty","text":"<p>The <code>isEmpty</code> function determines whether a linked list contains any nodes.</p> <pre><code>int isEmpty(ListNodePtr sPtr)\n{\n    return sPtr == NULL;\n}\n</code></pre>"},{"location":"wk_five/#printing-the-list","title":"Printing the List","text":"<p>The <code>printList</code> function traverses the list and displays its contents. If the list is empty, it reports that to the user; otherwise, it prints each node\u2019s data value in sequence.</p> <pre><code>void printList(ListNodePtr currentPtr)\n{\n    if (isEmpty(currentPtr))\n    {\n        puts(\"List is empty.\\n\");\n    }\n    else\n    {\n        puts(\"The list is:\");\n\n        while (currentPtr != NULL)\n        {\n            printf(\"%c --&gt; \", currentPtr-&gt;data);\n            currentPtr = currentPtr-&gt;nextPtr;\n        }\n\n        puts(\"NULL\\n\");\n    }\n}\n</code></pre> <p>This function is often used for debugging or visualizing the list\u2019s current state after insertions or deletions.</p>"},{"location":"wk_five/#merging-two-sorted-lists","title":"Merging Two Sorted Lists","text":"<ol> <li> <p>initialize pointers</p> <ol> <li><code>prevPtr</code> points to NULL</li> <li><code>currPtr</code> points to beginning of list1</li> <li><code>tempPtr</code> points to beginning of list2</li> </ol> </li> <li> <p>Loop through each element of list2 (using <code>tempPtr</code>)</p> <ol> <li> <p>find the correct insertion point in list 1</p> <ol> <li>walk the pointers until <code>tempPtr-&gt;data</code> is less than or equal to <code>currentPtr-&gt;data</code> or <code>currentPtr</code> becomes <code>NULL</code></li> </ol> </li> <li> <p>Insert the node</p> <ol> <li> <p>if <code>prevPtr</code> is <code>NULL</code> then insert at head by</p> <ol> <li>pointing the List2 pointer to the <code>tempPtr-&gt;next</code> node</li> <li>updating the <code>tempPtr-&gt;next</code> node to point to the List1 pointer</li> <li>updating the List1 pointer to point to the <code>tempPtr</code></li> </ol> </li> <li> <p>otherwise:</p> <ol> <li>pointing the List2 pointer to the <code>tempPtr-&gt;next</code> node</li> <li>updating the <code>prevPtr&gt;next</code> node to point to the <code>tempPtr</code> </li> <li>updating the <code>tempPtr-&gt;next</code> to point to the <code>currentPtr</code></li> </ol> </li> </ol> </li> <li> <p>Advance the pointers</p> <ol> <li>move <code>prevPtr</code> to the <code>tempPtr</code> node</li> <li>move <code>tempPtr</code> to the List2 pointer.</li> </ol> </li> </ol> </li> </ol> Merge (visual) <p> </p>"},{"location":"wk_five/#trees","title":"Trees","text":"<p>A tree is a nonlinear, two-dimensional data structure made up of nodes. Unlike linear structures such as arrays or linked lists, trees organize data hierarchically.</p> <p>Each node in a tree may contain multiple links to other nodes. In a binary tree, each node contains two links\u2014commonly called the left and right child pointers. Either or both of these links can be <code>NULL</code>.</p> <p></p>"},{"location":"wk_five/#basic-terminology","title":"Basic Terminology","text":"<ul> <li>Root node \u2013 The topmost node in the tree. It serves as the entry point.</li> <li>Child node \u2013 A node referenced by another node.</li> <li>Parent node \u2013 A node that links to one or more children.</li> <li>Left child \u2013 The first node in the left subtree of a parent.</li> <li>Right child \u2013 The first node in the right subtree of a parent.</li> <li>Siblings \u2013 Nodes that share the same parent.</li> <li>Leaf node \u2013 A node with no children (both links are <code>NULL</code>).</li> </ul>"},{"location":"wk_five/#other-notes","title":"Other Notes","text":"<ul> <li>Not setting a leaf node\u2019s links to <code>NULL</code> can lead to runtime errors.</li> <li>A tree may be empty (no root node) or contain a hierarchy of nodes connected   by pointers.</li> <li>In computer science diagrams, trees are typically drawn with the root at the   top, opposite of how trees appear in nature.</li> </ul>"},{"location":"wk_five/#binary-search-tree-bst","title":"Binary Search Tree (BST)","text":"<p>A binary search tree (BST) is a special type of binary tree that stores unique values and maintains a specific ordering property:</p> <ul> <li>All values in the left subtree of a node are less than the value in   the node\u2019s parent.</li> <li>All values in the right subtree are greater than the value in the   node\u2019s parent.</li> </ul> <p>This ordering allows efficient search, insertion, and deletion operations.</p> <p></p> <p>In the example above, the tree has nine values. Notice that:</p> <ul> <li>Every left child is smaller than its parent.</li> <li>Every right child is larger than its parent.</li> <li>The shape of a BST depends on the order of insertion. Inserting the   same numbers in a different order can produce a completely different tree   structure.</li> </ul> <p>This property enables fast lookups\u2014on average O(log n) time\u2014but in the worst case (such as inserting sorted data without balancing) performance can degenerate to O(n).</p>"},{"location":"wk_five/#preorder-traversal-root-left-right","title":"Preorder Traversal (Root \u2192 Left \u2192 Right)","text":"<p>In a preorder traversal, each node is visited before its subtrees:</p> <ol> <li>Visit the root.</li> <li>Traverse the left subtree.</li> <li>Traverse the right subtree.</li> </ol> <p>This means the root is always processed first.</p> Pre-order Traversal Visual <p>  Your browser does not support the video tag.  </p>"},{"location":"wk_five/#inorder-traversal-left-root-right","title":"Inorder Traversal (Left \u2192 Root \u2192 Right)","text":"<p>In an inorder traversal, the order ensures that nodes are visited in sorted order for a binary search tree:</p> <ol> <li>Traverse the left subtree.</li> <li>Visit the root.</li> <li>Traverse the right subtree.</li> </ol> <p>This traversal is often used to output data in ascending order.</p> In-order Traversal Visual <p>  Your browser does not support the video tag.  </p>"},{"location":"wk_five/#postorder-traversal-left-right-root","title":"Postorder Traversal (Left \u2192 Right \u2192 Root)","text":"<p>In a postorder traversal, subtrees are processed before the parent node:</p> <ol> <li>Traverse the left subtree.</li> <li>Traverse the right subtree.</li> <li>Visit the root.</li> </ol> <p>This traversal is useful for deleting or freeing nodes, since children are handled before their parent.</p> Post-order Traversal Visual <p>  Your browser does not support the video tag.  </p>"},{"location":"wk_five/#pointer-to-pointer-parameters-and-the-insertnode-example","title":"Pointer-to-Pointer Parameters and the <code>insertNode</code> Example","text":"<p>The pointer-to-pointer pattern is required when a function must modify a pointer owned by the caller (e.g., the tree\u2019s root or a child link). Passing the address of that pointer lets the function assign to it directly.</p> <pre><code>void insertNode(TreeNodePtr *treePtr, int value)\n{\n    if (*treePtr == NULL) {\n        *treePtr = malloc(sizeof **treePtr);\n        if (*treePtr) {\n            (*treePtr)-&gt;data = value;\n            (*treePtr)-&gt;leftPtr = NULL;\n            (*treePtr)-&gt;rightPtr = NULL;\n        } else {\n            printf(\"%d not inserted. No memory available.\\n\", value);\n        }\n        return;\n    }\n\n    if (value &lt; (*treePtr)-&gt;data) {\n        insertNode(&amp;((*treePtr)-&gt;leftPtr), value);\n    } else if (value &gt; (*treePtr)-&gt;data) {\n        insertNode(&amp;((*treePtr)-&gt;rightPtr), value);\n    } else {\n        printf(\"dup\\n\");\n    }\n}\n</code></pre> <ul> <li><code>treePtr</code> has type <code>TreeNode **</code> (pointer to a <code>TreeNode *</code>).</li> <li><code>*treePtr</code> is the actual <code>TreeNode *</code> (root or a child link).</li> <li><code>(*treePtr)-&gt;member</code> accesses a field of the node that <code>*treePtr</code> points to.</li> </ul>"},{"location":"wk_five/#why-treeptr-leftptr","title":"Why <code>&amp;((*treePtr)-&gt;leftPtr)</code>?","text":"<p>When you recurse left or right, you must pass the address of the child pointer so the callee can update that pointer in place.</p> <ul> <li><code>(*treePtr)-&gt;leftPtr</code> has type <code>TreeNode *</code> (a child link).</li> <li><code>&amp;((*treePtr)-&gt;leftPtr)</code> therefore has type <code>TreeNode **</code> \u2014 exactly what <code>insertNode</code> expects.</li> </ul> <p>This is the critical difference: you are not passing the address of the node; you are passing the address of the pointer that stores the child link.</p> <pre><code>// Types at each step\nTreeNodePtr  left   = (*treePtr)-&gt;leftPtr;   // TreeNode *\nTreeNodePtr *target = &amp;((*treePtr)-&gt;leftPtr); // TreeNode **\ninsertNode(target, value);                   // matches parameter type\n</code></pre> <p>Operator precedence and parentheses</p> <ul> <li><code>-&gt;</code> binds tighter than unary <code>&amp;</code>, so <code>&amp;(*treePtr)-&gt;leftPtr</code> would be parsed the same as <code>&amp;((*treePtr)-&gt;leftPtr)</code>.</li> <li>The extra parentheses are kept for readability and to avoid misreading the expression as <code>&amp;*treePtr</code> (which simplifies to <code>treePtr</code>, not the child field\u2019s address).</li> </ul> <p>Contrast:</p> <ul> <li><code>&amp;*treePtr</code> \u2192 <code>treePtr</code> (type <code>TreeNode **</code>), the address-of followed by dereference cancels out.</li> <li><code>&amp;((*treePtr)-&gt;leftPtr)</code> \u2192 address of the left child pointer field inside the node pointed to by <code>*treePtr</code>.</li> </ul> <p>A helpful way to read it:</p> <ol> <li><code>*treePtr</code> \u2192 the current node pointer.</li> <li><code>(*treePtr)-&gt;leftPtr</code> \u2192 the left child pointer stored in that node.</li> <li><code>&amp;((*treePtr)-&gt;leftPtr)</code> \u2192 the address of that child pointer (so we can assign to it inside the callee).</li> </ol>"},{"location":"wk_four/","title":"Week 4","text":"<p>This week continued Chapter 10 and covered unions and bit manipulations. </p>"},{"location":"wk_four/#unions","title":"Unions","text":"<p>Like a <code>struct</code>, a <code>union</code> is a derived data type. The difference is that all members of a union occupy the same memory space.</p> <p>This is helpful when different variables are only relevant at different times during program execution. By combining them in a <code>union</code>, you can save memory rather than allocating space for all members simultaneously.</p> <p>In most cases, a <code>union</code> contains two or more items of different types. You can access only one member (and therefore one type) at a time. It is the programmer\u2019s responsibility to reference the data with the proper type \u2014 using the wrong one results in a logic error.</p> <p>The <code>sizeof</code> a <code>union</code> is always equal to the size of its largest member type.</p>"},{"location":"wk_four/#declaring-a-union","title":"Declaring a <code>union</code>","text":"<p>The declaration of a <code>union</code> is very similar to that of a <code>struct</code>:</p> <pre><code>union number { \n    int x; \n    double y; \n};\n</code></pre> <p>As with a <code>struct</code>, defining a <code>union</code> only creates a new type; it does not reserve memory until you declare variables of that type.</p> <p>Tip</p> <p>Union definitions are often placed in header files so they can be reused across multiple source files that require access to the same type definition.</p>"},{"location":"wk_four/#initializing-union-during-declaration","title":"Initializing <code>union</code> During Declaration","text":"<p>You can initialize a variable of a union type during its declaration by assigning a value to the first member type listed in the definition.</p> <pre><code>// 'number' contains the following members in order: int x, double y\nunion number value = {10}; // assigns 10 to x\n</code></pre> <p>Warning</p> <p>If you provide a value intended for a different member during initialization, it will be converted to the first member type instead.</p> <pre><code>// 'number' contains the following members in order: int x, double y\nunion number value = {1.43}; // assigns 1 to x instead of assigning 1.43 to y\n</code></pre>"},{"location":"wk_four/#beyond-the-textbook-tagged-unions","title":"Beyond the Textbook: Tagged Unions","text":"<p>Note</p> <p>The following material was not covered in class (nor in this section of  the text as far as I can tell) and is provided here for informational purposes only.</p> <p>While traditional unions allow multiple types to share the same memory space, they provide no way to track which member is currently active. This makes them error-prone for most applications.</p> <p>A safer and more common modern pattern is the tagged union (also called a discriminated union). A tagged union adds an explicit field, or tag, to record which member of the union is currently valid.</p> <p>This trades a bit of extra overhead for greater safety.</p> <pre><code>enum ValueType { TYPE_INT, TYPE_DOUBLE };\n\nstruct Value {\n    enum ValueType type;   // the tag\n    union {\n        int i;\n        double d;\n    } data;\n};\n</code></pre> <p>This design lets programs safely determine which member to use:</p> <pre><code>struct Value v;\nv.type = TYPE_DOUBLE;\nv.data.d = 3.14;\n\nif (v.type == TYPE_DOUBLE) {\n    printf(\"%f\\n\", v.data.d);\n}\n</code></pre> <p>Info</p> <p>Tagged unions are common in modern C for representing values that may take multiple forms, such as tokens in a compiler or event types in an input system. They are safer and clearer than plain unions while still using shared memory efficiently.</p>"},{"location":"wk_four/#bitwise-operators","title":"Bitwise Operators","text":"<p>Computers represent all data internally as sequences of bits (0s and 1s). Each bit can store one of two values, and groups of bits are used to represent larger quantities. On most systems, eight bits form one byte \u2014 the typical storage unit for a <code>char</code>.</p> <p>Bitwise operators allow direct manipulation of individual bits within integer values. These operations work on the binary representations of the operands and are frequently used for low-level programming, such as hardware control, encoding, and flag management.</p> <p>Note</p> <p>Bitwise operations are typically applied to unsigned integers to avoid ambiguity when dealing with sign bits and system-dependent right-shift behavior.</p>"},{"location":"wk_four/#bitwise-and","title":"Bitwise AND (<code>&amp;</code>)","text":"<p>Sets each bit in the result to 1 only if the corresponding bits in both operands are 1.</p> <pre><code>// 4-bit examples\n//    1101  (13)\n//  &amp; 1011  (11)\n//  --------\n//    1001  (9)\n</code></pre>"},{"location":"wk_four/#bitwise-or","title":"Bitwise OR (<code>|</code>)","text":"<p>Sets each bit in the result to 1 if at least one of the corresponding bits in either operand is 1.</p> <pre><code>//    1101  (13)\n//  | 1011  (11)\n//  --------\n//    1111  (15)\n</code></pre>"},{"location":"wk_four/#bitwise-xor","title":"Bitwise XOR (<code>^</code>)","text":"<p>Sets each bit in the result to 1 only if the corresponding bits in the operands differ.</p> <pre><code>//    1101  (13)\n//  ^ 1011  (11)\n//  --------\n//    0110  (6)\n</code></pre>"},{"location":"wk_four/#left-shift","title":"Left Shift (<code>&lt;&lt;</code>)","text":"<p>Moves bits to the left, filling with zeros from the right. Each left shift by 1 multiplies the number by 2.</p> <pre><code>//    0101  (5)\n//  &lt;&lt; 1\n//  --------\n//    1010  (10)\n</code></pre>"},{"location":"wk_four/#right-shift","title":"Right Shift (<code>&gt;&gt;</code>)","text":"<p>Moves bits to the right, discarding bits on the right. For unsigned values, zeros are filled in from the left. Each right shift by 1 divides the number by 2 (integer division).</p> <pre><code>//    1010  (10)\n//  &gt;&gt; 1\n//  --------\n//    0101  (5)\n</code></pre>"},{"location":"wk_four/#bitwise-not","title":"Bitwise NOT (<code>~</code>)","text":"<p>Inverts each bit of the operand, turning 0s into 1s and 1s into 0s.</p> <pre><code>//    0101  (5)\n//  ~\n//  --------\n//    1010  (10 if only 4 bits are shown)\n</code></pre> <p>Warning</p> <p>In C, <code>~</code> inverts all bits in the operand, not just the visible ones. For fixed-width integers like <code>uint8_t</code>, this means all 8 bits are inverted. When printed as signed types, this can appear as a negative number.</p>"},{"location":"wk_four/#beyond-the-textbook-common-bit-manipulation-techniques","title":"Beyond the Textbook: Common Bit Manipulation Techniques","text":"<p>Note</p> <p>The following material was not covered in class (nor in this section of  the text) and is provided here for informational purposes only.</p> <p>Bit manipulation techniques are frequently used in competitive programming and technical interviews (such as on LeetCode). These operations allow efficient arithmetic and logical computations without relying on higher-level constructs.</p> <p>Below are several common patterns, each explained with examples using 4-bit binary values for clarity.</p>"},{"location":"wk_four/#1-checking-if-a-number-is-even-or-odd","title":"1. Checking if a Number is Even or Odd","text":"<p>You can check the least significant bit (LSB) of a number using the bitwise AND operator.</p> <pre><code>if (x &amp; 1)\n    printf(\"Odd\");\nelse\n    printf(\"Even\");\n</code></pre> <p>Example:</p> <pre><code>//   0101 (5)\n// &amp; 0001\n// ------\n//   0001 -&gt; Odd\n\n//   0110 (6)\n// &amp; 0001\n// ------\n//   0000 -&gt; Even\n</code></pre>"},{"location":"wk_four/#2-swapping-two-numbers-without-a-temporary-variable","title":"2. Swapping Two Numbers Without a Temporary Variable","text":"<p>This uses XOR to swap values in place.</p> <pre><code>a ^= b;\nb ^= a;\na ^= b;\n</code></pre> <p>Example:</p> <pre><code>// a = 0101 (5)\n// b = 0011 (3)\n// Step 1: a = a ^ b -&gt; 0110\n// Step 2: b = b ^ a -&gt; 0101\n// Step 3: a = a ^ b -&gt; 0011\n// Result: a = 3, b = 5\n</code></pre>"},{"location":"wk_four/#3-checking-if-a-number-is-a-power-of-two","title":"3. Checking if a Number is a Power of Two","text":"<p>A number is a power of two if it has exactly one bit set.</p> <pre><code>if (x &gt; 0 &amp;&amp; (x &amp; (x - 1)) == 0)\n    printf(\"Power of 2\");\n</code></pre> <p>Example:</p> <pre><code>//   x = 0100 (4)\n// x-1 = 0011\n// &amp; operation:\n//   0100\n// &amp; 0011 \n//   ---- \n//   0000 -&gt; true\n</code></pre>"},{"location":"wk_four/#4-counting-set-bits-brian-kernighans-algorithm","title":"4. Counting Set Bits (Brian Kernighan\u2019s Algorithm)","text":"<p>This algorithm repeatedly removes the lowest set bit until the number becomes zero.</p> <pre><code>int count = 0;\nwhile (x) {\n    x &amp;= (x - 1);\n    count++;\n}\n</code></pre> <p>Example:</p> <pre><code>// x = 1101 (13)\n// 1101 -&gt; 1100 -&gt; 1000 -&gt; 0000\n// count = 3\n</code></pre>"},{"location":"wk_four/#5-clearing-or-setting-a-specific-bit","title":"5. Clearing or Setting a Specific Bit","text":"<p>To set a bit, use OR; to clear a bit, use AND with the complement of a mask.</p> <pre><code>// Set nth bit\nx |= (1 &lt;&lt; n);\n\n// Clear nth bit\nx &amp;= ~(1 &lt;&lt; n);\n</code></pre> <p>Example:</p> <pre><code>// x = 0101, n = 1\n// (1 &lt;&lt; 1) = 0010\n// Set:   0101 | 0010 = 0111\n// Clear: 0101 &amp; 1101 = 0101 (no change since that bit is already 0)\n</code></pre>"},{"location":"wk_four/#6-toggling-a-bit","title":"6. Toggling a Bit","text":"<p>Flips the specified bit using XOR.</p> <pre><code>x ^= (1 &lt;&lt; n);\n</code></pre> <p>Example:</p> <pre><code>// x = 0101, n = 2\n// (1 &lt;&lt; 2) = 0100\n//   0101 \n// ^ 0100 \n//   ----\n//   0001\n</code></pre>"},{"location":"wk_four/#7-extracting-the-lowest-set-bit","title":"7. Extracting the Lowest Set Bit","text":"<p>Returns a number with only the lowest set bit of <code>x</code> preserved.</p> <pre><code>int lowest = x &amp; -x;\n</code></pre> <p>Example:</p> <pre><code>// x = 1010\n// -x (two\u2019s complement) = 0110\n//   1010 \n// &amp; 0110 \n//   ----\n//   0010\n</code></pre>"},{"location":"wk_four/#8-checking-if-two-integers-have-opposite-signs","title":"8. Checking if Two Integers Have Opposite Signs","text":"<p>Uses XOR to test the sign bit. The result will be negative if the signs differ.</p> <pre><code>if ((x ^ y) &lt; 0)\n    printf(\"Opposite signs\");\n</code></pre> <p>Example:</p> <pre><code>// x = +5 (0101), y = -3 (in 4-bit two\u2019s complement: 1101)\n// x ^ y = 1000 (negative)\n// -&gt; Opposite signs\n</code></pre>"},{"location":"wk_nine/","title":"Week 9","text":"<p>This week covers CLI arguments (as well as some basic shell operations),  <code>calloc()</code> and <code>realloc()</code>, and a bunch of other random topics that seems to just be here to say it was covered..</p>"},{"location":"wk_nine/#command-line-arguments-in-c","title":"Command Line Arguments in C","text":"<p>In C, we can grab arguments from the command line when running a program. To do this, we can supply two arguments to our main function: <pre><code>int main(int argc, char *argv[])\n\n// or equivanlently\n\nint main(int argc, char **argv)\n</code></pre></p> <p><code>int argc</code> stands for the argument count and always includes the name of the program as the first counted element (a program always has at least one argument as a result).</p> <p><code>char *argv[]</code> stands for the argument vector. It is an array of strings representing the different arguments passed (including the name of the program).</p> Example <pre><code>#include &lt;stdio.h&gt;\n\nint main(int argc, char *argv[])\n{\n  for (int i = 0; i &lt; argc; ++i)\n  {\n    printf(\"Argument %d: %-10s\\n\", i + 1, argv[i]);\n  }\n}\n</code></pre> <p> </p>"},{"location":"wk_nine/#shell-operators","title":"Shell Operators","text":"<p>These operators belong to the command-line environment, not to C. They behave the same idea-wise in Unix shells (bash, zsh, etc.) and in Windows CMD/PowerShell, even if some details differ. These operators let you combine, chain, and repurpose command-line programs by directing where their input comes from and where their output goes, making them far more flexible to use at the terminal.</p>"},{"location":"wk_nine/#output-redirection-operator","title":"Output redirection operator <code>&gt;</code>","text":"<p>Sends a program\u2019s stdout to a file, replacing the file if it already exists.</p> Output redirection operator <code>&gt;</code> Example <p> </p>"},{"location":"wk_nine/#output-append-operator","title":"Output append operator <code>&gt;&gt;</code>","text":"<p>Appends stdout to the end of a file instead of overwriting it.</p> Output append redirection operator <code>&gt;&gt;</code> Example <p> </p>"},{"location":"wk_nine/#input-redirection-operator","title":"Input redirection operator <code>&lt;</code>","text":"<p>Uses a file as stdin for the program.</p> Input redirection operator <code>&lt;</code> Example <p> </p>"},{"location":"wk_nine/#pipe-operator","title":"Pipe operator <code>|</code>","text":"<p>Connects the <code>stdout</code> of one program to the <code>stdin</code> of another.</p> Pipe operator <code>|</code> Example <p> </p>"},{"location":"wk_nine/#calloc","title":"<code>calloc</code>","text":"<p><code>calloc</code> is like <code>malloc</code>, but it initializes all allocated memory to zero. It takes two arguments:</p> <ul> <li>The number of elements</li> <li>The size of each element in bytes</li> </ul> <p><pre><code>int num_elements = 4;\nvoid *myZeroedArray = calloc(num_elements, sizeof(int));\n/* The memory layout of myZeroedArray would look like this (assuming returned\n   block starts at address 0x1000):\n\n   Address     | Value (in binary)\n   --------------------------------------------------------------\n   0x1000      | 00000000 00000000 00000000 00000000   (first int)\n   0x1004      | 00000000 00000000 00000000 00000000   (second int)\n   0x1008      | 00000000 00000000 00000000 00000000   (third int)\n   0x100C      | 00000000 00000000 00000000 00000000   (fourth int)\n*/\n</code></pre> Unlike malloc, where memory is allocated but not initialized, calloc ensures that all bytes are set to zero.</p> <p>Note</p> <p>Bob mentioned that, in practice, you don't need to remember the order of the arguments as they are multiplied together and all bits set to 0 so passing them  in the wrong order will still produce a correct result. </p>"},{"location":"wk_nine/#realloc","title":"<code>realloc</code>","text":"<p><code>realloc</code> is used to resize a previously allocated block of memory. It takes two arguments:</p> <ul> <li>A pointer to a block of memory previously allocated with <code>malloc</code>, <code>calloc</code>,   or <code>realloc</code></li> <li>The new desired size in bytes</li> </ul> <pre><code>int num_elements = 4;\nint *arr = malloc(num_elements * sizeof(int));\n\n/* Later, we decide we need space for 8 ints instead of 4: */\nnum_elements = 8;\nint *newArr = realloc(arr, num_elements * sizeof(int));\n\n/* After this call:\n   - If the block can be extended in place, `newArr` will have the same address\n     as `arr`.\n   - If it cannot be extended, a new block is allocated elsewhere, the old data\n     is copied to it, and `arr` is freed automatically.\n   - The newly allocated portion (the extra bytes) is *not initialized*.\n*/\n</code></pre> <p>If <code>realloc</code> fails, it returns NULL and the original pointer remains valid. To avoid losing access to the old memory, it's common to assign the result to a temporary pointer first.</p> <p>Warning</p> <p><code>realloc</code> may move the memory block to a different address. After calling <code>realloc</code>, always use the returned pointer and never the original one.</p>"},{"location":"wk_nine/#other-topics","title":"Other Topics","text":"<p>These topics were covered in class but received very minimal emphasis.</p>"},{"location":"wk_nine/#variable-argument-lists","title":"Variable Argument Lists","text":"<p>Functions can accept an unspecified number of arguments using <code>&lt;stdarg.h&gt;</code>. This is similar to Python's <code>*args</code>, but C provides no runtime type information, so each argument's type must be known in advance.</p> <p>To define such a function, end the parameter list with <code>...</code> and use <code>&lt;stdarg.h&gt;</code> macros to iterate through the unnamed arguments.</p> <pre><code>#include &lt;stdarg.h&gt;\n\nint sum(int count, ...) {\n    va_list args;\n    va_start(args, count);\n\n    int total = 0;\n    for (int i = 0; i &lt; count; i++) {\n        total += va_arg(args, int);\n    }\n\n    va_end(args);\n    return total;\n}\n</code></pre> <p>Key concepts:</p> <ul> <li><code>va_list</code>: object used to traverse unnamed arguments</li> <li><code>va_start(list, last_named_param)</code>: initialize traversal</li> <li><code>va_arg(list, type)</code>: read the next argument as the given type</li> <li><code>va_end(list)</code>: finalize traversal</li> </ul> <p>Notes</p> <ul> <li>Arguments must be read in the order they were passed.</li> <li>Using the wrong type with <code>va_arg</code> is undefined behavior.</li> <li>Commonly used in wrappers around <code>printf</code>-style functionality.</li> </ul>"},{"location":"wk_nine/#constant-literal-suffixes","title":"Constant Literal Suffixes","text":"<p>Suffixes help control literal type, avoid implicit promotions, and prevent overflow.</p> <p>Integer and floating-point literals can be suffixed to control their type. This matters when matching function prototypes, avoiding overflow, or controlling storage size.</p> <pre><code>long a = 5;    // '5' is an int literal; it is implicitly promoted to long\nlong b = 5L;   // '5L' is a long literal; no promotion occurs\n</code></pre> <p>Common suffixes:</p> Literal Meaning integers <code>U</code> Unsigned int <code>L</code> Long int <code>UL</code> or <code>LU</code> Unsigned long <code>LL</code> Long long <code>ULL</code> Unsigned long long floats <code>F</code> Float (otherwise double) <code>L</code> Long double <p>Typical Uses</p> <ul> <li>Prevent overflow in intermediate expressions.</li> <li>Match functions that expect <code>float</code>.</li> <li>Ensure constants match fixed-width integer types.</li> </ul>"},{"location":"wk_nine/#exit-and-atexit","title":"<code>exit</code> and <code>atexit</code>","text":"<p><code>exit</code> terminates the program and runs any cleanup functions previously registered with <code>atexit</code>.</p> <pre><code>exit(EXIT_SUCCESS);\nexit(EXIT_FAILURE);\n</code></pre> <p>Before termination, <code>exit</code> will:</p> <ul> <li>flush open output streams</li> <li>close files</li> <li>call all functions registered with <code>atexit</code></li> </ul> <p><code>atexit</code> registers a function to run automatically when <code>exit</code> is invoked:</p> <pre><code>void cleanup(void) {\n    printf(\"Cleaning up...\\n\");\n}\n\nint main(void) {\n    atexit(cleanup);\n    exit(EXIT_SUCCESS);\n}\n</code></pre> <p>Notes</p> <ul> <li>Functions run in reverse order of registration (LIFO).</li> <li>Useful in library code or for guaranteed cleanup.</li> </ul>"},{"location":"wk_nine/#goto","title":"<code>goto</code>","text":"<p><code>goto</code> transfers control to a labeled statement within the same function.</p> <pre><code>if (error_condition)\n    goto cleanup;\n\ncleanup:\n    free(ptr);\n</code></pre> <p>Key Points</p> <ul> <li>Labels must be inside the same function.</li> <li>No automatic cleanup occurs; stack variables are not unwound.</li> <li>Useful for unified cleanup blocks and breaking out of nested structures.</li> </ul> <p>Warning</p> <p>Avoid using <code>goto</code> for normal control flow; reserve it for cleanup/error paths.</p>"},{"location":"wk_one/","title":"Week 1","text":"<p>This week covers the first half of Chapter 9 in the text. We look in depth at <code>printf</code> formatting including specifiers, field widths, formatting flags, and escape sequences which all help control how output is displayed.</p>"},{"location":"wk_one/#streams","title":"Streams","text":"<p>Streams are sequences of bytes used for input and output.</p> <ul> <li>Input: Data flows from a device (keyboard, disk, network, etc.) into main memory.</li> <li>Output: Data flows from main memory to a device (screen, printer, disk, network, etc.).</li> </ul> <p>At program start, three standard streams are available:</p> <ol> <li>Standard input (<code>stdin</code>) \u2013 usually from the keyboard.</li> <li>Standard output (<code>stdout</code>) \u2013 usually to the screen.</li> <li>Standard error (<code>stderr</code>) \u2013 also to the screen, for error messages.</li> </ol> <p>Redirection: Operating systems allow these streams to be redirected to other devices or files.</p>"},{"location":"wk_one/#printf-formatting","title":"<code>printf</code> Formatting","text":"<p>As we learned in the previous course, <code>printf</code> can be used to format output to <code>stdout</code> using conversion specifications.</p>"},{"location":"wk_one/#type-specifiers","title":"Type Specifiers","text":""},{"location":"wk_one/#integers","title":"Integers","text":"Specifier Description <code>%d</code> Signed decimal integer <code>%i</code> Signed decimal integer (same as <code>%d</code>) <code>%o</code> Unsigned octal integer <code>%u</code> Unsigned decimal integer <code>%x</code> Unsigned hexadecimal integer (lowercase a\u2013f) <code>%X</code> Unsigned hexadecimal integer (uppercase A\u2013F) <code>%hd</code> / <code>%ld</code> / <code>%lld</code> Short, long, or long long integers (length modifiers) <p>Note: if you are using any of the unsigned specifiers, don't pass it any negative numbers.</p> <p>If you are using any of the long length modifiers you should add a corresponding literal suffix (<code>L</code>, <code>LL</code>) to the value that you pass to <code>printf</code>.</p> <pre><code>printf(\"%ld\\n\", 5000000000L); // long (suffix L required)\nprintf(\"%lld\\n\", 9000000000000LL); // long long (suffix LL required)\n</code></pre>"},{"location":"wk_one/#floating-point-numbers","title":"Floating-Point Numbers","text":"Specifier Description <code>%e</code> / <code>%E</code> Exponential (scientific) notation (e.g., <code>1.23e+02</code> or <code>1.23E+02</code>) <code>%f</code> / <code>%F</code> Fixed-point notation <code>%g</code> / <code>%G</code> Uses either <code>%f</code> or <code>%e</code> (<code>%E</code>) depending on value\u2019s magnitude, with no trailing zeros <code>%Lf</code> / <code>%Le</code> / <code>%Lg</code> Long double (length modifier <code>L</code>) <p>The default precision is 6 digits after the decimal (for <code>%f</code>) or 6 significant digits (for <code>%g</code>/<code>%G</code>).</p> <p>Rounding: <code>%e</code>, <code>%E</code>, and <code>%g</code> perform rounding; <code>%f</code> shows exact decimals.</p> <p><code>%g</code>/<code>%G</code> automatically chooses the shortest visual representation for a given number:</p> <ul> <li>Chooses <code>%e</code> if the exponent is &lt; -4 or \u2265 precision.</li> <li>Otherwise chooses <code>%f</code>.</li> <li>Removes trailing zeros.</li> <li>Omits the decimal point if the fractional part is zero.</li> </ul> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"%g\\n\", 87.0);        // 87\n    // whole number, fractional part is zero so \".0\" is suppressed\n\n    printf(\"%g\\n\", 87.50);       // 87.5\n    // fractional part kept, trailing zero removed\n\n    printf(\"%g\\n\", 87.25);       // 87.25\n    // fractional part kept, no trailing zeros to remove\n\n    printf(\"%g\\n\", 0.0000875);   // 8.75e-05\n    // exponent &lt; -4, so %e format is chosen\n\n    printf(\"%g\\n\", 8750000.0);   // 8.75e+06\n    // exponent \u2265 precision (6), so %e format is chosen\n\n    printf(\"%#g\\n\", 87.0);       // 87.0000\n    // '#' flag forces decimal point and trailing zeros up to precision\n\n    return 0;\n}\n</code></pre>"},{"location":"wk_one/#strings-and-characters","title":"Strings and Characters","text":"<ul> <li><code>%c</code> prints a single <code>char</code></li> <li><code>%s</code> prints a null-terminated string (<code>char*</code>), stops at <code>\\0</code></li> <li>Missing null terminator or wrong format specifier (e.g., <code>%s</code> with a <code>char</code>) undefined behavior, often a crash</li> <li>Compilers usually don\u2019t catch format string errors \u2014 they show up only at runtime.</li> </ul>"},{"location":"wk_one/#pointers","title":"Pointers","text":"Specifier Description <code>%p</code> Displays a pointer (address) in an implementation-defined way (commonly hexadecimal) <p><code>%p</code> expects a pointer argument (e.g., <code>&amp;x</code>, or a <code>char*</code>, <code>int*</code>, etc.). The exact format of the address depends on the system, but is typically hexadecimal. Useful for debugging to confirm memory addresses.</p>"},{"location":"wk_one/#field-width","title":"Field Width","text":"<p>You can control the minimum number of characters used when printing a value by specifying a field width.</p> <p>If the value has fewer characters than the field width then it is padded (by default with spaces).</p> <p>Note: If the value has more characters than the field width then the full value is printed (field width is ignored). That is to say, it does not truncate the output.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"%4d\\n\", 1);       //    1\n    printf(\"%4d\\n\", 12);      //   12\n    printf(\"%4d\\n\", 123);     //  123\n    printf(\"%4d\\n\", 1234);    // 1234\n    printf(\"%4d\\n\", 12345);   // 12345 (too wide, prints fully)\n\n    printf(\"%4d\\n\", -1);      //   -1\n    printf(\"%4d\\n\", -12);     //  -12\n    printf(\"%4d\\n\", -123);    // -123\n    printf(\"%4d\\n\", -1234);   // -1234\n    printf(\"%4d\\n\", -12345);  // -12345\n}\n</code></pre>"},{"location":"wk_one/#negative-values","title":"Negative Values","text":"<p>If the value has a negative sign, it will use up one of the field width characters:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"BEFORE%4dAFTER\\n\", 1);        //BEFORE   1AFTER\n    printf(\"BEFORE%4dAFTER\\n\", -1);       //BEFORE  -1AFTER\n    // In the second example, there are only 2 spaces.\n}\n</code></pre>"},{"location":"wk_one/#dynamic-widths","title":"Dynamic Widths","text":"<p>Instead of providing a number, you can pass <code>*</code> instead and then supply the width as one of the values passed instead.</p> <p>This works for precision as well.</p> <pre><code>printf(\"BEFORE%*.*fAFTER\", 7, 2, 98.736); // BEFORE  98.74AFTER\n// 7 \u2192 total field width (minimum size, includes digits, decimal point, and padding)\n// 2 \u2192 precision (number of digits after the decimal point)\n</code></pre>"},{"location":"wk_one/#format-flags","title":"Format Flags","text":""},{"location":"wk_one/#alignment","title":"Alignment","text":"<p>By default, values are right-aligned in the field. To make them left-aligned, add a <code>-</code> before the field width:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"BEFORE%4dAFTER\\n\", 1);        //BEFORE   1AFTER\n    printf(\"BEFORE%-4dAFTER\\n\", 1);       //BEFORE1   AFTER\n}\n</code></pre>"},{"location":"wk_one/#sign-control-for-numbers","title":"Sign Control (for numbers)","text":"<p>By default, only negative numbers are printed with a sign (<code>-</code>). You can control how positive numbers appear using flags:</p> <ul> <li><code>+</code>: always print a sign (<code>+</code> for positive, <code>-</code> for negative).</li> <li>space (<code>' '</code>): print a space in front of positive numbers (negative numbers still get <code>-</code>).</li> </ul> <p>This can be useful for aligning columns of positive and negative numbers.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"%d\\n\", 42);     // 42\n    printf(\"%+d\\n\", 42);    // +42\n    printf(\"% d\\n\", 42);    //  42 (leading space)\n    printf(\"%d\\n\", -42);    // -42\n    printf(\"%+d\\n\", -42);   // -42\n    printf(\"% d\\n\", -42);   // -42\n}\n</code></pre>"},{"location":"wk_one/#alternate-form-flag","title":"Alternate Form (# Flag)","text":"<p>The <code>#</code> flag modifies how certain values are displayed:</p> <ul> <li>Octal (<code>%o</code>): prefixes the value with <code>0</code>.</li> <li>Hexadecimal (<code>%x</code> / <code>%X</code>): prefixes the value with <code>0x</code> or <code>0X</code>.</li> <li> <p>Floating-point (<code>%f</code>, <code>%e</code>, <code>%E</code>, <code>%g</code>, <code>%G</code>): forces a decimal point to appear, even if the fractional part is zero.</p> </li> <li> <p>For <code>%g</code> / <code>%G</code>, it also prevents trailing zeros from being removed.</p> </li> </ul> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    int c = 1427;\n    double p = 1427.0;\n\n    printf(\"%o\\n\", c);    // 2623\n    printf(\"%#o\\n\", c);   // 02623\n\n    printf(\"%x\\n\", c);    // 593\n    printf(\"%#x\\n\", c);   // 0x593\n\n    printf(\"%X\\n\", c);    // 593\n    printf(\"%#X\\n\", c);   // 0X593\n\n    printf(\"%g\\n\", p);    // 1427\n    printf(\"%#g\\n\", p);   // 1427.00 (decimal point forced, trailing zeros kept)\n}\n</code></pre>"},{"location":"wk_one/#zero-padding-0-flag","title":"Zero Padding (0 Flag)","text":"<p>By default, extra space in a field width is filled with spaces. The <code>0</code> flag changes this so that extra space is filled with leading zeros.</p> <ul> <li>Works with integers and floating-point numbers.</li> <li>Often combined with the <code>+</code> flag to show signs with padded numbers.</li> <li>Padding occurs after the sign, not before.</li> </ul>"},{"location":"wk_one/#example","title":"Example","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"%9d\\n\", 452);     // \"      452\" (spaces)\n    printf(\"%09d\\n\", 452);    // \"000000452\" (zeros)\n\n    printf(\"%+09d\\n\", 452);   // \"+00000452\"\n    printf(\"%09d\\n\", -452);   // \"-00000452\"\n}\n</code></pre>"},{"location":"wk_one/#literals-and-escape-sequences","title":"Literals and Escape Sequences","text":"<p>Characters in a format string that are not part of a conversion specification are printed literally.</p> <p>Escape sequences allow you to include special characters in strings that cannot be typed directly or would otherwise be ambiguous.</p> Escape Description <code>\\'</code> Single quote (<code>'</code>) <code>\\\"</code> Double quote (<code>\"</code>) <code>\\?</code> Question mark (<code>?</code>) <code>\\\\</code> Backslash (<code>\\\\</code>) <code>\\a</code> Alert (bell/flash) <code>\\b</code> Backspace <code>\\f</code> Form feed (new page) <code>\\n</code> Newline <code>\\r</code> Carriage return (does not move to beginning of next line) <code>\\t</code> Horizontal tab <code>\\v</code> Vertical tab <code>%%</code> Percent symbol (<code>%</code>) <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Hello\\tWorld\\n\");     // tab between words, newline at end\n    printf(\"Path: C:\\\\temp\\n\");   // prints: Path: C:\\temp\n    printf(\"Beep!\\a\\n\");          // may cause a sound or window flash\n    printf(\"CPU usage: 95%%\\n\");  // CPU usage: 95%\n}\n</code></pre> Why <code>%%</code> isn\u2019t like <code>\\\\n</code> <p>Backslash escapes (like <code>\\\\n</code>, <code>\\\\t</code>, <code>\\\\?</code>) are language features handled at compile time, because they solve parsing or representation issues in string literals.  Percent escapes (like <code>%d</code>, <code>%%</code>) are library features, defined only for functions such as <code>printf</code>/<code>scanf</code> and interpreted at runtime.  In short: <code>\\\\n</code> is replaced by the compiler, while <code>%%</code> is handled later by <code>printf</code>.</p>"},{"location":"wk_one/#formatted-io-variants","title":"Formatted I/O Variants","text":"Function Purpose Typical Use Case <code>fprintf(FILE *fp, const char *format, ...)</code> Prints formatted output to a file stream. Writing data to files. <code>fscanf(FILE *fp, const char *format, ...)</code> Reads formatted input from a file stream. Reading structured file input. <code>sprintf(char *str, const char *format, ...)</code> Writes formatted output into a string buffer. Building formatted strings in memory. <code>sscanf(const char *str, const char *format, ...)</code> Reads formatted input from a string. Parsing string data (e.g., CSV fields). <p>Tip</p> <p>These functions behave like <code>printf</code> and <code>scanf</code>, but redirect input/output to files or strings instead of the console.</p>"},{"location":"wk_seven/","title":"Week 7","text":"<p>This week was the midterm. Bob required us to do a lecture before the midterm  on Big O notation, selection sort, and insertion sort because he cannot manage the time in his courses appropriately.</p>"},{"location":"wk_seven/#big-o-notation","title":"Big O Notation","text":"<p>Big O notation is a mathematical notation that describes the limiting behaviour of a function. It is one of the asymptotic notations and describes  what a function does as its arguments tend to large values (infinity). </p> <p>The O stands for \"order of\" approximation. It represents the upper bound or  worst case performance of the growth rate of a function. It is used to show how the function grows in relation to the number of inputs: will it remain  constant (<code>O(1)</code>) time to perform, will it grow quadratically (<code>O(n\u00b2)</code>), etc.</p> <p>In this course we only look at this from the most simplistic, basic lens. That is, we should be aware of a few of the common complexities using <code>n</code> to  represent the number of inputs:</p> <p>Common Complexities</p> <ul> <li> <p><code>O(1)</code> Constant Time</p> <ul> <li>Execution time stays the same even as <code>n</code> increases</li> <li>Example: direct array access</li> </ul> </li> <li> <p><code>O(log n)</code> Logarithmic Time</p> <ul> <li>Doubling <code>n</code> only adds another constant amount of time.</li> <li>Example: binary search</li> </ul> </li> <li> <p><code>O(n)</code> Linear Time</p> <ul> <li>Directly proportional to <code>n</code>. </li> <li>Example: simple loop through elements of an array.</li> </ul> </li> <li> <p><code>O(n log n)</code> Log Linear Time</p> <ul> <li>Combination of linear and logarithmic behaviour</li> <li>Example: Merge sort, heapsort, quicksort (average case).</li> </ul> </li> <li> <p><code>O(n\u00b2)</code> Quadratic Time</p> <ul> <li>Grows exponentially as <code>n</code> increases in a quadratic way (square of <code>n</code>).</li> <li>Example: Nested loops, naive matrix multiplication, bubble sort.</li> </ul> </li> <li> <p><code>O(n\u00b3)</code> Cubic Time</p> <ul> <li>Grows exponentially as <code>n</code> increases in a cubic way (cube of <code>n</code>).</li> <li>Example: Floyd\u2013Warshall shortest path algorithm.</li> </ul> </li> <li> <p><code>O(2\u207f)</code> Exponential Time</p> <ul> <li>Algorithms that consider every subset or combination.</li> <li>Examples: Brute-force traveling salesman, subset generation.</li> </ul> </li> <li> <p><code>O(n!)</code> Factorial Time</p> <ul> <li>Grows faster than any exponential function; work explodes as <code>n</code> increases because it considers all possible permutations of <code>n</code> items</li> <li>Example: Brute-force traveling salesperson problem by checking all permutations.</li> </ul> </li> </ul>"},{"location":"wk_seven/#determining-big-o-complexity","title":"Determining Big-O Complexity","text":"<p>Rules of Thumb</p> <ul> <li> <p>Drop Constants     Big-O ignores fixed factors.  </p> <ul> <li><code>O(2n)</code> \u2192 <code>O(n)</code> </li> <li><code>O(n + 100)</code> \u2192 <code>O(n)</code></li> </ul> </li> <li> <p>Add Sequential Operations     If code runs one after another, add their costs, then simplify.  </p> <ul> <li><code>O(n) + O(n)</code> \u2192 <code>O(2n)</code> \u2192 <code>O(n)</code></li> </ul> </li> <li> <p>Multiply Nested Loops     Inner loop work multiplies outer loop work.  </p> <ul> <li><code>O(n) * O(n)</code> \u2192 <code>O(n\u00b2)</code> If the inner loop runs <code>1..i</code>, the total is  </li> <li><code>1 + 2 + ... + n = O(n\u00b2)</code> Always consider the worst case.</li> </ul> </li> <li> <p>Different Input Sizes     Don\u2019t merge unrelated inputs.  </p> <ul> <li>Sequential \u2192 <code>O(n + m)</code> </li> <li>Nested \u2192 <code>O(n * m)</code> Only combine when they represent the same dataset.</li> </ul> </li> <li> <p>Keep the Dominant Term     Keep only the highest-growth part.  </p> <ul> <li><code>O(n\u00b2 + n)</code> \u2192 <code>O(n\u00b2)</code> </li> <li><code>O(n\u00b3 + n log n)</code> \u2192 <code>O(n\u00b3)</code></li> </ul> </li> <li> <p>Recognize Logarithmic Behavior     Happens when work shrinks by a constant factor, usually halving.     Examples: binary search, heaps, balanced trees, divide-and-conquer depth.</p> </li> </ul>"},{"location":"wk_seven/#selection-sort","title":"Selection Sort","text":"<p>The selection sort algorithm sorts an array by repeatedly finding the smallest  element in the unsorted portion of the array and swapping it into its correct  position at the front.</p> <ol> <li>Find the smallest element in the entire array and swap it with the first element.</li> <li>Then find the smallest element in the remaining unsorted part of the array     and swap it with the first element of that unsorted portion.</li> <li>Continue this process until the entire array is sorted.</li> </ol> Selection Sort Visual <p>  Your browser does not support the video tag.  </p> <p>Alternatively, see the animation from Y. Daniel Liang / Pearson Education which was used in class: https://liveexample.pearsoncmg.com/dsanimation/SelectionSortWithCpp.html</p>"},{"location":"wk_seven/#insertion-sort","title":"Insertion Sort","text":"<p>The insertion sort algorithm builds a sorted portion of the array one element at a time. At each step, it takes the next element from the unsorted portion and inserts it into the correct position within the sorted portion.</p> <ul> <li>Start with the first element (a one-element array is already sorted).</li> <li>Take the next element and compare it with the elements in the sorted portion.</li> <li>Shift larger elements one position to the right.</li> <li>Insert the current element into its correct position.</li> <li>Repeat for each element until the array is fully sorted.</li> </ul> Insertion Sort Visual <p>  Your browser does not support the video tag.  </p> <p>Alternatively, see the animation from Y. Daniel Liang / Pearson Education which was used in class: https://liveexample.pearsoncmg.com/dsanimation/InsertionSortWithCpp.html</p>"},{"location":"wk_seven/#other-animations-from-y-daniel-liang","title":"Other Animations from Y. Daniel Liang","text":"<p>The author of the animations that Bob uses in class has similar ones for other algorithms which can be found at the link below with corresponding code in C++, Java, or Python:       https://liveexample.pearsoncmg.com/dsanimation/ </p>"},{"location":"wk_six/","title":"Week 6","text":"<p>This week covers using variants of a linked list to implement stacks and queues.</p>"},{"location":"wk_six/#stacks","title":"Stacks","text":"<p>A stack is a specialized form of a linked list where insertion and deletion can only occur at one end, called the top of the stack.</p> <p>Stacks follow the Last-In, First-Out (LIFO) principle: the most recently inserted element is the first one removed.</p>"},{"location":"wk_six/#basic-structure","title":"Basic Structure","text":"<p>A stack can be implemented as a linked list, where each node contains:</p> <ul> <li>The data being stored.</li> <li>A pointer to the next node.</li> </ul> <p>The top pointer (<code>stackPtr</code>) always points to the node at the top of the stack. The last node\u2019s link is set to <code>NULL</code> to mark the end of the stack.</p> <pre><code>struct stackNode {\n    int data;             // value stored in the node\n    struct stackNode *nextPtr; // pointer to next node\n};\n</code></pre> <p>Using <code>typedef</code> can make this cleaner:</p> <pre><code>typedef struct stackNode StackNode;\ntypedef StackNode *StackNodePtr;\n</code></pre>"},{"location":"wk_six/#primary-operations","title":"Primary Operations","text":"<p>The two main operations on a stack are push and pop:</p> <ul> <li><code>push(StackNodePtr *topPtr, int value)</code> \u2013 Creates a new node and places it on top of the stack.</li> <li><code>pop(StackNodePtr *topPtr)</code> \u2013 Removes the top node, returns its data, and frees its memory.</li> </ul> <p>In addition, we often include:</p> <ul> <li><code>isEmpty(StackNodePtr topPtr)</code> \u2013 Returns true if the stack is empty.</li> <li><code>printStack(StackNodePtr currentPtr)</code> \u2013 Displays the contents of the stack.</li> </ul>"},{"location":"wk_six/#push-operation","title":"Push Operation","text":"<p>The push operation adds a new element to the top of the stack.</p> <ol> <li>Use <code>malloc</code> to create a new node.</li> <li>Assign the new node\u2019s data field.</li> <li>Point the new node\u2019s <code>nextPtr</code> to the current top node.</li> <li>Update the stack pointer (<code>stackPtr</code>) to point to the new node.</li> </ol> <p>This ensures the new node becomes the first element accessed when popping.</p> <pre><code>void push(StackNodePtr *topPtr, int value)\n{\n    StackNodePtr newPtr = malloc(sizeof(StackNode));\n\n    if (newPtr != NULL) {\n        newPtr-&gt;data = value;\n        newPtr-&gt;nextPtr = *topPtr; // link new node to previous top\n        *topPtr = newPtr;          // move top pointer to new node\n    }\n    else {\n        printf(\\\"No memory available. %d not inserted.\\n\", value);\n    }\n}\n</code></pre> Push Visualization <p> </p>"},{"location":"wk_six/#pop-operation","title":"Pop Operation","text":"<p>The pop operation removes the element currently at the top of the stack. It returns the popped value and frees the corresponding node from memory.</p> <ol> <li>If the stack is empty, the operation cannot proceed.</li> <li>Create a temporary pointer (<code>tempPtr</code>) to hold the current top node.</li> <li>Move the stack pointer (<code>stackPtr</code>) to the next node in the stack.</li> <li>Free the memory for the node stored in <code>tempPtr</code>.</li> </ol> <pre><code>int pop(StackNodePtr *topPtr)\n{\n    int value = (*topPtr)-&gt;data;\n    StackNodePtr tempPtr = *topPtr;   // store current top\n    *topPtr = (*topPtr)-&gt;nextPtr;     // move top to next node\n    free(tempPtr);                    // free old top\n    return value;                     // return popped value\n}\n</code></pre> Pop Visualization <p> </p> <p>After popping, the stack pointer points to the new top node. If all nodes are removed, it becomes <code>NULL</code>, indicating an empty stack.</p>"},{"location":"wk_six/#queues","title":"Queues","text":"<p>A queue is a data structure that operates on the First-In, First-Out (FIFO) principle, similar to a line at a grocery store.</p> <ul> <li>The first person in line receives service first.</li> <li>New customers (or elements) join the end of the line and must wait their turn.</li> </ul> <p>In a queue:</p> <ul> <li>Insertion (enqueue) occurs at the rear (or tail).</li> <li>Removal (dequeue) occurs at the front (or head).</li> </ul> <p>This means that the element inserted earliest is the first to be removed.</p> <p>Queues are used in many areas of computing:</p> <ul> <li>Process Scheduling: When multiple programs or threads compete for CPU time, waiting processes are stored in a queue until the CPU becomes available.</li> <li>Print Spooling: Print jobs are queued until the printer can process them, much like thread spooling in sewing.</li> <li>Network Routing: Data packets are queued at routers before being sent along the network path.</li> </ul> <p>Queues ensure orderly, predictable access to shared resources, where the first to arrive is the first to be processed.</p>"},{"location":"wk_six/#queue-implementation","title":"Queue Implementation","text":"<p>A queue can be implemented as a linked list, where each node contains:</p> <ul> <li>The data to store.</li> <li>A pointer to the next node.</li> </ul> <p>Two pointers are maintained:</p> <ul> <li><code>frontPtr</code> \u2013 Points to the first node (head) of the queue.</li> <li><code>rearPtr</code> \u2013 Points to the last node (tail) of the queue.</li> </ul> <pre><code>struct queueNode {\n    int data;                  // value stored in the node\n    struct queueNode *nextPtr; // pointer to next node\n};\n\ntypedef struct queueNode QueueNode;\ntypedef QueueNode *QueueNodePtr;\n</code></pre>"},{"location":"wk_six/#queue-operations","title":"Queue Operations","text":"<p>The main operations of a queue are enqueue and dequeue:</p>"},{"location":"wk_six/#enqueue","title":"Enqueue","text":"<p>Adds a new node to the rear of the queue.</p> <pre><code>void enqueue(QueueNodePtr *frontPtr, QueueNodePtr *rearPtr, int value)\n{\n    QueueNodePtr newPtr = malloc(sizeof(QueueNode));\n\n    if (newPtr != NULL) {\n        newPtr-&gt;data = value;\n        newPtr-&gt;nextPtr = NULL;\n\n        // if queue is empty, new node is both front and rear\n        if (*frontPtr == NULL)\n            *frontPtr = newPtr;\n        else\n            (*rearPtr)-&gt;nextPtr = newPtr;\n\n        *rearPtr = newPtr;\n    }\n    else {\n        printf(\"No memory available. %d not inserted.\\n\", value);\n    }\n}\n</code></pre> Enqueue Visualization <p> </p>"},{"location":"wk_six/#dequeue","title":"Dequeue","text":"<p>Removes a node from the front of the queue and returns its value.</p> <pre><code>int dequeue(QueueNodePtr *frontPtr, QueueNodePtr *rearPtr)\n{\n    int value = (*frontPtr)-&gt;data;\n    QueueNodePtr tempPtr = *frontPtr;  // store current front\n\n    *frontPtr = (*frontPtr)-&gt;nextPtr;  // move front to next node\n\n    // if queue is now empty, rear must also be NULL\n    if (*frontPtr == NULL)\n        *rearPtr = NULL;\n\n    free(tempPtr);\n    return value;\n}\n</code></pre> Dequeue Visualization <p> </p>"},{"location":"wk_ten/","title":"Week 10","text":"<p>This week covers function pointers and continues on file processing with index files.</p>"},{"location":"wk_ten/#function-pointers","title":"Function Pointers","text":"<p>A function pointer stores the address of a function. When used correctly, it allows functions to be passed as arguments, stored in arrays, or reassigned.</p>"},{"location":"wk_ten/#basic-form","title":"Basic Form","text":"<pre><code>int add(int a, int b) {\n    return a + b;\n}\n\nint (*fp)(int, int) = add;\nint result = fp(3, 4); // 7\n</code></pre> <p>Why Parentheses Matter</p> <p>If you dont wrap the return type in parentheses, you declare a regular  function rather than a function pointer. </p> <pre><code>int (*fp)(int, int);   // pointer to function\nint *fp2(int, int);    // function returning int*\n</code></pre>"},{"location":"wk_ten/#qsort","title":"<code>qsort</code>","text":"<p><code>qsort</code> is a standard library function (in <code>&lt;stdlib.h&gt;</code>) used to sort an array of arbitrary elements by using a user-supplied comparison function.</p> <pre><code>qsort(arr, count, sizeof(int), &lt;comparator function&gt;);\n</code></pre> <p>It requires a function pointer to a comparator function matching this signature:</p> <pre><code>int (*compare)(const void *left, const void *right);\n</code></pre> <p>Any comparator function for <code>qsort</code> must:</p> <ul> <li>accept two <code>const void *</code> pointers (pointing to elements being compared)</li> <li> <p>return:</p> <ul> <li>a negative value if left &lt; right</li> <li>zero if left == right</li> <li>a positive value if left &gt; right</li> </ul> </li> </ul> int Comparator Example <pre><code>int compareInts(const void *a, const void *b) {\n    int x = *(const int *)a;\n    int y = *(const int *)b;\n    return (x &gt; y) - (x &lt; y);\n}\n</code></pre>"},{"location":"wk_ten/#indexing-a-data-file","title":"Indexing a Data File","text":"<p>Typically, the only way to find a specific record in a data file is to scan from the beginning until it is found. For large files, this becomes slow.</p> <p>To solve this, we can create a secondary index file which stores some meta information about the data and each record\u2019s key and its byte offset, an index value, which allows a program reading the data to jump directly to the required record.</p> <p>Think of it like the index in a textbook.</p>"},{"location":"wk_ten/#creating-index-files","title":"Creating Index Files","text":"<p>Index files typically have two parts to them.</p> <ol> <li> <p>Index Header</p> <p>The header contains general information needed to read and interpret the index. This usually includes:</p> <ul> <li>the number of records  </li> <li>the size or format of each key  </li> <li>any identifying information linking this index to the corresponding data file  </li> </ul> <p>The header does not contain any actual record data.</p> </li> <li> <p>Index Records</p> <p>Each index record stores two pieces of information:</p> <ul> <li>the key for the record  </li> <li>the byte offset of that record in the data file</li> </ul> </li> </ol> <p>Creating an Index File</p> <p>This is the typical process for creating an index file for a given data file. <pre><code>1. Read the data file sequentially.\n2. For each record, record its key and the file position where it starts.\n3. Store all (key, offset) pairs in an array.\n4. Sort this array by key (using qsort).\n5. Write the index header.\n6. Write all index records in sorted order.\n</code></pre></p> <p>This produces a compact structure the program can search quickly.</p> <p>Structure</p> <p>After indexing, the structure will look something like this with two files.</p> <p>Data File (full records) <pre><code>[ Record 1 data ... ]\n[ Record 2 data ... ]\n[ Record 3 data ... ]\n[ ... ]\n</code></pre></p> <p>Index File (keys + offsets only) <pre><code>[ Index Header ]\n[ Key 1 | Offset of Record 1 ]\n[ Key 2 | Offset of Record 2 ]\n[ Key 3 | Offset of Record 3 ]\n[ ... ]\n</code></pre></p>"},{"location":"wk_ten/#using-an-index-file","title":"Using an Index File","text":"<p>Once the index file is created, the program can use it to quickly locate and load specific records from the data file without scanning.</p> <p>Reading data using an Index File</p> <p>This is the typical process for reading a data file using an index file. <pre><code>1. Open the data file and the index file.\n2. Read the index header.\n3. Load all index records into memory.\n4. Search the index records for the desired key.\n5. Retrieve the byte offset associated with that key.\n6. Use fseek() to jump to that position in the data file.\n7. Read the record from the data file.\n</code></pre></p> Example using <code>fseek</code> With an Index Offset <p>Step 1: Use the index file to find the offset for the desired key</p> <pre><code>FILE *indexFp = fopen(\"data.idx\", \"rb\");\n\nIndexHeader hdr;\nfread(&amp;hdr, sizeof(IndexHeader), 1, indexFp);\n\nIndexRecord *records = malloc(hdr.recordCount * sizeof(IndexRecord));\nfread(records, sizeof(IndexRecord), hdr.recordCount, indexFp);\n\nlong offset = -1;\n\nfor (int i = 0; i &lt; hdr.recordCount; i++)\n{\n    if (strcmp(records[i].key, targetKey) == 0)\n    {\n        offset = records[i].offset;\n        break;\n    }\n}\n\nfclose(indexFp);\n</code></pre> <p>Step 2: Jump directly to the correct record in the data file</p> <pre><code>FILE *fp = fopen(\"data.dat\", \"rb\");\n\nif (fp != NULL &amp;&amp; offset &gt;= 0)\n{\n    fseek(fp, offset, SEEK_SET);\n\n    DataRecord rec;\n    fread(&amp;rec, sizeof(DataRecord), 1, fp);\n\n    fclose(fp);\n}\n</code></pre> <p>The data file is not searched directly. The program reads the index file, finds the offset, and then jumps straight to that position.</p>"},{"location":"wk_three/","title":"Week 3","text":"<p>This week covers structures and typedefs.</p>"},{"location":"wk_three/#structures","title":"Structures","text":"<p>A structure is a collection of related variables grouped under one name. In the C standard, structures are referred to as aggregates.</p> <p>The <code>struct</code> keyword is used to define a structure type:</p> <pre><code>// A structure for representing a playing card.\nstruct card {\n    const char *face;\n    const char *suit;\n};  // Note: a semicolon is required after the closing brace.\n</code></pre> <p>The example above defines a new structure type named <code>card</code>. The variables declared inside the braces (<code>face</code> and <code>suit</code>) are called members.</p> <p>Since this type definition is a declaration, a semicolon must follow the  closing brace.</p>"},{"location":"wk_three/#member-types","title":"Member Types","text":"<p>Structures can contain members of different types. However, a structure cannot contain a member that is an instance of its own type. For example, the following is invalid:</p> <pre><code>// Invalid: a structure cannot contain an instance of itself.\nstruct card {\n    const char *face;\n    const char *suit;\n    struct card nextCard;  // Invalid\n};\n</code></pre> <p>To work around this, use a pointer to the same type:</p> <pre><code>// Valid: a structure can contain a pointer to its own type.\nstruct card {\n    const char *face;\n    const char *suit;\n    struct card *nextCard;  // Valid\n};\n</code></pre> <p>This pattern is commonly used for creating nodes in a linked list.</p>"},{"location":"wk_three/#defining-variables-of-structure-types","title":"Defining Variables of Structure Types","text":"<p>Structure definitions alone only create a new type that can be used later in  code; they do not reserve any space in memory. A structure definition is  essentially a blueprint. To begin reserving memory for variables, use the  following syntax:</p> <pre><code>// create a new card struct\nstruct card myCard;\n\n// or create an array of card structs\nstruct card deck[52];\n\n// or create a pointer to a card struct\nstruct card *cardPtr;\n</code></pre> <p>You can also create variables of a struct during the definition of the struct  by providing a comma-separated list of variable names after the closing  brace of the struct but before the ending semicolon of the declaration:</p> <pre><code>struct card {\n    const char *face;\n    const char *suit;\n} myCard, deck[52], *cardPtr;\n</code></pre>"},{"location":"wk_three/#structures-without-tag-names","title":"Structures without Tag Names","text":"<p>You can define a struct without a tag name:</p> <pre><code>struct {    // NOTE: no \"card\" tag name\n    const char *face;\n    const char *suit;\n} exampleCard;\n</code></pre> <p>However, without a tag name, you cannot declare additional variables of this  type later in the program. Therefore, you must provide variable names during the declaration to use them.</p> <pre><code>// This defines and declares two variables immediately.\nstruct {\n    int x;\n    int y;\n} point1, point2;\n</code></pre>"},{"location":"wk_three/#comparing-structure-objects","title":"Comparing Structure Objects","text":"<p>Structures cannot be compared using the operators <code>==</code> or <code>!=</code> because structure members may not be stored in consecutive bytes of memory. Compilers often insert padding bytes to align data members according to their type\u2019s alignment requirements.</p> <p>These holes contain unspecified values, which may differ between structures even if all members are identical. In rare cases, they might coincidentally contain the same garbage data (for example, if memory was recently zeroed or reused), making a bytewise comparison appear to return true. However, this behavior is entirely undefined and cannot be relied upon.</p> <p>In short, even if two structures look the same in memory, the C standard provides no guarantee that comparing them byte-by-byte would produce consistent results.</p> Illustration of padding and comparison <p>Suppose we have a struct defined as follows, with two variables of that type named <code>sample1</code> and <code>sample2</code>.</p> <pre><code>struct example {\n    char c;\n    int i;\n} sample1, sample2;\n</code></pre> <p>Initially, the variables contain garbage values:</p> <p></p> <p>We then assign values to the members of <code>sample1</code>:</p> <pre><code>sample1.c = 'G';\nsample1.i = 42069;\n</code></pre> <p></p> <p>Notice that the <code>int</code> portion begins at byte 4. This is because integers must align on a 4-byte boundary, leaving a gap in bytes 1\u20133.</p> <p>Next, we assign the same values to the members of <code>sample2</code>:</p> <pre><code>sample2.c = 'G';\nsample2.i = 42069;\n</code></pre> <p></p> <p>When comparing the two, the visible members appear equivalent, but the hidden padding bytes may contain different, undefined values. Even if both happen to contain zeros or identical garbage, it would be by coincidence, not by rule. The result of comparing such structs directly would therefore be undefined.</p> <p></p> <p>Warning</p> <p>Padding bytes are not initialized or standardized by the C language. Comparing structs as raw memory is undefined behavior and should never be used as a substitute for member-by-member comparison.</p> <p></p>"},{"location":"wk_three/#using-sizeof-with-structures","title":"Using <code>sizeof</code> with Structures","text":"<p>The <code>sizeof</code> operator can be used to determine the amount of memory a structure occupies. However, the value returned by <code>sizeof</code> a structure often exceeds the sum of its members' sizes due to padding and alignment.</p> <p>For example:</p> <pre><code>struct example {\n    char c;\n    int i;\n};\n\nprintf(\"%zu\\n\", sizeof(struct example));  // Likely prints 8, not 5\n</code></pre> <p>The <code>sizeof</code> value includes both the member data and any extra bytes the compiler adds to satisfy memory alignment requirements.</p> <p>Structure packing and alignment</p> <p>When structures are stored in memory, the compiler may insert padding bytes  between members to align data according to hardware requirements. This  improves access performance but can waste space.</p> <p>You can minimize wasted space by ordering structure members from largest to  smallest type (for example, <code>double</code> then <code>int</code> then <code>char</code>).</p> <p>Some compilers provide directives like <code>#pragma pack</code> to override default  alignment and reduce padding. However, this is compiler-specific and  may lead to portability or performance issues. </p> <p>It is generally recommended to avoid using <code>#pragma pack</code> unless you  have a clear and justified need, such as matching external binary data formats.</p>"},{"location":"wk_three/#typedef","title":"<code>typedef</code>","text":"<p><code>typedef</code> allows you to create synonyms (or aliases) for previously defined types.</p> <p>It is commonly used to create shorter names for struct types and simplify declarations of types like function pointers.</p> <p>Tip</p> <p>You can use typedef to avoid retyping out struct card each time you create a new variable of type card.</p> <pre><code>typedef struct card Card;\n// you can now declare a new card struct as follows\nCard newCard;\n</code></pre>"},{"location":"wk_three/#combining-typedef-with-struct-definitions","title":"Combining <code>typedef</code> with <code>struct</code> Definitions","text":"<p>You can combine <code>typedef</code> with a <code>struct</code> declaration to make your code cleaner  and more readable.</p> <p>Tip</p> <pre><code>// Basic struct definition\nstruct card {\n    const char *face;\n    const char *suit;\n};\n\n// typedef struct definition\ntypedef struct {\n    const char *face;\n    const char *suit;\n} Card;\n\n// Create an instance of each\nstruct card basicCard;\nCard typeDefCard;\n</code></pre> <p>Using <code>typedef</code> in this way eliminates the need to repeatedly write <code>struct</code>  when declaring variables and clearly separates the definition of the structure  from its use as a type.</p> <p>Warning</p> <p>When using <code>typedef</code> in this manner, do not include variables in the  struct definition itself. Doing so would cause those variables to be  recreated every time the alias is used.</p> <p>If you need to define variables along with the structure, use the standard  <code>struct</code> definition and then follow it with a separate <code>typedef</code> alias, as  shown in the previous section.</p>"},{"location":"wk_three/#creating-readable-and-consistent-type-aliases","title":"Creating Readable and Consistent Type Aliases","text":"<p><code>typedef</code> is also used to create clear, platform-independent type names.  This is common in system-level programming and game development, where  developers want to ensure that integer sizes and data types are explicit and  consistent across compilers.</p> <p>For example, we can define type aliases like this:</p> <pre><code>typedef uint8_t  uint8;\ntypedef uint16_t uint16;\ntypedef uint32_t uint32;\ntypedef uint64_t uint64;\n\ntypedef int8_t  int8;\ntypedef int16_t int16;\ntypedef int32_t int32;\ntypedef int64_t int64;\n\ntypedef int32 bool32;\n\ntypedef float  real32;\ntypedef double real64;\n</code></pre> <p>These aliases improve clarity by clearly expressing the intended size  and purpose of each type, regardless of the compiler or platform.</p> <p>Info</p> <p>This technique helps:</p> <ul> <li>Make code explicit about the bit-width of each type.</li> <li>Improve portability, since <code>stdint.h</code> guarantees fixed-width integer  types like <code>int32_t</code> and <code>uint16_t</code>.</li> <li>Enhance readability, particularly in codebases where naming  consistency (like <code>real32</code> vs <code>float</code>) helps distinguish between conceptual  or mathematical types.</li> </ul>"},{"location":"wk_two/","title":"Week 2","text":"<p>This week covers formatted input using <code>scanf</code> and recursion.</p>"},{"location":"wk_two/#formatted-input-with-scanf","title":"Formatted Input with <code>scanf</code>","text":"<p><code>scanf</code> statements contain a format control string that specifies how input should be read, followed by pointers to variables where the input will be stored.</p> <p>Key capabilities:</p> <ol> <li>Inputting all types of data.</li> <li>Inputting specific characters from an input stream.</li> <li>Skipping specific characters in an input stream.</li> </ol>"},{"location":"wk_two/#scanf-syntax","title":"<code>scanf</code> Syntax","text":"<pre><code>scanf(format-control-string, other-arguments);\n</code></pre> <p>format-control-string \u2013 describes input formats using conversion specifiers. other-arguments \u2013 pointers to variables that will receive the input.</p> <pre><code>- Prompt the user for one (or a few) items at a time.\n- Avoid asking for many inputs in one statement.\n- Always handle the possibility of incorrect data (e.g., invalid integers or\n  strings with missing punctuation).\n</code></pre>"},{"location":"wk_two/#conversion-specifiers","title":"Conversion Specifiers","text":"<p>Like <code>printf</code>, <code>scanf</code> uses conversion specifiers to handle different data types. Some specifiers differ between input (<code>scanf</code>) and output (<code>printf</code>).</p> Specifier Description Integers <code>%d</code> Reads a signed decimal integer <code>int*</code> <code>%i</code> Reads signed decimal, octal, or hexadecimal <code>int*</code> <code>%o</code> Reads an octal integer <code>unsigned int*</code> <code>%u</code> Reads an unsigned decimal integer <code>unsigned int*</code> <code>%x</code> / <code>%X</code> Reads a hexadecimal integer <code>unsigned int*</code> <code>h</code>, <code>l</code>, <code>ll</code> Length modifiers (<code>short</code>, <code>long</code>, <code>long long</code>) for integers Floating-point <code>%e</code>, <code>%E</code>, <code>%f</code>, <code>%F</code>, <code>%g</code>, <code>%G</code> Reads a floating-point value <code>float*</code> / <code>double*</code> <code>l</code> or <code>L</code> Length modifiers for <code>double</code> or <code>long double</code> Characters &amp; Strings <code>%c</code> Reads a single character <code>char*</code> (no <code>\\0</code> added) <code>%s</code> Reads a string <code>char[]</code> (terminates with <code>\\0</code>) Scan set <code>%[...]</code> Reads a set of characters into a string Miscellaneous <code>%p</code> Reads an address (pointer format) <code>%n</code> Stores number of characters read so far <code>int*</code> <code>%%</code> Skips a literal <code>%</code> in input"},{"location":"wk_two/#using-scan-sets","title":"Using Scan Sets","text":"<p>A scan set allows input of only certain characters, defined inside square brackets <code>[]</code> after a <code>%</code> in the format string. Input continues until a character not in the scan set is encountered.</p> <p>Example: using <code>%[aeiou]</code> reads only vowels.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char z[9] = \"\";\n    printf(\"%s\", \"Enter string: \");\n    scanf(\"%8[aeiou]\", z); // only vowels\n    printf(\"The input was \\\"%s\\\"\\n\", z);\n    return 0;\n}\n</code></pre> <p>Input: <code>oeeeooahah</code> \u2192 stops at <code>h</code>, outputs <code>oeeeooa</code>.</p>"},{"location":"wk_two/#inverting-the-scan-set","title":"Inverting the Scan Set","text":"<p>An inverted scan set matches characters not in the given set. Use a <code>^</code> inside the brackets to invert.</p> <p>Example: <code>%[^aeiou]</code> reads only consonants and other non-vowels.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char z[9] = \"\";\n    printf(\"%s\", \"Enter a string: \");\n    scanf(\"%8[^aeiou]\", z); // non-vowels\n    printf(\"The input was \\\"%s\\\"\\n\", z);\n    return 0;\n}\n</code></pre> <p>Input: <code>String</code> \u2192 stops at vowel <code>i</code>, outputs <code>Str</code>.</p>"},{"location":"wk_two/#using-field-widths","title":"Using Field Widths","text":"<p>A field width can be applied in a <code>scanf</code> conversion specifier to control how many characters are read from the input stream.</p> <ul> <li>Input is read as groups of digits/characters of the specified width.</li> <li>Useful when parsing fixed-length data such as IDs, phone numbers, or formatted strings.</li> </ul> <p>Example: <code>%2d</code> reads exactly 2 digits into one variable, then <code>%d</code> reads the rest.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    int x = 0;\n    int y = 0;\n\n    printf(\"%s\", \"Enter a six digit integer: \");\n    scanf(\"%2d%d\", &amp;x, &amp;y); // first 2 digits go to x, remaining go to y\n\n    printf(\"The integers input were %d and %d\\n\", x, y);\n    return 0;\n}\n</code></pre> <p>Input: <code>123456</code> \u2192 output: <code>12</code> and <code>3456</code>.</p>"},{"location":"wk_two/#skipping-characters-in-an-input-stream","title":"Skipping Characters in an Input Stream","text":"<p><code>scanf</code> can skip unnecessary characters in the input stream:</p> <ul> <li>Whitespace characters (space, tab, newline) are skipped automatically at the beginning of most format specifiers.</li> <li>Literal characters in the format string (like <code>-</code> or <code>/</code>) must match in the input and are discarded.</li> </ul> <p>Example:</p> <pre><code>scanf(\"%d-%d-%d\", &amp;month, &amp;day, &amp;year);\n</code></pre> <p>Input: <code>11-10-1999</code> \u2192 assigns 11, 10, 1999 while skipping the dashes.</p>"},{"location":"wk_two/#assignment-suppression-character","title":"Assignment Suppression Character","text":"<p>The <code>*</code> assignment suppression character allows <code>scanf</code> to read and discard input without storing it in a variable.</p> <p>Example: <code>%*c</code> reads and discards a single character.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    int month = 0;\n    int day = 0;\n    int year = 0;\n\n    printf(\"%s\", \"Enter a date in the form mm-dd-yyyy: \");\n    scanf(\"%d%*c%d%*c%d\", &amp;month, &amp;day, &amp;year); // ignores separators\n    printf(\"month = %d day = %d year = %d\\n\", month, day, year);\n\n    printf(\"%s\", \"Enter a date in the form mm/dd/yyyy: \");\n    scanf(\"%d%*c%d%*c%d\", &amp;month, &amp;day, &amp;year); // works with /\n    printf(\"month = %d day = %d year = %d\\n\", month, day, year);\n    return 0;\n}\n</code></pre> <p>Input: <code>07-04-2021</code> \u2192 output: <code>7 4 2021</code> Input: <code>01/01/2021</code> \u2192 output: <code>1 1 2021</code></p>"},{"location":"wk_two/#recursion","title":"Recursion","text":"<p>A recursive function is one that calls itself, either directly or indirectly through another function. Recursion is a common but complex topic; here we look at its basic structure.</p>"},{"location":"wk_two/#base-cases-and-recursive-calls","title":"Base Cases and Recursive Calls","text":"<p>A recursive function solves problems by dividing them into:</p> <ul> <li>A base case \u2013 the simplest case the function knows how to solve directly.</li> <li>A recursive case \u2013 a more complex problem broken down into smaller versions of itself.</li> </ul> <p>The recursive case must resemble the original problem but be simpler or smaller, ensuring progress toward the base case. Each recursive call works on the reduced problem until the base case is reached.</p>"},{"location":"wk_two/#recursive-step","title":"Recursive Step","text":"<p>When a recursive call is made:</p> <ul> <li>The function pauses its current execution and launches a fresh copy of itself to handle the smaller problem.</li> <li>This process can repeat many times, generating multiple recursive calls.</li> <li>Each call must eventually converge on the base case, where recursion stops.</li> </ul>"},{"location":"wk_two/#returning-results","title":"Returning Results","text":"<p>Each recursive call includes a <code>return</code> statement. When the base case is reached, the result is returned back to the previous call. This chain of returns continues until the result reaches the original caller.</p> <p>In summary:</p> <ul> <li>Base case: directly solvable, no further recursion.</li> <li>Recursive step: reduces the problem and calls the function again.</li> <li>Convergence: repeated recursion eventually reaches the base case, then unwinds with results.</li> </ul>"},{"location":"wk_two/#example-factorial","title":"Example: Factorial","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint factorial(int n) {\n    if (n == 0) {           // base case\n        return 1;\n    } else {\n        return n * factorial(n - 1); // recursive case\n    }\n}\n\nint main(void) {\n    int num = 5;\n    printf(\"Factorial of %d is %d\\n\", num, factorial(num));\n    return 0;\n}\n</code></pre> <p>Input: <code>5</code> \u2192 Output: <code>120</code></p>"},{"location":"wk_two/#stack-visualization","title":"Stack Visualization","text":"<p>Recursive calls can be visualized as a stack. Each new call is pushed onto the stack showing the pending computation, and results are popped once the base case is reached.</p> <p>Factorial(5)</p> <p>Push (calls): Factorial(5) -&gt; 5 _ Factorial(4) Factorial(4) -&gt; 4 _ Factorial(3) Factorial(3) -&gt; 3 _ Factorial(2) Factorial(2) -&gt; 2 _ Factorial(1) Factorial(1) -&gt; 1 * Factorial(0) Factorial(0) -&gt; 1 (base case)</p> <pre><code>&lt;strong&gt;Pop (returns):&lt;/strong&gt;&lt;br&gt;\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=\"color:#4dd0e1;\"&gt;Factorial(1)&lt;/span&gt; = 1 * &lt;span style=\"color:#42a5f5;\"&gt;Factorial(0)&lt;/span&gt; = 1 * 1 = 1&lt;br&gt;\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=\"color:#81c784;\"&gt;Factorial(2)&lt;/span&gt; = 2 * &lt;span style=\"color:#4dd0e1;\"&gt;Factorial(1)&lt;/span&gt; = 2 * 1 = 2&lt;br&gt;\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=\"color:#aed581;\"&gt;Factorial(3)&lt;/span&gt; = 3 * &lt;span style=\"color:#81c784;\"&gt;Factorial(2)&lt;/span&gt; = 3 * 2 = 6&lt;br&gt;\n&amp;nbsp;&amp;nbsp;&lt;span style=\"color:#ffca28;\"&gt;Factorial(4)&lt;/span&gt; = 4 * &lt;span style=\"color:#aed581;\"&gt;Factorial(3)&lt;/span&gt; = 4 * 6 = 24&lt;br&gt;\n&lt;span style=\"color:#ffa726;\"&gt;Factorial(5)&lt;/span&gt; = 5 * &lt;span style=\"color:#ffca28;\"&gt;Factorial(4)&lt;/span&gt; = 5 * 24 = 120\n</code></pre>"}]}