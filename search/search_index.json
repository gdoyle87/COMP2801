{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"COMP2801 - Application Development with C","text":""},{"location":"#overview","title":"Overview","text":"<p>For full course information bcit.ca. Course taken in Fall 2025 term (outline) with Bob Langelaan.</p> <ul> <li>Midterm and Final in-person</li> <li>4 quizzes, one each in weeks 3, 5, 8, and 11<ul> <li>right at the start of class</li> </ul> </li> <li>8 labs<ul> <li>must be submitted to get a mark for labs</li> </ul> </li> <li>There will be 4 assignments</li> </ul> <p>The course continues from COMP2701 and just follows C How to Program -- Ninth Edition.</p>"},{"location":"midterm/","title":"Midterm Study Notes","text":""},{"location":"midterm/#streams","title":"Streams","text":"<p>Streams are sequences of bytes used for input and output.</p> <ul> <li>Input: Data flows from a device (keyboard, disk, network, etc.) into main memory.</li> <li>Output: Data flows from main memory to a device (screen, printer, disk, network, etc.).</li> </ul> <p>At program start, three standard streams are available (which can be redirected to other devices or files):</p> <ol> <li>Standard input (<code>stdin</code>) \u2013 usually from the keyboard.</li> <li>Standard output (<code>stdout</code>) \u2013 usually to the screen.</li> <li>Standard error (<code>stderr</code>) \u2013 also to the screen, for error messages.</li> </ol>"},{"location":"midterm/#printf","title":"printf","text":""},{"location":"midterm/#conversion-specifiers","title":"Conversion Specifiers","text":"<p><code>printf</code> uses conversion specifiers to determine how data is formatted when printed. Each specifier begins with <code>%</code> followed by one or more characters describing type and formatting.</p> Specifier Description Example Output Integers <code>%d</code>, <code>%i</code> Signed decimal integer <code>printf(\"%d\", 42)</code> \u2192 <code>42</code> <code>%u</code> Unsigned decimal integer <code>printf(\"%u\", 42)</code> \u2192 <code>42</code> <code>%o</code> Unsigned octal integer <code>printf(\"%o\", 10)</code> \u2192 <code>12</code> <code>%x</code>, <code>%X</code> Unsigned hexadecimal integer (<code>a\u2013f</code> or <code>A\u2013F</code>) <code>printf(\"%x\", 255)</code> \u2192 <code>ff</code> Floating-point <code>%f</code>* Floating-point decimal (fixed) <code>printf(\"%f\", 3.1416)</code> \u2192 <code>3.141600</code> <code>%e</code>, <code>%E</code>* Floating-point in scientific notation <code>printf(\"%e\", 1234.56)</code> \u2192 <code>1.234560e+03</code> <code>%g</code>, <code>%G</code>** Floating-point (shortest of <code>%f</code> or <code>%e</code>) <code>printf(\"%g\", 0.0000123)</code> \u2192 <code>1.23e-05</code> * default 6 digits of precision after decimal ** 6 significant digits (including before decimal) Characters &amp; Strings <code>%c</code> Single character <code>printf(\"%c\", 'A')</code> \u2192 <code>A</code> <code>%s</code> String of characters <code>printf(\"%s\", \"Hello\")</code> \u2192 <code>Hello</code> Miscellaneous <code>%p</code> Pointer displayed in an implementation defined manner <code>printf(\"%p\", ptr)</code> \u2192 <code>0x7ffeefbff5ac</code> <code>%%</code> Prints a literal percent sign <code>printf(\"%%\")</code> \u2192 <code>%</code>"},{"location":"midterm/#when-to-use-g","title":"When to Use <code>%g</code>","text":"<p>The <code>%g</code> (or <code>%G</code>) specifier automatically chooses between fixed-point (<code>%f</code>) and scientific (<code>%e</code>) notation depending on the value\u2019s magnitude and precision:</p> <ul> <li>If the exponent is less than -4 or greater than or equal to the precision, <code>%e</code> format is used.</li> <li>Otherwise, <code>%f</code> format is used.</li> <li>Trailing zeros are removed, and no unnecessary decimal point is shown.</li> </ul> <pre><code>printf(\"%g\", 0.0000123); // \u2192 1.23e-05\nprintf(\"%g\", 123.456);   // \u2192 123.456\nprintf(\"%g\", 100.0);     // \u2192 100\n</code></pre> <p>Use <code>%g</code> when you want concise output without manually deciding between scientific and decimal notation.</p>"},{"location":"midterm/#field-widths","title":"Field Widths","text":"<p>A field width specifies the minimum number of characters to print. If the value is shorter, it is left-padded with spaces by default.</p> <pre><code>printf(\"%5d\", 12);         // \"   12\" (left-padded with 3 spaces)\nprintf(\"%5d\\n\", 123456);   // \"123456\" (wider than specifier, prints fully)\nprintf(\"%-5d\", 12);        // \"12   \" (right-padded with 3 spaces)\n</code></pre> <p>Field widths can also apply to floating-point values:</p> <pre><code>printf(\"%8.2f\", 3.14); // \"    3.14\"\n</code></pre> <ul> <li>The number before the decimal controls total width.</li> <li>The number after the decimal controls precision.</li> </ul>"},{"location":"midterm/#flags","title":"Flags","text":"<p>Flags modify alignment, padding, and sign display in formatted output.</p> Flag Meaning Example <code>-</code> Left-justify within the field <code>printf(\"%-5d\", 42)</code> \u2192 <code>42</code> <code>+</code> Always print a sign (<code>+</code> or <code>-</code>) <code>printf(\"%+d\", 42)</code> \u2192 <code>+42</code> space Prefix positive numbers with a space <code>printf(\"% d\", 42)</code> \u2192 <code>42</code> <code>0</code> Pad numeric output with leading zeros <code>printf(\"%05d\", 42)</code> \u2192 <code>00042</code> <code>#</code> Force alternate form (e.g., add <code>0x</code> for hex, decimal point for floats) <code>printf(\"%#x\", 255)</code> \u2192 <code>0xff</code>"},{"location":"midterm/#scanf","title":"scanf","text":""},{"location":"midterm/#conversion-specifiers_1","title":"Conversion Specifiers","text":"Specifier Description Integers <code>%d</code> Reads a signed decimal integer <code>int*</code> <code>%i</code> Reads signed decimal, octal, or hexadecimal <code>int*</code> <code>%o</code> Reads an octal integer <code>unsigned int*</code> <code>%u</code> Reads an unsigned decimal integer <code>unsigned int*</code> <code>%x</code> / <code>%X</code> Reads a hexadecimal integer <code>unsigned int*</code> <code>h</code>, <code>l</code>, <code>ll</code> Length modifiers (<code>short</code>, <code>long</code>, <code>long long</code>) for integers Floating-point <code>%e</code>, <code>%E</code>, <code>%f</code>, <code>%F</code>, <code>%g</code>, <code>%G</code> Reads a floating-point value <code>float*</code> / <code>double*</code> <code>l</code> or <code>L</code> Length modifiers for <code>double</code> or <code>long double</code> Characters &amp; Strings <code>%c</code> Reads a single character <code>char*</code> (no <code>\\0</code> added) <code>%s</code> Reads a string <code>char[]</code> (terminates with <code>\\0</code>) Scan set <code>%[...]</code> Reads a set of characters into a string Miscellaneous <code>%p</code> Reads an address (pointer format) <code>%n</code> Stores number of characters read so far <code>int*</code> <code>%%</code> Skips a literal <code>%</code> in input"},{"location":"midterm/#scan-sets-and-inverted-scan-sets","title":"Scan Sets and Inverted Scan Sets","text":"<p>Scan sets allow <code>scanf</code> to read a group of characters that match a specified set. They are defined using <code>%[ ... ]</code>.</p> <ul> <li><code>%[characters]</code> \u2192 reads only the characters listed.</li> <li><code>%[^characters]</code> \u2192 reads everything except the characters listed.</li> <li>Useful for reading structured data such as comma- or space-separated values.</li> </ul> <pre><code>char word[20];\nscanf(\"%19[A-Za-z]\", word);   // reads only letters\n\nchar untilComma[30];\nscanf(\"%29[^,]\", untilComma);  // reads everything up to the next comma\n</code></pre> <p>Notes:</p> <ul> <li><code>scanf</code> automatically adds a null terminator (<code>'\\0'</code>) at the end.</li> <li>To include <code>]</code> in the scanset, place it first inside the brackets: <code>%[]A-Z]</code>.</li> <li>To include <code>-</code>, place it at the start or end of the set: <code>%[-A-Z]</code>.</li> </ul>"},{"location":"midterm/#field-widths_1","title":"Field Widths","text":"<p>Field widths define how many characters <code>scanf</code> will read for a given conversion. This prevents buffer overflows and controls input precision.</p> <pre><code>char name[11];\nscanf(\"%10s\", name);   // reads at most 10 chars, leaves space for null terminator\n</code></pre> <pre><code>int year, month, day;\nscanf(\"%4d%2d%2d\", &amp;year, &amp;month, &amp;day);\n// Input: 20251028 \u2192 year=2025, month=10, day=28\n</code></pre>"},{"location":"midterm/#skipping-characters-and-assignment-suppression","title":"Skipping Characters and Assignment Suppression","text":"<p>The assignment suppression character (<code>*</code>) allows <code>scanf</code> to skip matched input without storing it.</p> <ul> <li>Any literal in the format string must appear in the input and will be consumed.</li> <li>Whitespace in the format matches any amount of whitespace in the input.</li> </ul> <pre><code>// Skip a single character (like '-') between numbers\nint year, month, day;\nscanf(\"%d%*c%d%*c%d\", &amp;year, &amp;month, &amp;day);\n\n// Skip entire field before comma\nchar name[20];\nscanf(\"%*[^,],%19s\", name);\n</code></pre>"},{"location":"midterm/#formatted-io-variants","title":"Formatted I/O Variants","text":"Function Purpose Typical Use Case <code>fprintf(FILE *fp, const char *format, ...)</code> Prints formatted output to a file stream. Writing data to files. <code>fscanf(FILE *fp, const char *format, ...)</code> Reads formatted input from a file stream. Reading structured file input. <code>sprintf(char *str, const char *format, ...)</code> Writes formatted output into a string buffer. Building formatted strings in memory. <code>sscanf(const char *str, const char *format, ...)</code> Reads formatted input from a string. Parsing string data (e.g., CSV fields). <p>Formatted I/O Variant Use</p> <p>These functions behave like <code>printf</code> and <code>scanf</code>, but redirect input/output to files or strings instead of the console.</p>"},{"location":"midterm/#literals-and-escape-sequences","title":"Literals and Escape Sequences","text":"<p>Characters in a format string that are not part of a conversion specification are printed literally.</p> <p>Escape sequences allow you to include special characters in strings that cannot be typed directly or would otherwise be ambiguous.</p> Escape Description <code>\\'</code> Single quote (<code>'</code>) <code>\\\"</code> Double quote (<code>\"</code>) <code>\\?</code> Question mark (<code>?</code>) <code>\\\\</code> Backslash (<code>\\\\</code>) <code>\\a</code> Alert (bell/flash) <code>\\b</code> Backspace <code>\\f</code> Form feed (new page) <code>\\n</code> Newline <code>\\r</code> Carriage return (does not move to beginning of next line) <code>\\t</code> Horizontal tab <code>\\v</code> Vertical tab <code>%%</code> Percent symbol (<code>%</code>)"},{"location":"midterm/#recursion","title":"Recursion","text":"<p>Recursion occurs when a function calls itself directly or indirectly. Each call creates a new stack frame until a base case is reached, after which calls resolve in reverse order.</p> <ul> <li>Base Case: The simplest form of the problem that can be solved directly.</li> <li>Recursive Case: Reduces the problem toward the base case.</li> <li>Recursion always requires progress toward termination to prevent infinite loops.</li> </ul> <pre><code>int factorial(int n)\n{\n    if (n == 0)  // base case\n        return 1;\n    else          // recursive case\n        return n * factorial(n - 1);\n}\n</code></pre> <ul> <li>For <code>factorial(3)</code> \u2192 calls unfold as <code>3 * factorial(2)</code> \u2192 <code>2 * factorial(1)</code> \u2192 <code>1 * factorial(0)</code>.</li> <li>Base case returns 1, then each call multiplies by the previous <code>n</code> until the result is complete.</li> </ul>"},{"location":"midterm/#structures","title":"Structures","text":"<p>A structure groups related variables under one name. The C standard calls them aggregates. Defined using the <code>struct</code> keyword:</p> <pre><code>struct card {\n    const char *face;\n    const char *suit;\n};\n</code></pre> <p>Semicolon is required after the closing brace. Members can be of different types, but a structure cannot directly contain an instance of itself\u2014only a pointer to its own type.</p> <pre><code>struct card {\n    const char *face;\n    const char *suit;\n    struct card *nextCard;  // Valid\n};\n</code></pre>"},{"location":"midterm/#defining-variables-of-structure-types","title":"Defining Variables of Structure Types","text":"<p>Defining a structure creates a type, not a variable. Variables are declared afterward:</p> <pre><code>struct card myCard;\nstruct card deck[52];\nstruct card *cardPtr;\n</code></pre> <p>You can also define variables inline with the structure:</p> <pre><code>struct card {\n    const char *face;\n    const char *suit;\n} myCard, deck[52], *cardPtr;\n</code></pre>"},{"location":"midterm/#initializing-structures","title":"Initializing Structures","text":"<pre><code>// array-like member initializer lists\nstruct card K = {\"king\", \"clubs\"};\n\n// assigning values to individual data members\nstruct card Q;\nQ.face = \"queen\";\nQ.suit = \"spades\";\n\n// assignment statements (setting one variable to equal another of the same struct)\nstruct card A = {\"Ace\", \"Hearts\"};\nstruct card B;\n\nB = A;   // assignment statement\n</code></pre>"},{"location":"midterm/#accessing-members-of-a-structure","title":"Accessing Members of a Structure","text":"<p>You can access members of a structure using the structure member operator: <code>.</code></p> <pre><code>struct card K = {\"king\", \"clubs\"};`\nchar *Kface = K.face;\n</code></pre> <p>If you are referring to the structure through a pointer, you can use the structure arrow operator to access the members.</p> <pre><code>struct card *KPtr = &amp;K;\nchar *Kface = K-&gt;face;\n\n// Alternatively you can also use the following dereference and dot syntax\nchar *Ksuit = (*KPtr).suit; // note the paranthesis are *required* here.\n</code></pre>"},{"location":"midterm/#structures-without-tag-names","title":"Structures Without Tag Names","text":"<p>Anonymous structs can be declared if variables are defined immediately:</p> <pre><code>struct {\n    int x;\n    int y;\n} point1, point2;\n</code></pre> <p>Without a tag, you can\u2019t reuse the type elsewhere.</p>"},{"location":"midterm/#comparing-structure-objects","title":"Comparing Structure Objects","text":"<p>Structures cannot be compared with <code>==</code> or <code>!=</code> because compilers insert padding bytes for memory alignment, which may hold unspecified garbage values.</p> <p>Even identical structures might differ in padding, making bytewise comparison undefined behaviour.</p> <p>With that said, they could sometimes compare equally (although as noted it is undefined behaviour and can't be relied on).</p>"},{"location":"midterm/#using-sizeof-with-structures","title":"Using <code>sizeof</code> with Structures","text":"<p><code>sizeof(struct_name)</code> gives the memory occupied by a structure, including padding.</p> <pre><code>struct example {\n    char c;\n    int i;\n};\n\nprintf(\"%zu\\n\", sizeof(struct example)); // Likely prints 8, not 5\n</code></pre>"},{"location":"midterm/#passing-structures-and-arrays","title":"Passing Structures and Arrays","text":"<p>Array of structures: passed by reference (actually decays to a pointer), just like any other array.</p> <ul> <li>The function can modify the original elements.</li> </ul> <p>Array member inside a structure: passed by value when the structure itself is passed by value.</p> <ul> <li>The function receives a copy; modifying it won\u2019t affect the original.</li> </ul>"},{"location":"midterm/#typedef","title":"typedef","text":"<p><code>typedef</code> creates an alias for a type, making code more concise and readable.</p> <pre><code>typedef struct card Card;\nCard newCard;\n</code></pre>"},{"location":"midterm/#combining-typedef-with-struct","title":"Combining <code>typedef</code> with <code>struct</code>","text":"<p>You can combine both in one declaration:</p> <pre><code>typedef struct {\n    const char *face;\n    const char *suit;\n} Card;\n</code></pre> <p>Warning</p> <p>Do not declare variables in the same line when using this form. If you need variables too, use a standard <code>struct</code> definition followed by a separate <code>typedef</code>.</p>"},{"location":"midterm/#unions","title":"Unions","text":"<p>A union is a derived data type similar to a <code>struct</code>, but unlike structures, all members share the same memory space. Only one member can be used at a time, making unions memory-efficient when variables are only relevant at different times during execution.</p> <pre><code>union number {\n    int x;\n    double y;\n};\n</code></pre> <p>Defining a union creates a new type but does not allocate memory until a variable is declared.</p> <ul> <li>The size of a union equals the size of its largest member.</li> <li>Accessing a member different from the one last assigned leads to undefined behavior.</li> <li>Unions save space but require careful type management.</li> </ul>"},{"location":"midterm/#initializing-a-union","title":"Initializing a Union","text":"<p>A union can be initialized only through its first member:</p> <pre><code>union number value = {10}; // assigns 10 to x\n</code></pre> <p>Warning</p> <p>If initialized with a value meant for another member, it will be converted to the first member\u2019s type:</p> <pre><code>union number value = {1.43}; // assigns 1 to x instead of 1.43 to y\n</code></pre>"},{"location":"midterm/#bitwise-operators","title":"Bitwise Operators","text":"<p>Bitwise operations work directly on the binary representation of integer types such as short, int, and long (and their unsigned variants). Each bit in a value represents a power of two.</p> <p>Operators</p> <ul> <li> <p>AND <code>&amp;</code>     Sets a bit to 1 only if both bits are 1.</p> <pre><code>// 1101 (13)\n// 1011 (11)\n// ----\n// 1001 (9)\n</code></pre> </li> <li> <p>OR <code>|</code>     Sets a bit to 1 if either bit is 1.</p> <pre><code>// 1101 (13)\n// 1011 (11)\n// ----\n// 1111 (15)\n</code></pre> </li> <li> <p>XOR <code>^</code>     Sets a bit to 1 if bits differ.</p> <pre><code>// 1101 (13)\n// 1011 (11)\n// ----\n// 0110 (6)\n</code></pre> </li> <li> <p>NOT <code>~</code>     Inverts each bit.</p> <p><pre><code>// 0101 (5)\n// ~\n// ----\n// 1010 (10)\n</code></pre> shown as 4 bits</p> </li> <li> <p>Left shift <code>&lt;&lt;</code>     Moves bits left (fills with 0).</p> <p><pre><code>// 0101 (5)\n// &lt;&lt; 1\n// ----\n// 1010 (10)\n</code></pre> Each shift multiplies by 2.</p> </li> <li> <p>Right shift <code>&gt;&gt;</code>     Moves bits right (fills with 0).</p> <p><pre><code>// 1010 (10)\n// &gt;&gt; 1\n// ----\n//0101 (5)\n</code></pre> Each shift divides by 2.</p> </li> </ul> <p>Note on shifts: Right-shift of signed negative values is implementation-defined; use <code>unsigned</code> integers where possible.</p> Common bit manipulation patterns <p>Even/odd: <code>x &amp; 1</code> <pre><code>if (x &amp; 1) puts(\"Odd\"); else puts(\"Even\");\n</code></pre> Swap without temp (XOR-swap): <pre><code>a ^= b; b ^= a; a ^= b;\n</code></pre> Power of two (exactly one bit set): <pre><code>if (x &gt; 0 &amp;&amp; (x &amp; (x - 1)) == 0) puts(\"Power of 2\");\n</code></pre> Count set bits (Kernighan): <pre><code>int c = 0; for (; x; ++c) x &amp;= (x - 1);\n</code></pre> Set / clear / toggle bit n: <pre><code>x |=  (1u &lt;&lt; n);   // set\nx &amp;= ~(1u &lt;&lt; n);   // clear\nx ^=  (1u &lt;&lt; n);   // toggle\n</code></pre> Lowest set bit: <pre><code>unsigned lowest = x &amp; -x;\n</code></pre> Opposite signs: <pre><code>if ((x ^ y) &lt; 0) puts(\"Opposite signs\");\n</code></pre></p>"},{"location":"midterm/#enums","title":"Enums","text":"<p>An enumeration is a user-defined type consisting of a set of named integer constants. Identifiers must be unique, but they can share the same constant value.</p> <pre><code>enum Day { MON, TUE, WED, THU, FRI, SAT, SUN }; // identifiers (MON\u2013SUN) map to constants 0\u20136\nenum Day today = WED; // WED corresponds to 2\n\n// You can also specify constant values in the definition\nenum SomeDays { MON = 1, TUE = 3, WED = 1 }; // WED shares the same value as MON\n\n// You **cannot** assign to enum constants after definition\nWED = 4;  // &lt;- ERROR: enumeration constants are read-only (compile-time error)\n</code></pre>"},{"location":"midterm/#self-referential-structures","title":"Self-Referential Structures","text":"<ul> <li>Structures can include pointers to their own type, enabling dynamic data structures.</li> </ul> <pre><code>struct node { int data; struct node *nextPtr; };\n</code></pre> <ul> <li>Used for linked lists, stacks, and trees.</li> </ul>"},{"location":"midterm/#linked-lists","title":"Linked Lists","text":"<p>Linear collection of nodes connected by pointers.</p> <ul> <li>Each node contains data and a pointer to the next node.</li> <li>The head pointer references the first node; the last node\u2019s pointer is <code>NULL</code>.</li> </ul> <p></p> <p>Traversals</p> <p>Move through nodes one by one until <code>NULL</code>:</p> <p>Start at <code>head</code> \u2192 process data \u2192 move to <code>nextPtr</code> \u2192 repeat.</p> <p>Insertions (two cases)</p> <ul> <li> </li> <li> </li> </ul> <p>Deletions (two cases)</p> <ul> <li> </li> <li> </li> </ul>"},{"location":"midterm/#1-unsorted-insertion-at-the-beginning","title":"1. Unsorted Insertion (at the beginning)","text":"<ol> <li>Allocate memory for a new node and create a <code>newPtr</code>.</li> <li>Assign the desired value to its data field.</li> <li>Link the new node to the existing list by setting    <code>newPtr-&gt;nextPtr = head;</code></li> <li>Update the head pointer so it points to the new node:    <code>head = newPtr;</code></li> </ol>"},{"location":"midterm/#2-sorted-insertion-maintaining-order","title":"2. Sorted Insertion (maintaining order)","text":"<ol> <li>Allocate and initialize the new node.</li> <li> <p>Set <code>previousPtr = NULL</code> and <code>currentPtr = head</code>.</p> <ul> <li><code>previousPtr</code> will always lag one node behind <code>currentPtr</code></li> </ul> </li> <li> <p>Traverse/walk the links until you find the spot.</p> <ul> <li><code>previousPtr = currentPtr</code></li> <li><code>currentPtr = currentPtr-&gt;nextPtr</code></li> </ul> </li> <li> <p>If <code>previousPtr == NULL</code>, insert at the start (new head).     Otherwise, insert between <code>previousPtr</code> and <code>currentPtr</code>.</p> <ul> <li><code>previousPtr-&gt;nextPtr = newPtr;</code></li> <li><code>newPtr-&gt;nextPtr = currentPtr;</code></li> </ul> </li> </ol>"},{"location":"midterm/#1-delete-the-first-node","title":"1. Delete the First Node","text":"<ol> <li>Store the current head in a temporary pointer.</li> <li>Move <code>head</code> to <code>head-&gt;nextPtr</code>.</li> <li>Free the temporary node.</li> </ol>"},{"location":"midterm/#2-delete-from-middle-or-end","title":"2. Delete from Middle or End","text":"<ol> <li>Use <code>previousPtr</code> and <code>currentPtr</code> to traverse until the node to delete is found.</li> <li>Update <code>previousPtr-&gt;nextPtr</code> to <code>currentPtr-&gt;nextPtr</code>.</li> <li>Free the deleted node.</li> </ol>"},{"location":"midterm/#utility-operations","title":"Utility Operations","text":"<ul> <li>isEmpty: return <code>head == NULL</code>.</li> <li>printList: traverse and print each node\u2019s data until <code>NULL</code>.</li> </ul>"},{"location":"midterm/#stacks","title":"Stacks","text":"<p>A stack is a linear data structure that follows the Last-In, First-Out (LIFO) principle. The most recently added element is removed first.</p> <ul> <li>Insertion and deletion occur only at the top of the stack.</li> <li>Implemented using linked lists or arrays.</li> <li>The stack pointer (<code>topPtr</code>) tracks the current top node.</li> </ul> Operation Description push() Insert an element at the top. pop() Remove the top element and return its value. isEmpty() Check if the stack is empty. <pre><code>struct stackNode {\n    int data;\n    struct stackNode *nextPtr;\n};\n</code></pre>"},{"location":"midterm/#queues","title":"Queues","text":"<p>A queue is a linear data structure that follows the First-In, First-Out (FIFO) principle. The first element added is the first one removed.</p> <ul> <li>Insertion occurs at the rear; deletion occurs at the front.</li> <li>Implemented using linked lists.</li> <li> <p>Two pointers are used:</p> </li> <li> <p><code>frontPtr</code> \u2192 points to the first node</p> </li> <li><code>rearPtr</code> \u2192 points to the last node</li> </ul> Operation Description enqueue() Add a new element to the rear. dequeue() Remove an element from the front. isEmpty() Check if the queue is empty. <pre><code>struct queueNode {\n    int data;\n    struct queueNode *nextPtr;\n};\n</code></pre>"},{"location":"midterm/#trees","title":"Trees","text":"<p>Non-linear hierarchical data structure consisting of nodes connected by edges.</p> <ul> <li>Each node may have two or more children.</li> </ul>"},{"location":"midterm/#binary-trees","title":"Binary Trees","text":"<p>A type of tree where each node has at most two children (<code>left</code>, <code>right</code>).</p> <ul> <li>The root is the topmost node; leaf nodes have no children.</li> </ul> <p></p>"},{"location":"midterm/#binary-search-tree-bst","title":"Binary Search Tree (BST)","text":"<p>Special binary tree where:</p> <ul> <li>Left subtree value &lt; Root value &lt; Right subtree value.</li> <li>Enables fast searching, insertion, and deletion.</li> </ul>"},{"location":"midterm/#tree-traversals","title":"Tree Traversals","text":"Type Visit Order Common Use Preorder Root \u2192 Left \u2192 Right Copying the tree Inorder Left \u2192 Root \u2192 Right Produces sorted output Postorder Left \u2192 Right \u2192 Root Deletion or cleanup"},{"location":"midterm/#pointer-to-pointer","title":"Pointer-to-Pointer","text":"<p>When a function needs to modify a pointer (such as a tree\u2019s root or a linked list\u2019s head), it must receive the address of that pointer. This allows the function to update the caller\u2019s pointer directly.</p> <pre><code>void insertNode(TreeNodePtr *treePtr, int value)\n{\n    if (*treePtr == NULL) {\n        *treePtr = malloc(sizeof **treePtr);\n        (*treePtr)-&gt;data = value;\n        (*treePtr)-&gt;leftPtr = NULL;\n        (*treePtr)-&gt;rightPtr = NULL;\n    }\n    else if (value &lt; (*treePtr)-&gt;data)\n        insertNode(&amp;((*treePtr)-&gt;leftPtr), value);  // pass address of left child\n    else if (value &gt; (*treePtr)-&gt;data)\n        insertNode(&amp;((*treePtr)-&gt;rightPtr), value); // pass address of right child\n}\n</code></pre> <ul> <li><code>treePtr</code> is a pointer to a pointer (<code>TreeNode **</code>).</li> <li><code>*treePtr</code> gives the actual node pointer (e.g., the root or a child link).</li> <li><code>&amp;((*treePtr)-&gt;leftPtr)</code> passes the address of the child pointer, allowing recursion to modify that link directly.</li> </ul> <p>Use <code>(*ptr)-&gt;member</code> instead of confusing forms like <code>*(*ptr).member</code>. Parentheses ensure the dereference applies to the pointer, not the struct member.</p>"},{"location":"wk_five/","title":"Week 5","text":"<p>This week was an introduction to self-referential structures, linked lists, and trees.</p>"},{"location":"wk_five/#self-referential-structures","title":"Self-Referential Structures","text":"<p>A structure cannot contain a member of its own type directly, because this would require the compiler to know the full size of the structure before its layout is complete. However, a structure can contain a pointer to its own type. This allows structures to reference other structures of the same type.</p> <p>This pattern is called a self-referential structure.</p>"},{"location":"wk_five/#nodes","title":"Nodes","text":"<p>A node is a fundamental building block used in several data structures (including linked lists, stacks, queues, and trees). A node stores its own data and one or more pointers that describe how to reach other nodes.</p> <p>Because these pointers refer to other nodes of the same type, nodes are self-referential.</p> <pre><code>struct node\n{\n    int data;\n    struct node *nextPtr;\n};\n</code></pre>"},{"location":"wk_five/#linked-lists","title":"Linked Lists","text":"<p>A linked list is a linear collection of self-referential nodes connected by pointer links.</p> <p>Unlike an array, a linked list does not require contiguous memory. Each node is allocated separately, and each node stores:</p> <ul> <li>Its data</li> <li>A pointer to the next node in the list (<code>nextPtr</code>)</li> </ul> <p>The list is accessed through a pointer to the first node, commonly called the head. If the list is empty, the head pointer is set to <code>NULL</code>.</p> <pre><code>struct node\n{\n    int data;\n    struct node *nextPtr;\n};\n</code></pre> <p></p> <p>The last node in the list has a <code>nextPtr</code> of <code>NULL</code>, indicating that no further nodes follow.</p>"},{"location":"wk_five/#traversing-a-linked-list","title":"Traversing a Linked List","text":"<p>To process each element, we use a pointer that starts at the head and moves from node to node until <code>NULL</code> is reached.</p> <pre><code>struct node *current = head;\n\nwhile (current != NULL)\n{\n    printf(\"%d \", current-&gt;data);\n    current = current-&gt;nextPtr;\n}\n</code></pre>"},{"location":"wk_five/#arrays-vs-linked-lists","title":"Arrays vs Linked Lists","text":"<p>Both arrays and linked lists store collections of data, but they differ in how memory is managed and how elements are accessed.</p>"},{"location":"wk_five/#when-linked-lists-are-useful","title":"When Linked Lists Are Useful","text":"<ul> <li>A linked list is appropriate when the number of data items is unknown   or changes over time.</li> <li>Linked lists are dynamic: nodes can be added or removed as needed at   runtime.</li> <li>Useful when elements will be frequently inserted or deleted, especially   in the middle of the sequence.</li> </ul>"},{"location":"wk_five/#when-arrays-are-useful","title":"When Arrays Are Useful","text":"<ul> <li>Arrays are fixed-size data structures. The size is determined when the   array is created.</li> <li>Arrays allow direct (constant-time) access to any element because   elements are stored contiguously in memory.</li> <li>Best when the total number of elements is known in advance and fast   indexing is required.</li> </ul>"},{"location":"wk_five/#memory-considerations","title":"Memory Considerations","text":"<ul> <li>Arrays may reserve more space than needed if sized too large.</li> <li>Linked lists only use memory for the nodes currently stored, but each node   requires extra memory for a pointer, and dynamic allocation involves   overhead.</li> </ul>"},{"location":"wk_five/#performance-summary","title":"Performance Summary","text":"Operation / Property Array Linked List Size Fixed at creation Grows and shrinks dynamically Memory Layout Contiguous Distributed (each node separately) Access by Index O(1) direct access O(n) traversal Insert/Delete at Middle Potentially expensive (shift) Efficient with pointer adjustments Extra Memory Required Only for elements Pointer stored in each node"},{"location":"wk_five/#inserting-into-a-linked-list","title":"Inserting into a Linked List","text":"<p>There are two common cases for inserting a new node into a singly linked list:</p> <ol> <li>When the list does not need to maintain sorted order (unsorted insertion)</li> <li>When the list must remain sorted after insertion (sorted insertion)</li> </ol>"},{"location":"wk_five/#1-insertion-in-an-unsorted-list","title":"1. Insertion in an Unsorted List","text":"<p>The simplest approach is to insert the new node at the beginning of the list. This avoids traversal and runs in O(1) time.</p> <p>Steps:</p> <ol> <li>Allocate memory for the new node.</li> <li>Store the data in the new node.</li> <li>Set the new node\u2019s <code>nextPtr</code> to point to the current head.</li> <li>Update the head to point to the new node.</li> </ol> <pre><code>newPtr-&gt;nextPtr = head;\nhead = newPtr;\n</code></pre> Unsorted linked list visual <p> </p>"},{"location":"wk_five/#2-insertion-in-a-sorted-linked-list","title":"2. Insertion in a Sorted Linked List","text":"<p>When the list is sorted, we must find the correct position for the new node so the ordering is preserved.</p> <p>We use two traversal pointers:</p> <ul> <li><code>previousPtr</code> (tracks the node before the insertion point)</li> <li><code>currentPtr</code> (used to walk the list)</li> </ul> <p>Steps:</p> <ol> <li>Allocate memory for the new node. If allocation fails, do not modify the list.</li> <li>Store the new data in the node and set its <code>nextPtr</code> to <code>NULL</code> initially.</li> <li> <p>Initialize traversal pointers:</p> </li> <li> <p><code>previousPtr = NULL</code></p> </li> <li> <p><code>currentPtr = head</code></p> </li> <li> <p>Traverse the list to locate the correct insertion point:</p> </li> <li> <p>While <code>currentPtr != NULL</code> and the new value is greater than      <code>currentPtr-&gt;data</code>:</p> <ul> <li><code>previousPtr = currentPtr</code></li> <li><code>currentPtr = currentPtr-&gt;nextPtr</code></li> </ul> </li> <li> <p>Insert the new node:</p> </li> <li> <p>If <code>previousPtr</code> is <code>NULL</code>, insert at beginning:</p> <pre><code>newPtr-&gt;nextPtr = head;\nhead = newPtr;\n</code></pre> </li> <li> <p>Otherwise, insert between <code>previousPtr</code> and <code>currentPtr</code>:</p> <pre><code>previousPtr-&gt;nextPtr = newPtr;\nnewPtr-&gt;nextPtr = currentPtr;\n</code></pre> </li> </ol> Sorted linked list visual <p> </p>"},{"location":"wk_five/#deleting-a-node-from-a-linked-list","title":"Deleting a Node from a Linked List","text":"<p>Deletion removes a node and reconnects the surrounding nodes so the list remains intact. Two common cases exist: deleting the first node and deleting a node elsewhere in the list.</p>"},{"location":"wk_five/#1-deleting-the-first-node","title":"1. Deleting the First Node","text":"<p>When the first node is removed, the head pointer must be updated to point to the second node.</p> <p>Steps:</p> <ol> <li>Assign a temporary pointer to the current head node.</li> <li>Move the head pointer to the next node.</li> <li>Free the memory of the removed node.</li> </ol> <pre><code>ListNodePtr temp = head;\nhead = head-&gt;nextPtr;\nfree(temp);\n</code></pre> Delete from start (visual) <p> </p>"},{"location":"wk_five/#2-deleting-a-node-elsewhere","title":"2. Deleting a Node Elsewhere","text":"<p>When deleting from the middle or end, traversal pointers are used to find the node preceding the one to remove.</p> <p>Steps:</p> <ol> <li> <p>Traverse the list using two pointers:</p> </li> <li> <p><code>previousPtr</code> tracks the node before the one to delete.</p> </li> <li> <p><code>currentPtr</code> tracks the node being inspected.</p> </li> <li> <p>Stop when <code>currentPtr</code> points to the node to remove.</p> </li> <li>Update <code>previousPtr-&gt;nextPtr</code> to skip over the deleted node.</li> <li>Free the deleted node.</li> </ol> <pre><code>previousPtr-&gt;nextPtr = currentPtr-&gt;nextPtr;\nfree(currentPtr);\n</code></pre> Delete elsewhere (visual) <p> </p> <p>Deleting requires careful pointer management to ensure that the remaining nodes stay properly linked and no memory leaks occur.</p>"},{"location":"wk_five/#checking-if-the-list-is-empty-and-printing-the-list","title":"Checking if the List is Empty and Printing the List","text":"<p>These utility functions help inspect a linked list without modifying it.</p>"},{"location":"wk_five/#checking-if-the-list-is-empty","title":"Checking if the List is Empty","text":"<p>The <code>isEmpty</code> function determines whether a linked list contains any nodes.</p> <pre><code>int isEmpty(ListNodePtr sPtr)\n{\n    return sPtr == NULL;\n}\n</code></pre>"},{"location":"wk_five/#printing-the-list","title":"Printing the List","text":"<p>The <code>printList</code> function traverses the list and displays its contents. If the list is empty, it reports that to the user; otherwise, it prints each node\u2019s data value in sequence.</p> <pre><code>void printList(ListNodePtr currentPtr)\n{\n    if (isEmpty(currentPtr))\n    {\n        puts(\"List is empty.\\n\");\n    }\n    else\n    {\n        puts(\"The list is:\");\n\n        while (currentPtr != NULL)\n        {\n            printf(\"%c --&gt; \", currentPtr-&gt;data);\n            currentPtr = currentPtr-&gt;nextPtr;\n        }\n\n        puts(\"NULL\\n\");\n    }\n}\n</code></pre> <p>This function is often used for debugging or visualizing the list\u2019s current state after insertions or deletions.</p>"},{"location":"wk_five/#trees","title":"Trees","text":"<p>A tree is a nonlinear, two-dimensional data structure made up of nodes. Unlike linear structures such as arrays or linked lists, trees organize data hierarchically.</p> <p>Each node in a tree may contain multiple links to other nodes. In a binary tree, each node contains two links\u2014commonly called the left and right child pointers. Either or both of these links can be <code>NULL</code>.</p> <p></p>"},{"location":"wk_five/#basic-terminology","title":"Basic Terminology","text":"<ul> <li>Root node \u2013 The topmost node in the tree. It serves as the entry point.</li> <li>Child node \u2013 A node referenced by another node.</li> <li>Parent node \u2013 A node that links to one or more children.</li> <li>Left child \u2013 The first node in the left subtree of a parent.</li> <li>Right child \u2013 The first node in the right subtree of a parent.</li> <li>Siblings \u2013 Nodes that share the same parent.</li> <li>Leaf node \u2013 A node with no children (both links are <code>NULL</code>).</li> </ul>"},{"location":"wk_five/#other-notes","title":"Other Notes","text":"<ul> <li>Not setting a leaf node\u2019s links to <code>NULL</code> can lead to runtime errors.</li> <li>A tree may be empty (no root node) or contain a hierarchy of nodes connected   by pointers.</li> <li>In computer science diagrams, trees are typically drawn with the root at the   top, opposite of how trees appear in nature.</li> </ul>"},{"location":"wk_five/#binary-search-tree-bst","title":"Binary Search Tree (BST)","text":"<p>A binary search tree (BST) is a special type of binary tree that stores unique values and maintains a specific ordering property:</p> <ul> <li>All values in the left subtree of a node are less than the value in   the node\u2019s parent.</li> <li>All values in the right subtree are greater than the value in the   node\u2019s parent.</li> </ul> <p>This ordering allows efficient search, insertion, and deletion operations.</p> <p></p> <p>In the example above, the tree has nine values. Notice that:</p> <ul> <li>Every left child is smaller than its parent.</li> <li>Every right child is larger than its parent.</li> <li>The shape of a BST depends on the order of insertion. Inserting the   same numbers in a different order can produce a completely different tree   structure.</li> </ul> <p>This property enables fast lookups\u2014on average O(log n) time\u2014but in the worst case (such as inserting sorted data without balancing) performance can degenerate to O(n).</p>"},{"location":"wk_five/#preorder-traversal-root-left-right","title":"Preorder Traversal (Root \u2192 Left \u2192 Right)","text":"<p>In a preorder traversal, each node is visited before its subtrees:</p> <ol> <li>Visit the root.</li> <li>Traverse the left subtree.</li> <li>Traverse the right subtree.</li> </ol> <p>This means the root is always processed first.</p> Pre-order Traversal Visual <p>  Your browser does not support the video tag.  </p>"},{"location":"wk_five/#inorder-traversal-left-root-right","title":"Inorder Traversal (Left \u2192 Root \u2192 Right)","text":"<p>In an inorder traversal, the order ensures that nodes are visited in sorted order for a binary search tree:</p> <ol> <li>Traverse the left subtree.</li> <li>Visit the root.</li> <li>Traverse the right subtree.</li> </ol> <p>This traversal is often used to output data in ascending order.</p> In-order Traversal Visual <p>  Your browser does not support the video tag.  </p>"},{"location":"wk_five/#postorder-traversal-left-right-root","title":"Postorder Traversal (Left \u2192 Right \u2192 Root)","text":"<p>In a postorder traversal, subtrees are processed before the parent node:</p> <ol> <li>Traverse the left subtree.</li> <li>Traverse the right subtree.</li> <li>Visit the root.</li> </ol> <p>This traversal is useful for deleting or freeing nodes, since children are handled before their parent.</p> Post-order Traversal Visual <p>  Your browser does not support the video tag.  </p>"},{"location":"wk_five/#pointer-to-pointer-parameters-and-the-insertnode-example","title":"Pointer-to-Pointer Parameters and the <code>insertNode</code> Example","text":"<p>The pointer-to-pointer pattern is required when a function must modify a pointer owned by the caller (e.g., the tree\u2019s root or a child link). Passing the address of that pointer lets the function assign to it directly.</p> <pre><code>void insertNode(TreeNodePtr *treePtr, int value)\n{\n    if (*treePtr == NULL) {\n        *treePtr = malloc(sizeof **treePtr);\n        if (*treePtr) {\n            (*treePtr)-&gt;data = value;\n            (*treePtr)-&gt;leftPtr = NULL;\n            (*treePtr)-&gt;rightPtr = NULL;\n        } else {\n            printf(\"%d not inserted. No memory available.\\n\", value);\n        }\n        return;\n    }\n\n    if (value &lt; (*treePtr)-&gt;data) {\n        insertNode(&amp;((*treePtr)-&gt;leftPtr), value);\n    } else if (value &gt; (*treePtr)-&gt;data) {\n        insertNode(&amp;((*treePtr)-&gt;rightPtr), value);\n    } else {\n        printf(\"dup\\n\");\n    }\n}\n</code></pre> <ul> <li><code>treePtr</code> has type <code>TreeNode **</code> (pointer to a <code>TreeNode *</code>).</li> <li><code>*treePtr</code> is the actual <code>TreeNode *</code> (root or a child link).</li> <li><code>(*treePtr)-&gt;member</code> accesses a field of the node that <code>*treePtr</code> points to.</li> </ul>"},{"location":"wk_five/#why-treeptr-leftptr","title":"Why <code>&amp;((*treePtr)-&gt;leftPtr)</code>?","text":"<p>When you recurse left or right, you must pass the address of the child pointer so the callee can update that pointer in place.</p> <ul> <li><code>(*treePtr)-&gt;leftPtr</code> has type <code>TreeNode *</code> (a child link).</li> <li><code>&amp;((*treePtr)-&gt;leftPtr)</code> therefore has type <code>TreeNode **</code> \u2014 exactly what <code>insertNode</code> expects.</li> </ul> <p>This is the critical difference: you are not passing the address of the node; you are passing the address of the pointer that stores the child link.</p> <pre><code>// Types at each step\nTreeNodePtr  left   = (*treePtr)-&gt;leftPtr;   // TreeNode *\nTreeNodePtr *target = &amp;((*treePtr)-&gt;leftPtr); // TreeNode **\ninsertNode(target, value);                   // matches parameter type\n</code></pre> <p>Operator precedence and parentheses</p> <ul> <li><code>-&gt;</code> binds tighter than unary <code>&amp;</code>, so <code>&amp;(*treePtr)-&gt;leftPtr</code> would be parsed the same as <code>&amp;((*treePtr)-&gt;leftPtr)</code>.</li> <li>The extra parentheses are kept for readability and to avoid misreading the expression as <code>&amp;*treePtr</code> (which simplifies to <code>treePtr</code>, not the child field\u2019s address).</li> </ul> <p>Contrast:</p> <ul> <li><code>&amp;*treePtr</code> \u2192 <code>treePtr</code> (type <code>TreeNode **</code>), the address-of followed by dereference cancels out.</li> <li><code>&amp;((*treePtr)-&gt;leftPtr)</code> \u2192 address of the left child pointer field inside the node pointed to by <code>*treePtr</code>.</li> </ul> <p>A helpful way to read it:</p> <ol> <li><code>*treePtr</code> \u2192 the current node pointer.</li> <li><code>(*treePtr)-&gt;leftPtr</code> \u2192 the left child pointer stored in that node.</li> <li><code>&amp;((*treePtr)-&gt;leftPtr)</code> \u2192 the address of that child pointer (so we can assign to it inside the callee).</li> </ol>"},{"location":"wk_four/","title":"Week 4","text":"<p>This week continued Chapter 10 and covered unions and bit manipulations. </p>"},{"location":"wk_four/#unions","title":"Unions","text":"<p>Like a <code>struct</code>, a <code>union</code> is a derived data type. The difference is that all members of a union occupy the same memory space.</p> <p>This is helpful when different variables are only relevant at different times during program execution. By combining them in a <code>union</code>, you can save memory rather than allocating space for all members simultaneously.</p> <p>In most cases, a <code>union</code> contains two or more items of different types. You can access only one member (and therefore one type) at a time. It is the programmer\u2019s responsibility to reference the data with the proper type \u2014 using the wrong one results in a logic error.</p> <p>The <code>sizeof</code> a <code>union</code> is always equal to the size of its largest member type.</p>"},{"location":"wk_four/#declaring-a-union","title":"Declaring a <code>union</code>","text":"<p>The declaration of a <code>union</code> is very similar to that of a <code>struct</code>:</p> <pre><code>union number { \n    int x; \n    double y; \n};\n</code></pre> <p>As with a <code>struct</code>, defining a <code>union</code> only creates a new type; it does not reserve memory until you declare variables of that type.</p> <p>Tip</p> <p>Union definitions are often placed in header files so they can be reused across multiple source files that require access to the same type definition.</p>"},{"location":"wk_four/#initializing-union-during-declaration","title":"Initializing <code>union</code> During Declaration","text":"<p>You can initialize a variable of a union type during its declaration by assigning a value to the first member type listed in the definition.</p> <pre><code>// 'number' contains the following members in order: int x, double y\nunion number value = {10}; // assigns 10 to x\n</code></pre> <p>Warning</p> <p>If you provide a value intended for a different member during initialization, it will be converted to the first member type instead.</p> <pre><code>// 'number' contains the following members in order: int x, double y\nunion number value = {1.43}; // assigns 1 to x instead of assigning 1.43 to y\n</code></pre>"},{"location":"wk_four/#beyond-the-textbook-tagged-unions","title":"Beyond the Textbook: Tagged Unions","text":"<p>Note</p> <p>The following material was not covered in class (nor in this section of  the text as far as I can tell) and is provided here for informational purposes only.</p> <p>While traditional unions allow multiple types to share the same memory space, they provide no way to track which member is currently active. This makes them error-prone for most applications.</p> <p>A safer and more common modern pattern is the tagged union (also called a discriminated union). A tagged union adds an explicit field, or tag, to record which member of the union is currently valid.</p> <p>This trades a bit of extra overhead for greater safety.</p> <pre><code>enum ValueType { TYPE_INT, TYPE_DOUBLE };\n\nstruct Value {\n    enum ValueType type;   // the tag\n    union {\n        int i;\n        double d;\n    } data;\n};\n</code></pre> <p>This design lets programs safely determine which member to use:</p> <pre><code>struct Value v;\nv.type = TYPE_DOUBLE;\nv.data.d = 3.14;\n\nif (v.type == TYPE_DOUBLE) {\n    printf(\"%f\\n\", v.data.d);\n}\n</code></pre> <p>Info</p> <p>Tagged unions are common in modern C for representing values that may take multiple forms, such as tokens in a compiler or event types in an input system. They are safer and clearer than plain unions while still using shared memory efficiently.</p>"},{"location":"wk_four/#bitwise-operators","title":"Bitwise Operators","text":"<p>Computers represent all data internally as sequences of bits (0s and 1s). Each bit can store one of two values, and groups of bits are used to represent larger quantities. On most systems, eight bits form one byte \u2014 the typical storage unit for a <code>char</code>.</p> <p>Bitwise operators allow direct manipulation of individual bits within integer values. These operations work on the binary representations of the operands and are frequently used for low-level programming, such as hardware control, encoding, and flag management.</p> <p>Note</p> <p>Bitwise operations are typically applied to unsigned integers to avoid ambiguity when dealing with sign bits and system-dependent right-shift behavior.</p>"},{"location":"wk_four/#bitwise-and","title":"Bitwise AND (<code>&amp;</code>)","text":"<p>Sets each bit in the result to 1 only if the corresponding bits in both operands are 1.</p> <pre><code>// 4-bit examples\n//    1101  (13)\n//  &amp; 1011  (11)\n//  --------\n//    1001  (9)\n</code></pre>"},{"location":"wk_four/#bitwise-or","title":"Bitwise OR (<code>|</code>)","text":"<p>Sets each bit in the result to 1 if at least one of the corresponding bits in either operand is 1.</p> <pre><code>//    1101  (13)\n//  | 1011  (11)\n//  --------\n//    1111  (15)\n</code></pre>"},{"location":"wk_four/#bitwise-xor","title":"Bitwise XOR (<code>^</code>)","text":"<p>Sets each bit in the result to 1 only if the corresponding bits in the operands differ.</p> <pre><code>//    1101  (13)\n//  ^ 1011  (11)\n//  --------\n//    0110  (6)\n</code></pre>"},{"location":"wk_four/#left-shift","title":"Left Shift (<code>&lt;&lt;</code>)","text":"<p>Moves bits to the left, filling with zeros from the right. Each left shift by 1 multiplies the number by 2.</p> <pre><code>//    0101  (5)\n//  &lt;&lt; 1\n//  --------\n//    1010  (10)\n</code></pre>"},{"location":"wk_four/#right-shift","title":"Right Shift (<code>&gt;&gt;</code>)","text":"<p>Moves bits to the right, discarding bits on the right. For unsigned values, zeros are filled in from the left. Each right shift by 1 divides the number by 2 (integer division).</p> <pre><code>//    1010  (10)\n//  &gt;&gt; 1\n//  --------\n//    0101  (5)\n</code></pre>"},{"location":"wk_four/#bitwise-not","title":"Bitwise NOT (<code>~</code>)","text":"<p>Inverts each bit of the operand, turning 0s into 1s and 1s into 0s.</p> <pre><code>//    0101  (5)\n//  ~\n//  --------\n//    1010  (10 if only 4 bits are shown)\n</code></pre> <p>Warning</p> <p>In C, <code>~</code> inverts all bits in the operand, not just the visible ones. For fixed-width integers like <code>uint8_t</code>, this means all 8 bits are inverted. When printed as signed types, this can appear as a negative number.</p>"},{"location":"wk_four/#beyond-the-textbook-common-bit-manipulation-techniques","title":"Beyond the Textbook: Common Bit Manipulation Techniques","text":"<p>Note</p> <p>The following material was not covered in class (nor in this section of  the text) and is provided here for informational purposes only.</p> <p>Bit manipulation techniques are frequently used in competitive programming and technical interviews (such as on LeetCode). These operations allow efficient arithmetic and logical computations without relying on higher-level constructs.</p> <p>Below are several common patterns, each explained with examples using 4-bit binary values for clarity.</p>"},{"location":"wk_four/#1-checking-if-a-number-is-even-or-odd","title":"1. Checking if a Number is Even or Odd","text":"<p>You can check the least significant bit (LSB) of a number using the bitwise AND operator.</p> <pre><code>if (x &amp; 1)\n    printf(\"Odd\");\nelse\n    printf(\"Even\");\n</code></pre> <p>Example:</p> <pre><code>//   0101 (5)\n// &amp; 0001\n// ------\n//   0001 -&gt; Odd\n\n//   0110 (6)\n// &amp; 0001\n// ------\n//   0000 -&gt; Even\n</code></pre>"},{"location":"wk_four/#2-swapping-two-numbers-without-a-temporary-variable","title":"2. Swapping Two Numbers Without a Temporary Variable","text":"<p>This uses XOR to swap values in place.</p> <pre><code>a ^= b;\nb ^= a;\na ^= b;\n</code></pre> <p>Example:</p> <pre><code>// a = 0101 (5)\n// b = 0011 (3)\n// Step 1: a = a ^ b -&gt; 0110\n// Step 2: b = b ^ a -&gt; 0101\n// Step 3: a = a ^ b -&gt; 0011\n// Result: a = 3, b = 5\n</code></pre>"},{"location":"wk_four/#3-checking-if-a-number-is-a-power-of-two","title":"3. Checking if a Number is a Power of Two","text":"<p>A number is a power of two if it has exactly one bit set.</p> <pre><code>if (x &gt; 0 &amp;&amp; (x &amp; (x - 1)) == 0)\n    printf(\"Power of 2\");\n</code></pre> <p>Example:</p> <pre><code>//   x = 0100 (4)\n// x-1 = 0011\n// &amp; operation:\n//   0100\n// &amp; 0011 \n//   ---- \n//   0000 -&gt; true\n</code></pre>"},{"location":"wk_four/#4-counting-set-bits-brian-kernighans-algorithm","title":"4. Counting Set Bits (Brian Kernighan\u2019s Algorithm)","text":"<p>This algorithm repeatedly removes the lowest set bit until the number becomes zero.</p> <pre><code>int count = 0;\nwhile (x) {\n    x &amp;= (x - 1);\n    count++;\n}\n</code></pre> <p>Example:</p> <pre><code>// x = 1101 (13)\n// 1101 -&gt; 1100 -&gt; 1000 -&gt; 0000\n// count = 3\n</code></pre>"},{"location":"wk_four/#5-clearing-or-setting-a-specific-bit","title":"5. Clearing or Setting a Specific Bit","text":"<p>To set a bit, use OR; to clear a bit, use AND with the complement of a mask.</p> <pre><code>// Set nth bit\nx |= (1 &lt;&lt; n);\n\n// Clear nth bit\nx &amp;= ~(1 &lt;&lt; n);\n</code></pre> <p>Example:</p> <pre><code>// x = 0101, n = 1\n// (1 &lt;&lt; 1) = 0010\n// Set:   0101 | 0010 = 0111\n// Clear: 0101 &amp; 1101 = 0101 (no change since that bit is already 0)\n</code></pre>"},{"location":"wk_four/#6-toggling-a-bit","title":"6. Toggling a Bit","text":"<p>Flips the specified bit using XOR.</p> <pre><code>x ^= (1 &lt;&lt; n);\n</code></pre> <p>Example:</p> <pre><code>// x = 0101, n = 2\n// (1 &lt;&lt; 2) = 0100\n//   0101 \n// ^ 0100 \n//   ----\n//   0001\n</code></pre>"},{"location":"wk_four/#7-extracting-the-lowest-set-bit","title":"7. Extracting the Lowest Set Bit","text":"<p>Returns a number with only the lowest set bit of <code>x</code> preserved.</p> <pre><code>int lowest = x &amp; -x;\n</code></pre> <p>Example:</p> <pre><code>// x = 1010\n// -x (two\u2019s complement) = 0110\n//   1010 \n// &amp; 0110 \n//   ----\n//   0010\n</code></pre>"},{"location":"wk_four/#8-checking-if-two-integers-have-opposite-signs","title":"8. Checking if Two Integers Have Opposite Signs","text":"<p>Uses XOR to test the sign bit. The result will be negative if the signs differ.</p> <pre><code>if ((x ^ y) &lt; 0)\n    printf(\"Opposite signs\");\n</code></pre> <p>Example:</p> <pre><code>// x = +5 (0101), y = -3 (in 4-bit two\u2019s complement: 1101)\n// x ^ y = 1000 (negative)\n// -&gt; Opposite signs\n</code></pre>"},{"location":"wk_one/","title":"Week 1","text":"<p>This week covers the first half of Chapter 9 in the text. We look in depth at <code>printf</code> formatting including specifiers, field widths, formatting flags, and escape sequences which all help control how output is displayed.</p>"},{"location":"wk_one/#streams","title":"Streams","text":"<p>Streams are sequences of bytes used for input and output.</p> <ul> <li>Input: Data flows from a device (keyboard, disk, network, etc.) into main memory.</li> <li>Output: Data flows from main memory to a device (screen, printer, disk, network, etc.).</li> </ul> <p>At program start, three standard streams are available:</p> <ol> <li>Standard input (<code>stdin</code>) \u2013 usually from the keyboard.</li> <li>Standard output (<code>stdout</code>) \u2013 usually to the screen.</li> <li>Standard error (<code>stderr</code>) \u2013 also to the screen, for error messages.</li> </ol> <p>Redirection: Operating systems allow these streams to be redirected to other devices or files.</p>"},{"location":"wk_one/#printf-formatting","title":"<code>printf</code> Formatting","text":"<p>As we learned in the previous course, <code>printf</code> can be used to format output to <code>stdout</code> using conversion specifications.</p>"},{"location":"wk_one/#type-specifiers","title":"Type Specifiers","text":""},{"location":"wk_one/#integers","title":"Integers","text":"Specifier Description <code>%d</code> Signed decimal integer <code>%i</code> Signed decimal integer (same as <code>%d</code>) <code>%o</code> Unsigned octal integer <code>%u</code> Unsigned decimal integer <code>%x</code> Unsigned hexadecimal integer (lowercase a\u2013f) <code>%X</code> Unsigned hexadecimal integer (uppercase A\u2013F) <code>%hd</code> / <code>%ld</code> / <code>%lld</code> Short, long, or long long integers (length modifiers) <p>Note: if you are using any of the unsigned specifiers, don't pass it any negative numbers.</p> <p>If you are using any of the long length modifiers you should add a corresponding literal suffix (<code>L</code>, <code>LL</code>) to the value that you pass to <code>printf</code>.</p> <pre><code>printf(\"%ld\\n\", 5000000000L); // long (suffix L required)\nprintf(\"%lld\\n\", 9000000000000LL); // long long (suffix LL required)\n</code></pre>"},{"location":"wk_one/#floating-point-numbers","title":"Floating-Point Numbers","text":"Specifier Description <code>%e</code> / <code>%E</code> Exponential (scientific) notation (e.g., <code>1.23e+02</code> or <code>1.23E+02</code>) <code>%f</code> / <code>%F</code> Fixed-point notation <code>%g</code> / <code>%G</code> Uses either <code>%f</code> or <code>%e</code> (<code>%E</code>) depending on value\u2019s magnitude, with no trailing zeros <code>%Lf</code> / <code>%Le</code> / <code>%Lg</code> Long double (length modifier <code>L</code>) <p>The default precision is 6 digits after the decimal (for <code>%f</code>) or 6 significant digits (for <code>%g</code>/<code>%G</code>).</p> <p>Rounding: <code>%e</code>, <code>%E</code>, and <code>%g</code> perform rounding; <code>%f</code> shows exact decimals.</p> <p><code>%g</code>/<code>%G</code> automatically chooses the shortest visual representation for a given number:</p> <ul> <li>Chooses <code>%e</code> if the exponent is &lt; -4 or \u2265 precision.</li> <li>Otherwise chooses <code>%f</code>.</li> <li>Removes trailing zeros.</li> <li>Omits the decimal point if the fractional part is zero.</li> </ul> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"%g\\n\", 87.0);        // 87\n    // whole number, fractional part is zero so \".0\" is suppressed\n\n    printf(\"%g\\n\", 87.50);       // 87.5\n    // fractional part kept, trailing zero removed\n\n    printf(\"%g\\n\", 87.25);       // 87.25\n    // fractional part kept, no trailing zeros to remove\n\n    printf(\"%g\\n\", 0.0000875);   // 8.75e-05\n    // exponent &lt; -4, so %e format is chosen\n\n    printf(\"%g\\n\", 8750000.0);   // 8.75e+06\n    // exponent \u2265 precision (6), so %e format is chosen\n\n    printf(\"%#g\\n\", 87.0);       // 87.0000\n    // '#' flag forces decimal point and trailing zeros up to precision\n\n    return 0;\n}\n</code></pre>"},{"location":"wk_one/#strings-and-characters","title":"Strings and Characters","text":"<ul> <li><code>%c</code> prints a single <code>char</code></li> <li><code>%s</code> prints a null-terminated string (<code>char*</code>), stops at <code>\\0</code></li> <li>Missing null terminator or wrong format specifier (e.g., <code>%s</code> with a <code>char</code>) undefined behavior, often a crash</li> <li>Compilers usually don\u2019t catch format string errors \u2014 they show up only at runtime.</li> </ul>"},{"location":"wk_one/#pointers","title":"Pointers","text":"Specifier Description <code>%p</code> Displays a pointer (address) in an implementation-defined way (commonly hexadecimal) <p><code>%p</code> expects a pointer argument (e.g., <code>&amp;x</code>, or a <code>char*</code>, <code>int*</code>, etc.). The exact format of the address depends on the system, but is typically hexadecimal. Useful for debugging to confirm memory addresses.</p>"},{"location":"wk_one/#field-width","title":"Field Width","text":"<p>You can control the minimum number of characters used when printing a value by specifying a field width.</p> <p>If the value has fewer characters than the field width then it is padded (by default with spaces).</p> <p>Note: If the value has more characters than the field width then the full value is printed (field width is ignored). That is to say, it does not truncate the output.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"%4d\\n\", 1);       //    1\n    printf(\"%4d\\n\", 12);      //   12\n    printf(\"%4d\\n\", 123);     //  123\n    printf(\"%4d\\n\", 1234);    // 1234\n    printf(\"%4d\\n\", 12345);   // 12345 (too wide, prints fully)\n\n    printf(\"%4d\\n\", -1);      //   -1\n    printf(\"%4d\\n\", -12);     //  -12\n    printf(\"%4d\\n\", -123);    // -123\n    printf(\"%4d\\n\", -1234);   // -1234\n    printf(\"%4d\\n\", -12345);  // -12345\n}\n</code></pre>"},{"location":"wk_one/#negative-values","title":"Negative Values","text":"<p>If the value has a negative sign, it will use up one of the field width characters:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"BEFORE%4dAFTER\\n\", 1);        //BEFORE   1AFTER\n    printf(\"BEFORE%4dAFTER\\n\", -1);       //BEFORE  -1AFTER\n    // In the second example, there are only 2 spaces.\n}\n</code></pre>"},{"location":"wk_one/#dynamic-widths","title":"Dynamic Widths","text":"<p>Instead of providing a number, you can pass <code>*</code> instead and then supply the width as one of the values passed instead.</p> <p>This works for precision as well.</p> <pre><code>printf(\"BEFORE%*.*fAFTER\", 7, 2, 98.736); // BEFORE  98.74AFTER\n// 7 \u2192 total field width (minimum size, includes digits, decimal point, and padding)\n// 2 \u2192 precision (number of digits after the decimal point)\n</code></pre>"},{"location":"wk_one/#format-flags","title":"Format Flags","text":""},{"location":"wk_one/#alignment","title":"Alignment","text":"<p>By default, values are right-aligned in the field. To make them left-aligned, add a <code>-</code> before the field width:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"BEFORE%4dAFTER\\n\", 1);        //BEFORE   1AFTER\n    printf(\"BEFORE%-4dAFTER\\n\", 1);       //BEFORE1   AFTER\n}\n</code></pre>"},{"location":"wk_one/#sign-control-for-numbers","title":"Sign Control (for numbers)","text":"<p>By default, only negative numbers are printed with a sign (<code>-</code>). You can control how positive numbers appear using flags:</p> <ul> <li><code>+</code>: always print a sign (<code>+</code> for positive, <code>-</code> for negative).</li> <li>space (<code>' '</code>): print a space in front of positive numbers (negative numbers still get <code>-</code>).</li> </ul> <p>This can be useful for aligning columns of positive and negative numbers.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"%d\\n\", 42);     // 42\n    printf(\"%+d\\n\", 42);    // +42\n    printf(\"% d\\n\", 42);    //  42 (leading space)\n    printf(\"%d\\n\", -42);    // -42\n    printf(\"%+d\\n\", -42);   // -42\n    printf(\"% d\\n\", -42);   // -42\n}\n</code></pre>"},{"location":"wk_one/#alternate-form-flag","title":"Alternate Form (# Flag)","text":"<p>The <code>#</code> flag modifies how certain values are displayed:</p> <ul> <li>Octal (<code>%o</code>): prefixes the value with <code>0</code>.</li> <li>Hexadecimal (<code>%x</code> / <code>%X</code>): prefixes the value with <code>0x</code> or <code>0X</code>.</li> <li> <p>Floating-point (<code>%f</code>, <code>%e</code>, <code>%E</code>, <code>%g</code>, <code>%G</code>): forces a decimal point to appear, even if the fractional part is zero.</p> </li> <li> <p>For <code>%g</code> / <code>%G</code>, it also prevents trailing zeros from being removed.</p> </li> </ul> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    int c = 1427;\n    double p = 1427.0;\n\n    printf(\"%o\\n\", c);    // 2623\n    printf(\"%#o\\n\", c);   // 02623\n\n    printf(\"%x\\n\", c);    // 593\n    printf(\"%#x\\n\", c);   // 0x593\n\n    printf(\"%X\\n\", c);    // 593\n    printf(\"%#X\\n\", c);   // 0X593\n\n    printf(\"%g\\n\", p);    // 1427\n    printf(\"%#g\\n\", p);   // 1427.00 (decimal point forced, trailing zeros kept)\n}\n</code></pre>"},{"location":"wk_one/#zero-padding-0-flag","title":"Zero Padding (0 Flag)","text":"<p>By default, extra space in a field width is filled with spaces. The <code>0</code> flag changes this so that extra space is filled with leading zeros.</p> <ul> <li>Works with integers and floating-point numbers.</li> <li>Often combined with the <code>+</code> flag to show signs with padded numbers.</li> <li>Padding occurs after the sign, not before.</li> </ul>"},{"location":"wk_one/#example","title":"Example","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"%9d\\n\", 452);     // \"      452\" (spaces)\n    printf(\"%09d\\n\", 452);    // \"000000452\" (zeros)\n\n    printf(\"%+09d\\n\", 452);   // \"+00000452\"\n    printf(\"%09d\\n\", -452);   // \"-00000452\"\n}\n</code></pre>"},{"location":"wk_one/#literals-and-escape-sequences","title":"Literals and Escape Sequences","text":"<p>Characters in a format string that are not part of a conversion specification are printed literally.</p> <p>Escape sequences allow you to include special characters in strings that cannot be typed directly or would otherwise be ambiguous.</p> Escape Description <code>\\'</code> Single quote (<code>'</code>) <code>\\\"</code> Double quote (<code>\"</code>) <code>\\?</code> Question mark (<code>?</code>) <code>\\\\</code> Backslash (<code>\\\\</code>) <code>\\a</code> Alert (bell/flash) <code>\\b</code> Backspace <code>\\f</code> Form feed (new page) <code>\\n</code> Newline <code>\\r</code> Carriage return (does not move to beginning of next line) <code>\\t</code> Horizontal tab <code>\\v</code> Vertical tab <code>%%</code> Percent symbol (<code>%</code>) <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Hello\\tWorld\\n\");     // tab between words, newline at end\n    printf(\"Path: C:\\\\temp\\n\");   // prints: Path: C:\\temp\n    printf(\"Beep!\\a\\n\");          // may cause a sound or window flash\n    printf(\"CPU usage: 95%%\\n\");  // CPU usage: 95%\n}\n</code></pre> Why <code>%%</code> isn\u2019t like <code>\\\\n</code> <p>Backslash escapes (like <code>\\\\n</code>, <code>\\\\t</code>, <code>\\\\?</code>) are language features handled at compile time, because they solve parsing or representation issues in string literals.  Percent escapes (like <code>%d</code>, <code>%%</code>) are library features, defined only for functions such as <code>printf</code>/<code>scanf</code> and interpreted at runtime.  In short: <code>\\\\n</code> is replaced by the compiler, while <code>%%</code> is handled later by <code>printf</code>.</p>"},{"location":"wk_one/#formatted-io-variants","title":"Formatted I/O Variants","text":"Function Purpose Typical Use Case <code>fprintf(FILE *fp, const char *format, ...)</code> Prints formatted output to a file stream. Writing data to files. <code>fscanf(FILE *fp, const char *format, ...)</code> Reads formatted input from a file stream. Reading structured file input. <code>sprintf(char *str, const char *format, ...)</code> Writes formatted output into a string buffer. Building formatted strings in memory. <code>sscanf(const char *str, const char *format, ...)</code> Reads formatted input from a string. Parsing string data (e.g., CSV fields). <p>Tip</p> <p>These functions behave like <code>printf</code> and <code>scanf</code>, but redirect input/output to files or strings instead of the console.</p>"},{"location":"wk_six/","title":"Week 6","text":"<p>This week covers using variants of a linked list to implement stacks and queues.</p>"},{"location":"wk_six/#stacks","title":"Stacks","text":"<p>A stack is a specialized form of a linked list where insertion and deletion can only occur at one end, called the top of the stack.</p> <p>Stacks follow the Last-In, First-Out (LIFO) principle: the most recently inserted element is the first one removed.</p>"},{"location":"wk_six/#basic-structure","title":"Basic Structure","text":"<p>A stack can be implemented as a linked list, where each node contains:</p> <ul> <li>The data being stored.</li> <li>A pointer to the next node.</li> </ul> <p>The top pointer (<code>stackPtr</code>) always points to the node at the top of the stack. The last node\u2019s link is set to <code>NULL</code> to mark the end of the stack.</p> <pre><code>struct stackNode {\n    int data;             // value stored in the node\n    struct stackNode *nextPtr; // pointer to next node\n};\n</code></pre> <p>Using <code>typedef</code> can make this cleaner:</p> <pre><code>typedef struct stackNode StackNode;\ntypedef StackNode *StackNodePtr;\n</code></pre>"},{"location":"wk_six/#primary-operations","title":"Primary Operations","text":"<p>The two main operations on a stack are push and pop:</p> <ul> <li><code>push(StackNodePtr *topPtr, int value)</code> \u2013 Creates a new node and places it on top of the stack.</li> <li><code>pop(StackNodePtr *topPtr)</code> \u2013 Removes the top node, returns its data, and frees its memory.</li> </ul> <p>In addition, we often include:</p> <ul> <li><code>isEmpty(StackNodePtr topPtr)</code> \u2013 Returns true if the stack is empty.</li> <li><code>printStack(StackNodePtr currentPtr)</code> \u2013 Displays the contents of the stack.</li> </ul>"},{"location":"wk_six/#push-operation","title":"Push Operation","text":"<p>The push operation adds a new element to the top of the stack.</p> <ol> <li>Use <code>malloc</code> to create a new node.</li> <li>Assign the new node\u2019s data field.</li> <li>Point the new node\u2019s <code>nextPtr</code> to the current top node.</li> <li>Update the stack pointer (<code>stackPtr</code>) to point to the new node.</li> </ol> <p>This ensures the new node becomes the first element accessed when popping.</p> <pre><code>void push(StackNodePtr *topPtr, int value)\n{\n    StackNodePtr newPtr = malloc(sizeof(StackNode));\n\n    if (newPtr != NULL) {\n        newPtr-&gt;data = value;\n        newPtr-&gt;nextPtr = *topPtr; // link new node to previous top\n        *topPtr = newPtr;          // move top pointer to new node\n    }\n    else {\n        printf(\\\"No memory available. %d not inserted.\\n\", value);\n    }\n}\n</code></pre> Push Visualization <p> </p>"},{"location":"wk_six/#pop-operation","title":"Pop Operation","text":"<p>The pop operation removes the element currently at the top of the stack. It returns the popped value and frees the corresponding node from memory.</p> <ol> <li>If the stack is empty, the operation cannot proceed.</li> <li>Create a temporary pointer (<code>tempPtr</code>) to hold the current top node.</li> <li>Move the stack pointer (<code>stackPtr</code>) to the next node in the stack.</li> <li>Free the memory for the node stored in <code>tempPtr</code>.</li> </ol> <pre><code>int pop(StackNodePtr *topPtr)\n{\n    int value = (*topPtr)-&gt;data;\n    StackNodePtr tempPtr = *topPtr;   // store current top\n    *topPtr = (*topPtr)-&gt;nextPtr;     // move top to next node\n    free(tempPtr);                    // free old top\n    return value;                     // return popped value\n}\n</code></pre> Pop Visualization <p> </p> <p>After popping, the stack pointer points to the new top node. If all nodes are removed, it becomes <code>NULL</code>, indicating an empty stack.</p>"},{"location":"wk_six/#queues","title":"Queues","text":"<p>A queue is a data structure that operates on the First-In, First-Out (FIFO) principle, similar to a line at a grocery store.</p> <ul> <li>The first person in line receives service first.</li> <li>New customers (or elements) join the end of the line and must wait their turn.</li> </ul> <p>In a queue:</p> <ul> <li>Insertion (enqueue) occurs at the rear (or tail).</li> <li>Removal (dequeue) occurs at the front (or head).</li> </ul> <p>This means that the element inserted earliest is the first to be removed.</p> <p>Queues are used in many areas of computing:</p> <ul> <li>Process Scheduling: When multiple programs or threads compete for CPU time, waiting processes are stored in a queue until the CPU becomes available.</li> <li>Print Spooling: Print jobs are queued until the printer can process them, much like thread spooling in sewing.</li> <li>Network Routing: Data packets are queued at routers before being sent along the network path.</li> </ul> <p>Queues ensure orderly, predictable access to shared resources, where the first to arrive is the first to be processed.</p>"},{"location":"wk_six/#queue-implementation","title":"Queue Implementation","text":"<p>A queue can be implemented as a linked list, where each node contains:</p> <ul> <li>The data to store.</li> <li>A pointer to the next node.</li> </ul> <p>Two pointers are maintained:</p> <ul> <li><code>frontPtr</code> \u2013 Points to the first node (head) of the queue.</li> <li><code>rearPtr</code> \u2013 Points to the last node (tail) of the queue.</li> </ul> <pre><code>struct queueNode {\n    int data;                  // value stored in the node\n    struct queueNode *nextPtr; // pointer to next node\n};\n\ntypedef struct queueNode QueueNode;\ntypedef QueueNode *QueueNodePtr;\n</code></pre>"},{"location":"wk_six/#queue-operations","title":"Queue Operations","text":"<p>The main operations of a queue are enqueue and dequeue:</p>"},{"location":"wk_six/#enqueue","title":"Enqueue","text":"<p>Adds a new node to the rear of the queue.</p> <pre><code>void enqueue(QueueNodePtr *frontPtr, QueueNodePtr *rearPtr, int value)\n{\n    QueueNodePtr newPtr = malloc(sizeof(QueueNode));\n\n    if (newPtr != NULL) {\n        newPtr-&gt;data = value;\n        newPtr-&gt;nextPtr = NULL;\n\n        // if queue is empty, new node is both front and rear\n        if (*frontPtr == NULL)\n            *frontPtr = newPtr;\n        else\n            (*rearPtr)-&gt;nextPtr = newPtr;\n\n        *rearPtr = newPtr;\n    }\n    else {\n        printf(\"No memory available. %d not inserted.\\n\", value);\n    }\n}\n</code></pre> Enqueue Visualization <p> </p>"},{"location":"wk_six/#dequeue","title":"Dequeue","text":"<p>Removes a node from the front of the queue and returns its value.</p> <pre><code>int dequeue(QueueNodePtr *frontPtr, QueueNodePtr *rearPtr)\n{\n    int value = (*frontPtr)-&gt;data;\n    QueueNodePtr tempPtr = *frontPtr;  // store current front\n\n    *frontPtr = (*frontPtr)-&gt;nextPtr;  // move front to next node\n\n    // if queue is now empty, rear must also be NULL\n    if (*frontPtr == NULL)\n        *rearPtr = NULL;\n\n    free(tempPtr);\n    return value;\n}\n</code></pre> Dequeue Visualization <p> </p>"},{"location":"wk_three/","title":"Week 3","text":"<p>This week covers structures and typedefs.</p>"},{"location":"wk_three/#structures","title":"Structures","text":"<p>A structure is a collection of related variables grouped under one name. In the C standard, structures are referred to as aggregates.</p> <p>The <code>struct</code> keyword is used to define a structure type:</p> <pre><code>// A structure for representing a playing card.\nstruct card {\n    const char *face;\n    const char *suit;\n};  // Note: a semicolon is required after the closing brace.\n</code></pre> <p>The example above defines a new structure type named <code>card</code>. The variables declared inside the braces (<code>face</code> and <code>suit</code>) are called members.</p> <p>Since this type definition is a declaration, a semicolon must follow the  closing brace.</p>"},{"location":"wk_three/#member-types","title":"Member Types","text":"<p>Structures can contain members of different types. However, a structure cannot contain a member that is an instance of its own type. For example, the following is invalid:</p> <pre><code>// Invalid: a structure cannot contain an instance of itself.\nstruct card {\n    const char *face;\n    const char *suit;\n    struct card nextCard;  // Invalid\n};\n</code></pre> <p>To work around this, use a pointer to the same type:</p> <pre><code>// Valid: a structure can contain a pointer to its own type.\nstruct card {\n    const char *face;\n    const char *suit;\n    struct card *nextCard;  // Valid\n};\n</code></pre> <p>This pattern is commonly used for creating nodes in a linked list.</p>"},{"location":"wk_three/#defining-variables-of-structure-types","title":"Defining Variables of Structure Types","text":"<p>Structure definitions alone only create a new type that can be used later in  code; they do not reserve any space in memory. A structure definition is  essentially a blueprint. To begin reserving memory for variables, use the  following syntax:</p> <pre><code>// create a new card struct\nstruct card myCard;\n\n// or create an array of card structs\nstruct card deck[52];\n\n// or create a pointer to a card struct\nstruct card *cardPtr;\n</code></pre> <p>You can also create variables of a struct during the definition of the struct  by providing a comma-separated list of variable names after the closing  brace of the struct but before the ending semicolon of the declaration:</p> <pre><code>struct card {\n    const char *face;\n    const char *suit;\n} myCard, deck[52], *cardPtr;\n</code></pre>"},{"location":"wk_three/#structures-without-tag-names","title":"Structures without Tag Names","text":"<p>You can define a struct without a tag name:</p> <pre><code>struct {    // NOTE: no \"card\" tag name\n    const char *face;\n    const char *suit;\n} exampleCard;\n</code></pre> <p>However, without a tag name, you cannot declare additional variables of this  type later in the program. Therefore, you must provide variable names during the declaration to use them.</p> <pre><code>// This defines and declares two variables immediately.\nstruct {\n    int x;\n    int y;\n} point1, point2;\n</code></pre>"},{"location":"wk_three/#comparing-structure-objects","title":"Comparing Structure Objects","text":"<p>Structures cannot be compared using the operators <code>==</code> or <code>!=</code> because structure members may not be stored in consecutive bytes of memory. Compilers often insert padding bytes to align data members according to their type\u2019s alignment requirements.</p> <p>These holes contain unspecified values, which may differ between structures even if all members are identical. In rare cases, they might coincidentally contain the same garbage data (for example, if memory was recently zeroed or reused), making a bytewise comparison appear to return true. However, this behavior is entirely undefined and cannot be relied upon.</p> <p>In short, even if two structures look the same in memory, the C standard provides no guarantee that comparing them byte-by-byte would produce consistent results.</p> Illustration of padding and comparison <p>Suppose we have a struct defined as follows, with two variables of that type named <code>sample1</code> and <code>sample2</code>.</p> <pre><code>struct example {\n    char c;\n    int i;\n} sample1, sample2;\n</code></pre> <p>Initially, the variables contain garbage values:</p> <p></p> <p>We then assign values to the members of <code>sample1</code>:</p> <pre><code>sample1.c = 'G';\nsample1.i = 42069;\n</code></pre> <p></p> <p>Notice that the <code>int</code> portion begins at byte 4. This is because integers must align on a 4-byte boundary, leaving a gap in bytes 1\u20133.</p> <p>Next, we assign the same values to the members of <code>sample2</code>:</p> <pre><code>sample2.c = 'G';\nsample2.i = 42069;\n</code></pre> <p></p> <p>When comparing the two, the visible members appear equivalent, but the hidden padding bytes may contain different, undefined values. Even if both happen to contain zeros or identical garbage, it would be by coincidence, not by rule. The result of comparing such structs directly would therefore be undefined.</p> <p></p> <p>Warning</p> <p>Padding bytes are not initialized or standardized by the C language. Comparing structs as raw memory is undefined behavior and should never be used as a substitute for member-by-member comparison.</p> <p></p>"},{"location":"wk_three/#using-sizeof-with-structures","title":"Using <code>sizeof</code> with Structures","text":"<p>The <code>sizeof</code> operator can be used to determine the amount of memory a structure occupies. However, the value returned by <code>sizeof</code> a structure often exceeds the sum of its members' sizes due to padding and alignment.</p> <p>For example:</p> <pre><code>struct example {\n    char c;\n    int i;\n};\n\nprintf(\"%zu\\n\", sizeof(struct example));  // Likely prints 8, not 5\n</code></pre> <p>The <code>sizeof</code> value includes both the member data and any extra bytes the compiler adds to satisfy memory alignment requirements.</p> <p>Structure packing and alignment</p> <p>When structures are stored in memory, the compiler may insert padding bytes  between members to align data according to hardware requirements. This  improves access performance but can waste space.</p> <p>You can minimize wasted space by ordering structure members from largest to  smallest type (for example, <code>double</code> then <code>int</code> then <code>char</code>).</p> <p>Some compilers provide directives like <code>#pragma pack</code> to override default  alignment and reduce padding. However, this is compiler-specific and  may lead to portability or performance issues. </p> <p>It is generally recommended to avoid using <code>#pragma pack</code> unless you  have a clear and justified need, such as matching external binary data formats.</p>"},{"location":"wk_three/#typedef","title":"<code>typedef</code>","text":"<p><code>typedef</code> allows you to create synonyms (or aliases) for previously defined types.</p> <p>It is commonly used to create shorter names for struct types and simplify declarations of types like function pointers.</p> <p>Tip</p> <p>You can use typedef to avoid retyping out struct card each time you create a new variable of type card.</p> <pre><code>typedef struct card Card;\n// you can now declare a new card struct as follows\nCard newCard;\n</code></pre>"},{"location":"wk_three/#combining-typedef-with-struct-definitions","title":"Combining <code>typedef</code> with <code>struct</code> Definitions","text":"<p>You can combine <code>typedef</code> with a <code>struct</code> declaration to make your code cleaner  and more readable.</p> <p>Tip</p> <pre><code>// Basic struct definition\nstruct card {\n    const char *face;\n    const char *suit;\n};\n\n// typedef struct definition\ntypedef struct {\n    const char *face;\n    const char *suit;\n} Card;\n\n// Create an instance of each\nstruct card basicCard;\nCard typeDefCard;\n</code></pre> <p>Using <code>typedef</code> in this way eliminates the need to repeatedly write <code>struct</code>  when declaring variables and clearly separates the definition of the structure  from its use as a type.</p> <p>Warning</p> <p>When using <code>typedef</code> in this manner, do not include variables in the  struct definition itself. Doing so would cause those variables to be  recreated every time the alias is used.</p> <p>If you need to define variables along with the structure, use the standard  <code>struct</code> definition and then follow it with a separate <code>typedef</code> alias, as  shown in the previous section.</p>"},{"location":"wk_three/#creating-readable-and-consistent-type-aliases","title":"Creating Readable and Consistent Type Aliases","text":"<p><code>typedef</code> is also used to create clear, platform-independent type names.  This is common in system-level programming and game development, where  developers want to ensure that integer sizes and data types are explicit and  consistent across compilers.</p> <p>For example, we can define type aliases like this:</p> <pre><code>typedef uint8_t  uint8;\ntypedef uint16_t uint16;\ntypedef uint32_t uint32;\ntypedef uint64_t uint64;\n\ntypedef int8_t  int8;\ntypedef int16_t int16;\ntypedef int32_t int32;\ntypedef int64_t int64;\n\ntypedef int32 bool32;\n\ntypedef float  real32;\ntypedef double real64;\n</code></pre> <p>These aliases improve clarity by clearly expressing the intended size  and purpose of each type, regardless of the compiler or platform.</p> <p>Info</p> <p>This technique helps:</p> <ul> <li>Make code explicit about the bit-width of each type.</li> <li>Improve portability, since <code>stdint.h</code> guarantees fixed-width integer  types like <code>int32_t</code> and <code>uint16_t</code>.</li> <li>Enhance readability, particularly in codebases where naming  consistency (like <code>real32</code> vs <code>float</code>) helps distinguish between conceptual  or mathematical types.</li> </ul>"},{"location":"wk_two/","title":"Week 2","text":"<p>This week covers formatted input using <code>scanf</code> and recursion.</p>"},{"location":"wk_two/#formatted-input-with-scanf","title":"Formatted Input with <code>scanf</code>","text":"<p><code>scanf</code> statements contain a format control string that specifies how input should be read, followed by pointers to variables where the input will be stored.</p> <p>Key capabilities:</p> <ol> <li>Inputting all types of data.</li> <li>Inputting specific characters from an input stream.</li> <li>Skipping specific characters in an input stream.</li> </ol>"},{"location":"wk_two/#scanf-syntax","title":"<code>scanf</code> Syntax","text":"<pre><code>scanf(format-control-string, other-arguments);\n</code></pre> <p>format-control-string \u2013 describes input formats using conversion specifiers. other-arguments \u2013 pointers to variables that will receive the input.</p> <pre><code>- Prompt the user for one (or a few) items at a time.\n- Avoid asking for many inputs in one statement.\n- Always handle the possibility of incorrect data (e.g., invalid integers or\n  strings with missing punctuation).\n</code></pre>"},{"location":"wk_two/#conversion-specifiers","title":"Conversion Specifiers","text":"<p>Like <code>printf</code>, <code>scanf</code> uses conversion specifiers to handle different data types. Some specifiers differ between input (<code>scanf</code>) and output (<code>printf</code>).</p> Specifier Description Integers <code>%d</code> Reads a signed decimal integer <code>int*</code> <code>%i</code> Reads signed decimal, octal, or hexadecimal <code>int*</code> <code>%o</code> Reads an octal integer <code>unsigned int*</code> <code>%u</code> Reads an unsigned decimal integer <code>unsigned int*</code> <code>%x</code> / <code>%X</code> Reads a hexadecimal integer <code>unsigned int*</code> <code>h</code>, <code>l</code>, <code>ll</code> Length modifiers (<code>short</code>, <code>long</code>, <code>long long</code>) for integers Floating-point <code>%e</code>, <code>%E</code>, <code>%f</code>, <code>%F</code>, <code>%g</code>, <code>%G</code> Reads a floating-point value <code>float*</code> / <code>double*</code> <code>l</code> or <code>L</code> Length modifiers for <code>double</code> or <code>long double</code> Characters &amp; Strings <code>%c</code> Reads a single character <code>char*</code> (no <code>\\0</code> added) <code>%s</code> Reads a string <code>char[]</code> (terminates with <code>\\0</code>) Scan set <code>%[...]</code> Reads a set of characters into a string Miscellaneous <code>%p</code> Reads an address (pointer format) <code>%n</code> Stores number of characters read so far <code>int*</code> <code>%%</code> Skips a literal <code>%</code> in input"},{"location":"wk_two/#using-scan-sets","title":"Using Scan Sets","text":"<p>A scan set allows input of only certain characters, defined inside square brackets <code>[]</code> after a <code>%</code> in the format string. Input continues until a character not in the scan set is encountered.</p> <p>Example: using <code>%[aeiou]</code> reads only vowels.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char z[9] = \"\";\n    printf(\"%s\", \"Enter string: \");\n    scanf(\"%8[aeiou]\", z); // only vowels\n    printf(\"The input was \\\"%s\\\"\\n\", z);\n    return 0;\n}\n</code></pre> <p>Input: <code>oeeeooahah</code> \u2192 stops at <code>h</code>, outputs <code>oeeeooa</code>.</p>"},{"location":"wk_two/#inverting-the-scan-set","title":"Inverting the Scan Set","text":"<p>An inverted scan set matches characters not in the given set. Use a <code>^</code> inside the brackets to invert.</p> <p>Example: <code>%[^aeiou]</code> reads only consonants and other non-vowels.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char z[9] = \"\";\n    printf(\"%s\", \"Enter a string: \");\n    scanf(\"%8[^aeiou]\", z); // non-vowels\n    printf(\"The input was \\\"%s\\\"\\n\", z);\n    return 0;\n}\n</code></pre> <p>Input: <code>String</code> \u2192 stops at vowel <code>i</code>, outputs <code>Str</code>.</p>"},{"location":"wk_two/#using-field-widths","title":"Using Field Widths","text":"<p>A field width can be applied in a <code>scanf</code> conversion specifier to control how many characters are read from the input stream.</p> <ul> <li>Input is read as groups of digits/characters of the specified width.</li> <li>Useful when parsing fixed-length data such as IDs, phone numbers, or formatted strings.</li> </ul> <p>Example: <code>%2d</code> reads exactly 2 digits into one variable, then <code>%d</code> reads the rest.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    int x = 0;\n    int y = 0;\n\n    printf(\"%s\", \"Enter a six digit integer: \");\n    scanf(\"%2d%d\", &amp;x, &amp;y); // first 2 digits go to x, remaining go to y\n\n    printf(\"The integers input were %d and %d\\n\", x, y);\n    return 0;\n}\n</code></pre> <p>Input: <code>123456</code> \u2192 output: <code>12</code> and <code>3456</code>.</p>"},{"location":"wk_two/#skipping-characters-in-an-input-stream","title":"Skipping Characters in an Input Stream","text":"<p><code>scanf</code> can skip unnecessary characters in the input stream:</p> <ul> <li>Whitespace characters (space, tab, newline) are skipped automatically at the beginning of most format specifiers.</li> <li>Literal characters in the format string (like <code>-</code> or <code>/</code>) must match in the input and are discarded.</li> </ul> <p>Example:</p> <pre><code>scanf(\"%d-%d-%d\", &amp;month, &amp;day, &amp;year);\n</code></pre> <p>Input: <code>11-10-1999</code> \u2192 assigns 11, 10, 1999 while skipping the dashes.</p>"},{"location":"wk_two/#assignment-suppression-character","title":"Assignment Suppression Character","text":"<p>The <code>*</code> assignment suppression character allows <code>scanf</code> to read and discard input without storing it in a variable.</p> <p>Example: <code>%*c</code> reads and discards a single character.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    int month = 0;\n    int day = 0;\n    int year = 0;\n\n    printf(\"%s\", \"Enter a date in the form mm-dd-yyyy: \");\n    scanf(\"%d%*c%d%*c%d\", &amp;month, &amp;day, &amp;year); // ignores separators\n    printf(\"month = %d day = %d year = %d\\n\", month, day, year);\n\n    printf(\"%s\", \"Enter a date in the form mm/dd/yyyy: \");\n    scanf(\"%d%*c%d%*c%d\", &amp;month, &amp;day, &amp;year); // works with /\n    printf(\"month = %d day = %d year = %d\\n\", month, day, year);\n    return 0;\n}\n</code></pre> <p>Input: <code>07-04-2021</code> \u2192 output: <code>7 4 2021</code> Input: <code>01/01/2021</code> \u2192 output: <code>1 1 2021</code></p>"},{"location":"wk_two/#recursion","title":"Recursion","text":"<p>A recursive function is one that calls itself, either directly or indirectly through another function. Recursion is a common but complex topic; here we look at its basic structure.</p>"},{"location":"wk_two/#base-cases-and-recursive-calls","title":"Base Cases and Recursive Calls","text":"<p>A recursive function solves problems by dividing them into:</p> <ul> <li>A base case \u2013 the simplest case the function knows how to solve directly.</li> <li>A recursive case \u2013 a more complex problem broken down into smaller versions of itself.</li> </ul> <p>The recursive case must resemble the original problem but be simpler or smaller, ensuring progress toward the base case. Each recursive call works on the reduced problem until the base case is reached.</p>"},{"location":"wk_two/#recursive-step","title":"Recursive Step","text":"<p>When a recursive call is made:</p> <ul> <li>The function pauses its current execution and launches a fresh copy of itself to handle the smaller problem.</li> <li>This process can repeat many times, generating multiple recursive calls.</li> <li>Each call must eventually converge on the base case, where recursion stops.</li> </ul>"},{"location":"wk_two/#returning-results","title":"Returning Results","text":"<p>Each recursive call includes a <code>return</code> statement. When the base case is reached, the result is returned back to the previous call. This chain of returns continues until the result reaches the original caller.</p> <p>In summary:</p> <ul> <li>Base case: directly solvable, no further recursion.</li> <li>Recursive step: reduces the problem and calls the function again.</li> <li>Convergence: repeated recursion eventually reaches the base case, then unwinds with results.</li> </ul>"},{"location":"wk_two/#example-factorial","title":"Example: Factorial","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint factorial(int n) {\n    if (n == 0) {           // base case\n        return 1;\n    } else {\n        return n * factorial(n - 1); // recursive case\n    }\n}\n\nint main(void) {\n    int num = 5;\n    printf(\"Factorial of %d is %d\\n\", num, factorial(num));\n    return 0;\n}\n</code></pre> <p>Input: <code>5</code> \u2192 Output: <code>120</code></p>"},{"location":"wk_two/#stack-visualization","title":"Stack Visualization","text":"<p>Recursive calls can be visualized as a stack. Each new call is pushed onto the stack showing the pending computation, and results are popped once the base case is reached.</p> <p>Factorial(5)</p> <p>Push (calls): Factorial(5) -&gt; 5 _ Factorial(4) Factorial(4) -&gt; 4 _ Factorial(3) Factorial(3) -&gt; 3 _ Factorial(2) Factorial(2) -&gt; 2 _ Factorial(1) Factorial(1) -&gt; 1 * Factorial(0) Factorial(0) -&gt; 1 (base case)</p> <pre><code>&lt;strong&gt;Pop (returns):&lt;/strong&gt;&lt;br&gt;\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=\"color:#4dd0e1;\"&gt;Factorial(1)&lt;/span&gt; = 1 * &lt;span style=\"color:#42a5f5;\"&gt;Factorial(0)&lt;/span&gt; = 1 * 1 = 1&lt;br&gt;\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=\"color:#81c784;\"&gt;Factorial(2)&lt;/span&gt; = 2 * &lt;span style=\"color:#4dd0e1;\"&gt;Factorial(1)&lt;/span&gt; = 2 * 1 = 2&lt;br&gt;\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=\"color:#aed581;\"&gt;Factorial(3)&lt;/span&gt; = 3 * &lt;span style=\"color:#81c784;\"&gt;Factorial(2)&lt;/span&gt; = 3 * 2 = 6&lt;br&gt;\n&amp;nbsp;&amp;nbsp;&lt;span style=\"color:#ffca28;\"&gt;Factorial(4)&lt;/span&gt; = 4 * &lt;span style=\"color:#aed581;\"&gt;Factorial(3)&lt;/span&gt; = 4 * 6 = 24&lt;br&gt;\n&lt;span style=\"color:#ffa726;\"&gt;Factorial(5)&lt;/span&gt; = 5 * &lt;span style=\"color:#ffca28;\"&gt;Factorial(4)&lt;/span&gt; = 5 * 24 = 120\n</code></pre>"}]}