{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"COMP2801 - Application Development with C","text":""},{"location":"#overview","title":"Overview","text":"<p>For full course information bcit.ca. Course taken in Fall 2025 term (outline) with Bob Langelaan.</p> <ul> <li>Midterm and Final in-person</li> <li>4 quizzes, one each in weeks 3, 5, 8, and 11<ul> <li>right at the start of class</li> </ul> </li> <li>8 labs<ul> <li>must be submitted to get a mark for labs</li> </ul> </li> <li>There will be 4 assignments</li> </ul> <p>The course continues from COMP2701 and just follows C How to Program -- Ninth Edition.</p>"},{"location":"wk_four/","title":"Week 4","text":"<p>This week continued Chapter 10 and covered unions and bit manipulations. </p>"},{"location":"wk_four/#unions","title":"Unions","text":"<p>Like a <code>struct</code>, a <code>union</code> is a derived data type. The difference is that all members of a union occupy the same memory space.</p> <p>This is helpful when different variables are only relevant at different times during program execution. By combining them in a <code>union</code>, you can save memory rather than allocating space for all members simultaneously.</p> <p>In most cases, a <code>union</code> contains two or more items of different types. You can access only one member (and therefore one type) at a time. It is the programmer\u2019s responsibility to reference the data with the proper type \u2014 using the wrong one results in a logic error.</p> <p>The <code>sizeof</code> a <code>union</code> is always equal to the size of its largest member type.</p>"},{"location":"wk_four/#declaring-a-union","title":"Declaring a <code>union</code>","text":"<p>The declaration of a <code>union</code> is very similar to that of a <code>struct</code>:</p> <pre><code>union number { \n    int x; \n    double y; \n};\n</code></pre> <p>As with a <code>struct</code>, defining a <code>union</code> only creates a new type; it does not reserve memory until you declare variables of that type.</p> <p>Tip</p> <p>Union definitions are often placed in header files so they can be reused across multiple source files that require access to the same type definition.</p>"},{"location":"wk_four/#initializing-union-during-declaration","title":"Initializing <code>union</code> During Declaration","text":"<p>You can initialize a variable of a union type during its declaration by assigning a value to the first member type listed in the definition.</p> <pre><code>// 'number' contains the following members in order: int x, double y\nunion number value = {10}; // assigns 10 to x\n</code></pre> <p>Warning</p> <p>If you provide a value intended for a different member during initialization, it will be converted to the first member type instead.</p> <pre><code>// 'number' contains the following members in order: int x, double y\nunion number value = {1.43}; // assigns 1 to x instead of assigning 1.43 to y\n</code></pre>"},{"location":"wk_four/#beyond-the-textbook-tagged-unions","title":"Beyond the Textbook: Tagged Unions","text":"<p>Note</p> <p>The following material was not covered in class (nor in this section of  the text as far as I can tell) and is provided here for informational purposes only.</p> <p>While traditional unions allow multiple types to share the same memory space, they provide no way to track which member is currently active. This makes them error-prone for most applications.</p> <p>A safer and more common modern pattern is the tagged union (also called a discriminated union). A tagged union adds an explicit field, or tag, to record which member of the union is currently valid.</p> <p>This trades a bit of extra overhead for greater safety.</p> <pre><code>enum ValueType { TYPE_INT, TYPE_DOUBLE };\n\nstruct Value {\n    enum ValueType type;   // the tag\n    union {\n        int i;\n        double d;\n    } data;\n};\n</code></pre> <p>This design lets programs safely determine which member to use:</p> <pre><code>struct Value v;\nv.type = TYPE_DOUBLE;\nv.data.d = 3.14;\n\nif (v.type == TYPE_DOUBLE) {\n    printf(\"%f\\n\", v.data.d);\n}\n</code></pre> <p>Info</p> <p>Tagged unions are common in modern C for representing values that may take multiple forms, such as tokens in a compiler or event types in an input system. They are safer and clearer than plain unions while still using shared memory efficiently.</p>"},{"location":"wk_four/#bitwise-operators","title":"Bitwise Operators","text":"<p>Computers represent all data internally as sequences of bits (0s and 1s). Each bit can store one of two values, and groups of bits are used to represent larger quantities. On most systems, eight bits form one byte \u2014 the typical storage unit for a <code>char</code>.</p> <p>Bitwise operators allow direct manipulation of individual bits within integer values. These operations work on the binary representations of the operands and are frequently used for low-level programming, such as hardware control, encoding, and flag management.</p> <p>Note</p> <p>Bitwise operations are typically applied to unsigned integers to avoid ambiguity when dealing with sign bits and system-dependent right-shift behavior.</p>"},{"location":"wk_four/#bitwise-and","title":"Bitwise AND (<code>&amp;</code>)","text":"<p>Sets each bit in the result to 1 only if the corresponding bits in both operands are 1.</p> <pre><code>// 4-bit examples\n//    1101  (13)\n//  &amp; 1011  (11)\n//  --------\n//    1001  (9)\n</code></pre>"},{"location":"wk_four/#bitwise-or","title":"Bitwise OR (<code>|</code>)","text":"<p>Sets each bit in the result to 1 if at least one of the corresponding bits in either operand is 1.</p> <pre><code>//    1101  (13)\n//  | 1011  (11)\n//  --------\n//    1111  (15)\n</code></pre>"},{"location":"wk_four/#bitwise-xor","title":"Bitwise XOR (<code>^</code>)","text":"<p>Sets each bit in the result to 1 only if the corresponding bits in the operands differ.</p> <pre><code>//    1101  (13)\n//  ^ 1011  (11)\n//  --------\n//    0110  (6)\n</code></pre>"},{"location":"wk_four/#left-shift","title":"Left Shift (<code>&lt;&lt;</code>)","text":"<p>Moves bits to the left, filling with zeros from the right. Each left shift by 1 multiplies the number by 2.</p> <pre><code>//    0101  (5)\n//  &lt;&lt; 1\n//  --------\n//    1010  (10)\n</code></pre>"},{"location":"wk_four/#right-shift","title":"Right Shift (<code>&gt;&gt;</code>)","text":"<p>Moves bits to the right, discarding bits on the right. For unsigned values, zeros are filled in from the left. Each right shift by 1 divides the number by 2 (integer division).</p> <pre><code>//    1010  (10)\n//  &gt;&gt; 1\n//  --------\n//    0101  (5)\n</code></pre>"},{"location":"wk_four/#bitwise-not","title":"Bitwise NOT (<code>~</code>)","text":"<p>Inverts each bit of the operand, turning 0s into 1s and 1s into 0s.</p> <pre><code>//    0101  (5)\n//  ~\n//  --------\n//    1010  (10 if only 4 bits are shown)\n</code></pre> <p>Warning</p> <p>In C, <code>~</code> inverts all bits in the operand, not just the visible ones. For fixed-width integers like <code>uint8_t</code>, this means all 8 bits are inverted. When printed as signed types, this can appear as a negative number.</p>"},{"location":"wk_four/#beyond-the-textbook-common-bit-manipulation-techniques","title":"Beyond the Textbook: Common Bit Manipulation Techniques","text":"<p>Note</p> <p>The following material was not covered in class (nor in this section of  the text) and is provided here for informational purposes only.</p> <p>Bit manipulation techniques are frequently used in competitive programming and technical interviews (such as on LeetCode). These operations allow efficient arithmetic and logical computations without relying on higher-level constructs.</p> <p>Below are several common patterns, each explained with examples using 4-bit binary values for clarity.</p>"},{"location":"wk_four/#1-checking-if-a-number-is-even-or-odd","title":"1. Checking if a Number is Even or Odd","text":"<p>You can check the least significant bit (LSB) of a number using the bitwise AND operator.</p> <pre><code>if (x &amp; 1)\n    printf(\"Odd\");\nelse\n    printf(\"Even\");\n</code></pre> <p>Example:</p> <pre><code>//   0101 (5)\n// &amp; 0001\n// ------\n//   0001 -&gt; Odd\n\n//   0110 (6)\n// &amp; 0001\n// ------\n//   0000 -&gt; Even\n</code></pre>"},{"location":"wk_four/#2-swapping-two-numbers-without-a-temporary-variable","title":"2. Swapping Two Numbers Without a Temporary Variable","text":"<p>This uses XOR to swap values in place.</p> <pre><code>a ^= b;\nb ^= a;\na ^= b;\n</code></pre> <p>Example:</p> <pre><code>// a = 0101 (5)\n// b = 0011 (3)\n// Step 1: a = a ^ b -&gt; 0110\n// Step 2: b = b ^ a -&gt; 0101\n// Step 3: a = a ^ b -&gt; 0011\n// Result: a = 3, b = 5\n</code></pre>"},{"location":"wk_four/#3-checking-if-a-number-is-a-power-of-two","title":"3. Checking if a Number is a Power of Two","text":"<p>A number is a power of two if it has exactly one bit set.</p> <pre><code>if (x &gt; 0 &amp;&amp; (x &amp; (x - 1)) == 0)\n    printf(\"Power of 2\");\n</code></pre> <p>Example:</p> <pre><code>//   x = 0100 (4)\n// x-1 = 0011\n// &amp; operation:\n//   0100\n// &amp; 0011 \n//   ---- \n//   0000 -&gt; true\n</code></pre>"},{"location":"wk_four/#4-counting-set-bits-brian-kernighans-algorithm","title":"4. Counting Set Bits (Brian Kernighan\u2019s Algorithm)","text":"<p>This algorithm repeatedly removes the lowest set bit until the number becomes zero.</p> <pre><code>int count = 0;\nwhile (x) {\n    x &amp;= (x - 1);\n    count++;\n}\n</code></pre> <p>Example:</p> <pre><code>// x = 1101 (13)\n// 1101 -&gt; 1100 -&gt; 1000 -&gt; 0000\n// count = 3\n</code></pre>"},{"location":"wk_four/#5-clearing-or-setting-a-specific-bit","title":"5. Clearing or Setting a Specific Bit","text":"<p>To set a bit, use OR; to clear a bit, use AND with the complement of a mask.</p> <pre><code>// Set nth bit\nx |= (1 &lt;&lt; n);\n\n// Clear nth bit\nx &amp;= ~(1 &lt;&lt; n);\n</code></pre> <p>Example:</p> <pre><code>// x = 0101, n = 1\n// (1 &lt;&lt; 1) = 0010\n// Set:   0101 | 0010 = 0111\n// Clear: 0101 &amp; 1101 = 0101 (no change since that bit is already 0)\n</code></pre>"},{"location":"wk_four/#6-toggling-a-bit","title":"6. Toggling a Bit","text":"<p>Flips the specified bit using XOR.</p> <pre><code>x ^= (1 &lt;&lt; n);\n</code></pre> <p>Example:</p> <pre><code>// x = 0101, n = 2\n// (1 &lt;&lt; 2) = 0100\n//   0101 \n// ^ 0100 \n//   ----\n//   0001\n</code></pre>"},{"location":"wk_four/#7-extracting-the-lowest-set-bit","title":"7. Extracting the Lowest Set Bit","text":"<p>Returns a number with only the lowest set bit of <code>x</code> preserved.</p> <pre><code>int lowest = x &amp; -x;\n</code></pre> <p>Example:</p> <pre><code>// x = 1010\n// -x (two\u2019s complement) = 0110\n//   1010 \n// &amp; 0110 \n//   ----\n//   0010\n</code></pre>"},{"location":"wk_four/#8-checking-if-two-integers-have-opposite-signs","title":"8. Checking if Two Integers Have Opposite Signs","text":"<p>Uses XOR to test the sign bit. The result will be negative if the signs differ.</p> <pre><code>if ((x ^ y) &lt; 0)\n    printf(\"Opposite signs\");\n</code></pre> <p>Example:</p> <pre><code>// x = +5 (0101), y = -3 (in 4-bit two\u2019s complement: 1101)\n// x ^ y = 1000 (negative)\n// -&gt; Opposite signs\n</code></pre>"},{"location":"wk_one/","title":"Week 1","text":"<p>This week covers the first half of Chapter 9 in the text. We look in depth at <code>printf</code> formatting including specifiers, field widths, formatting flags, and escape sequences which all help control how output is displayed.</p>"},{"location":"wk_one/#streams","title":"Streams","text":"<p>Streams are sequences of bytes used for input and output.</p> <ul> <li>Input: Data flows from a device (keyboard, disk, network, etc.) into main memory.</li> <li>Output: Data flows from main memory to a device (screen, printer, disk, network, etc.).</li> </ul> <p>At program start, three standard streams are available:</p> <ol> <li>Standard input (<code>stdin</code>) \u2013 usually from the keyboard.</li> <li>Standard output (<code>stdout</code>) \u2013 usually to the screen.</li> <li>Standard error (<code>stderr</code>) \u2013 also to the screen, for error messages.</li> </ol> <p>Redirection: Operating systems allow these streams to be redirected to other devices or files.</p>"},{"location":"wk_one/#printf-formatting","title":"<code>printf</code> Formatting","text":"<p>As we learned in the previous course, <code>printf</code> can be used to format output to <code>stdout</code> using conversion specifications.</p>"},{"location":"wk_one/#type-specifiers","title":"Type Specifiers","text":""},{"location":"wk_one/#integers","title":"Integers","text":"Specifier Description <code>%d</code> Signed decimal integer <code>%i</code> Signed decimal integer (same as <code>%d</code>) <code>%o</code> Unsigned octal integer <code>%u</code> Unsigned decimal integer <code>%x</code> Unsigned hexadecimal integer (lowercase a\u2013f) <code>%X</code> Unsigned hexadecimal integer (uppercase A\u2013F) <code>%hd</code> / <code>%ld</code> / <code>%lld</code> Short, long, or long long integers (length modifiers) <p>Note: if you are using any of the unsigned specifiers, don't pass it any negative numbers.</p> <p>If you are using any of the long length modifiers you should add a corresponding literal suffix (<code>L</code>, <code>LL</code>) to the value that you pass to <code>printf</code>.</p> <pre><code>printf(\"%ld\\n\", 5000000000L); // long (suffix L required)\nprintf(\"%lld\\n\", 9000000000000LL); // long long (suffix LL required)\n</code></pre>"},{"location":"wk_one/#floating-point-numbers","title":"Floating-Point Numbers","text":"Specifier Description <code>%e</code> / <code>%E</code> Exponential (scientific) notation (e.g., <code>1.23e+02</code> or <code>1.23E+02</code>) <code>%f</code> / <code>%F</code> Fixed-point notation <code>%g</code> / <code>%G</code> Uses either <code>%f</code> or <code>%e</code> (<code>%E</code>) depending on value\u2019s magnitude, with no trailing zeros <code>%Lf</code> / <code>%Le</code> / <code>%Lg</code> Long double (length modifier <code>L</code>) <p>The default precision is 6 digits after the decimal (for <code>%f</code>) or 6 significant digits (for <code>%g</code>/<code>%G</code>).</p> <p>Rounding: <code>%e</code>, <code>%E</code>, and <code>%g</code> perform rounding; <code>%f</code> shows exact decimals.</p> <p><code>%g</code>/<code>%G</code> automatically chooses the shortest visual representation for a given number:</p> <ul> <li>Chooses <code>%e</code> if the exponent is &lt; -4 or \u2265 precision.</li> <li>Otherwise chooses <code>%f</code>.</li> <li>Removes trailing zeros.</li> <li>Omits the decimal point if the fractional part is zero.</li> </ul> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"%g\\n\", 87.0);        // 87\n    // whole number, fractional part is zero so \".0\" is suppressed\n\n    printf(\"%g\\n\", 87.50);       // 87.5\n    // fractional part kept, trailing zero removed\n\n    printf(\"%g\\n\", 87.25);       // 87.25\n    // fractional part kept, no trailing zeros to remove\n\n    printf(\"%g\\n\", 0.0000875);   // 8.75e-05\n    // exponent &lt; -4, so %e format is chosen\n\n    printf(\"%g\\n\", 8750000.0);   // 8.75e+06\n    // exponent \u2265 precision (6), so %e format is chosen\n\n    printf(\"%#g\\n\", 87.0);       // 87.0000\n    // '#' flag forces decimal point and trailing zeros up to precision\n\n    return 0;\n}\n</code></pre>"},{"location":"wk_one/#strings-and-characters","title":"Strings and Characters","text":"<ul> <li><code>%c</code> prints a single <code>char</code></li> <li><code>%s</code> prints a null-terminated string (<code>char*</code>), stops at <code>\\0</code></li> <li>Missing null terminator or wrong format specifier (e.g., <code>%s</code> with a <code>char</code>) undefined behavior, often a crash</li> <li>Compilers usually don\u2019t catch format string errors \u2014 they show up only at runtime.</li> </ul>"},{"location":"wk_one/#pointers","title":"Pointers","text":"Specifier Description <code>%p</code> Displays a pointer (address) in an implementation-defined way (commonly hexadecimal) <p><code>%p</code> expects a pointer argument (e.g., <code>&amp;x</code>, or a <code>char*</code>, <code>int*</code>, etc.). The exact format of the address depends on the system, but is typically hexadecimal. Useful for debugging to confirm memory addresses.</p>"},{"location":"wk_one/#field-width","title":"Field Width","text":"<p>You can control the minimum number of characters used when printing a value by specifying a field width.</p> <p>If the value has fewer characters than the field width then it is padded (by default with spaces).</p> <p>Note: If the value has more characters than the field width then the full value is printed (field width is ignored). That is to say, it does not truncate the output.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"%4d\\n\", 1);       //    1\n    printf(\"%4d\\n\", 12);      //   12\n    printf(\"%4d\\n\", 123);     //  123\n    printf(\"%4d\\n\", 1234);    // 1234\n    printf(\"%4d\\n\", 12345);   // 12345 (too wide, prints fully)\n\n    printf(\"%4d\\n\", -1);      //   -1\n    printf(\"%4d\\n\", -12);     //  -12\n    printf(\"%4d\\n\", -123);    // -123\n    printf(\"%4d\\n\", -1234);   // -1234\n    printf(\"%4d\\n\", -12345);  // -12345\n}\n</code></pre>"},{"location":"wk_one/#negative-values","title":"Negative Values","text":"<p>If the value has a negative sign, it will use up one of the field width characters:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"BEFORE%4dAFTER\\n\", 1);        //BEFORE   1AFTER\n    printf(\"BEFORE%4dAFTER\\n\", -1);       //BEFORE  -1AFTER\n    // In the second example, there are only 2 spaces.\n}\n</code></pre>"},{"location":"wk_one/#dynamic-widths","title":"Dynamic Widths","text":"<p>Instead of providing a number, you can pass <code>*</code> instead and then supply the width as one of the values passed instead.</p> <p>This works for precision as well.</p> <pre><code>printf(\"BEFORE%*.*fAFTER\", 7, 2, 98.736); // BEFORE  98.74AFTER\n// 7 \u2192 total field width (minimum size, includes digits, decimal point, and padding)\n// 2 \u2192 precision (number of digits after the decimal point)\n</code></pre>"},{"location":"wk_one/#format-flags","title":"Format Flags","text":""},{"location":"wk_one/#alignment","title":"Alignment","text":"<p>By default, values are right-aligned in the field. To make them left-aligned, add a <code>-</code> before the field width:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"BEFORE%4dAFTER\\n\", 1);        //BEFORE   1AFTER\n    printf(\"BEFORE%-4dAFTER\\n\", 1);       //BEFORE1   AFTER\n}\n</code></pre>"},{"location":"wk_one/#sign-control-for-numbers","title":"Sign Control (for numbers)","text":"<p>By default, only negative numbers are printed with a sign (<code>-</code>). You can control how positive numbers appear using flags:</p> <ul> <li><code>+</code>: always print a sign (<code>+</code> for positive, <code>-</code> for negative).</li> <li>space (<code>' '</code>): print a space in front of positive numbers (negative numbers still get <code>-</code>).</li> </ul> <p>This can be useful for aligning columns of positive and negative numbers.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"%d\\n\", 42);     // 42\n    printf(\"%+d\\n\", 42);    // +42\n    printf(\"% d\\n\", 42);    //  42 (leading space)\n    printf(\"%d\\n\", -42);    // -42\n    printf(\"%+d\\n\", -42);   // -42\n    printf(\"% d\\n\", -42);   // -42\n}\n</code></pre>"},{"location":"wk_one/#alternate-form-flag","title":"Alternate Form (# Flag)","text":"<p>The <code>#</code> flag modifies how certain values are displayed:</p> <ul> <li>Octal (<code>%o</code>): prefixes the value with <code>0</code>.</li> <li>Hexadecimal (<code>%x</code> / <code>%X</code>): prefixes the value with <code>0x</code> or <code>0X</code>.</li> <li> <p>Floating-point (<code>%f</code>, <code>%e</code>, <code>%E</code>, <code>%g</code>, <code>%G</code>): forces a decimal point to appear, even if the fractional part is zero.</p> </li> <li> <p>For <code>%g</code> / <code>%G</code>, it also prevents trailing zeros from being removed.</p> </li> </ul> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    int c = 1427;\n    double p = 1427.0;\n\n    printf(\"%o\\n\", c);    // 2623\n    printf(\"%#o\\n\", c);   // 02623\n\n    printf(\"%x\\n\", c);    // 593\n    printf(\"%#x\\n\", c);   // 0x593\n\n    printf(\"%X\\n\", c);    // 593\n    printf(\"%#X\\n\", c);   // 0X593\n\n    printf(\"%g\\n\", p);    // 1427\n    printf(\"%#g\\n\", p);   // 1427.00 (decimal point forced, trailing zeros kept)\n}\n</code></pre>"},{"location":"wk_one/#zero-padding-0-flag","title":"Zero Padding (0 Flag)","text":"<p>By default, extra space in a field width is filled with spaces. The <code>0</code> flag changes this so that extra space is filled with leading zeros.</p> <ul> <li>Works with integers and floating-point numbers.</li> <li>Often combined with the <code>+</code> flag to show signs with padded numbers.</li> <li>Padding occurs after the sign, not before.</li> </ul>"},{"location":"wk_one/#example","title":"Example","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"%9d\\n\", 452);     // \"      452\" (spaces)\n    printf(\"%09d\\n\", 452);    // \"000000452\" (zeros)\n\n    printf(\"%+09d\\n\", 452);   // \"+00000452\"\n    printf(\"%09d\\n\", -452);   // \"-00000452\"\n}\n</code></pre>"},{"location":"wk_one/#literals-and-escape-sequences","title":"Literals and Escape Sequences","text":"<p>Characters in a format string that are not part of a conversion specification are printed literally.</p> <p>Escape sequences allow you to include special characters in strings that cannot be typed directly or would otherwise be ambiguous.</p> Escape Description <code>\\'</code> Single quote (<code>'</code>) <code>\\\"</code> Double quote (<code>\"</code>) <code>\\?</code> Question mark (<code>?</code>) <code>\\\\</code> Backslash (<code>\\\\</code>) <code>\\a</code> Alert (bell/flash) <code>\\b</code> Backspace <code>\\f</code> Form feed (new page) <code>\\n</code> Newline <code>\\r</code> Carriage return <code>\\t</code> Horizontal tab <code>\\v</code> Vertical tab <code>%%</code> Percent symbol (<code>%</code>) <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Hello\\tWorld\\n\");     // tab between words, newline at end\n    printf(\"Path: C:\\\\temp\\n\");   // prints: Path: C:\\temp\n    printf(\"Beep!\\a\\n\");          // may cause a sound or window flash\n    printf(\"CPU usage: 95%%\\n\");  // CPU usage: 95%\n}\n</code></pre> Why <code>%%</code> isn\u2019t like <code>\\\\n</code> <p>Backslash escapes (like <code>\\\\n</code>, <code>\\\\t</code>, <code>\\\\?</code>) are language features handled at compile time, because they solve parsing or representation issues in string literals.</p> <pre><code>Percent escapes (like `%d`, `%%`) are **library features**, defined only for functions such as `printf`/`scanf` and interpreted at runtime.\n\n**In short:** `\\\\n` is replaced by the compiler, while `%%` is handled later by `printf`.\n</code></pre>"},{"location":"wk_three/","title":"Week 3","text":"<p>This week covers structures and typedefs.</p>"},{"location":"wk_three/#structures","title":"Structures","text":"<p>A structure is a collection of related variables grouped under one name. In the C standard, structures are referred to as aggregates.</p> <p>The <code>struct</code> keyword is used to define a structure type:</p> <pre><code>// A structure for representing a playing card.\nstruct card {\n    const char *face;\n    const char *suit;\n};  // Note: a semicolon is required after the closing brace.\n</code></pre> <p>The example above defines a new structure type named <code>card</code>. The variables declared inside the braces (<code>face</code> and <code>suit</code>) are called members.</p> <p>Since this type definition is a declaration, a semicolon must follow the  closing brace.</p>"},{"location":"wk_three/#member-types","title":"Member Types","text":"<p>Structures can contain members of different types. However, a structure cannot contain a member that is an instance of its own type. For example, the following is invalid:</p> <pre><code>// Invalid: a structure cannot contain an instance of itself.\nstruct card {\n    const char *face;\n    const char *suit;\n    struct card nextCard;  // Invalid\n};\n</code></pre> <p>To work around this, use a pointer to the same type:</p> <pre><code>// Valid: a structure can contain a pointer to its own type.\nstruct card {\n    const char *face;\n    const char *suit;\n    struct card *nextCard;  // Valid\n};\n</code></pre> <p>This pattern is commonly used for creating nodes in a linked list.</p>"},{"location":"wk_three/#defining-variables-of-structure-types","title":"Defining Variables of Structure Types","text":"<p>Structure definitions alone only create a new type that can be used later in  code; they do not reserve any space in memory. A structure definition is  essentially a blueprint. To begin reserving memory for variables, use the  following syntax:</p> <pre><code>// create a new card struct\nstruct card myCard;\n\n// or create an array of card structs\nstruct card deck[52];\n\n// or create a pointer to a card struct\nstruct card *cardPtr;\n</code></pre> <p>You can also create variables of a struct during the definition of the struct  by providing a comma-separated list of variable names after the closing  brace of the struct but before the ending semicolon of the declaration:</p> <pre><code>struct card {\n    const char *face;\n    const char *suit;\n} myCard, deck[52], *cardPtr;\n</code></pre>"},{"location":"wk_three/#structures-without-tag-names","title":"Structures without Tag Names","text":"<p>You can define a struct without a tag name:</p> <pre><code>struct {    // NOTE: no \"card\" tag name\n    const char *face;\n    const char *suit;\n} exampleCard;\n</code></pre> <p>However, without a tag name, you cannot declare additional variables of this  type later in the program. Therefore, you must provide variable names during the declaration to use them.</p> <pre><code>// This defines and declares two variables immediately.\nstruct {\n    int x;\n    int y;\n} point1, point2;\n</code></pre>"},{"location":"wk_three/#comparing-structure-objects","title":"Comparing Structure Objects","text":"<p>Structures cannot be compared using the operators <code>==</code> or <code>!=</code> because structure members may not be stored in consecutive bytes of memory. Compilers often insert padding bytes to align data members according to their type\u2019s alignment requirements.</p> <p>These holes contain unspecified values, which may differ between structures even if all members are identical. In rare cases, they might coincidentally contain the same garbage data (for example, if memory was recently zeroed or reused), making a bytewise comparison appear to return true. However, this behavior is entirely undefined and cannot be relied upon.</p> <p>In short, even if two structures look the same in memory, the C standard provides no guarantee that comparing them byte-by-byte would produce consistent results.</p> Illustration of padding and comparison <p>Suppose we have a struct defined as follows, with two variables of that type named <code>sample1</code> and <code>sample2</code>.</p> <pre><code>struct example {\n    char c;\n    int i;\n} sample1, sample2;\n</code></pre> <p>Initially, the variables contain garbage values:</p> <p></p> <p>We then assign values to the members of <code>sample1</code>:</p> <pre><code>sample1.c = 'G';\nsample1.i = 42069;\n</code></pre> <p></p> <p>Notice that the <code>int</code> portion begins at byte 4. This is because integers must align on a 4-byte boundary, leaving a gap in bytes 1\u20133.</p> <p>Next, we assign the same values to the members of <code>sample2</code>:</p> <pre><code>sample2.c = 'G';\nsample2.i = 42069;\n</code></pre> <p></p> <p>When comparing the two, the visible members appear equivalent, but the hidden padding bytes may contain different, undefined values. Even if both happen to contain zeros or identical garbage, it would be by coincidence, not by rule. The result of comparing such structs directly would therefore be undefined.</p> <p></p> <p>Warning</p> <p>Padding bytes are not initialized or standardized by the C language. Comparing structs as raw memory is undefined behavior and should never be used as a substitute for member-by-member comparison.</p> <p></p>"},{"location":"wk_three/#using-sizeof-with-structures","title":"Using <code>sizeof</code> with Structures","text":"<p>The <code>sizeof</code> operator can be used to determine the amount of memory a structure occupies. However, the value returned by <code>sizeof</code> a structure often exceeds the sum of its members' sizes due to padding and alignment.</p> <p>For example:</p> <pre><code>struct example {\n    char c;\n    int i;\n};\n\nprintf(\"%zu\\n\", sizeof(struct example));  // Likely prints 8, not 5\n</code></pre> <p>The <code>sizeof</code> value includes both the member data and any extra bytes the compiler adds to satisfy memory alignment requirements.</p> <p>Structure packing and alignment</p> <p>When structures are stored in memory, the compiler may insert padding bytes  between members to align data according to hardware requirements. This  improves access performance but can waste space.</p> <p>You can minimize wasted space by ordering structure members from largest to  smallest type (for example, <code>double</code> then <code>int</code> then <code>char</code>).</p> <p>Some compilers provide directives like <code>#pragma pack</code> to override default  alignment and reduce padding. However, this is compiler-specific and  may lead to portability or performance issues. </p> <p>It is generally recommended to avoid using <code>#pragma pack</code> unless you  have a clear and justified need, such as matching external binary data formats.</p>"},{"location":"wk_three/#typedef","title":"<code>typedef</code>","text":"<p><code>typedef</code> allows you to create synonyms (or aliases) for previously defined types.</p> <p>It is commonly used to create shorter names for struct types and simplify declarations of types like function pointers.</p> <p>Tip</p> <p>You can use typedef to avoid retyping out struct card each time you create a new variable of type card.</p> <pre><code>typedef struct card Card;\n// you can now declare a new card struct as follows\nCard newCard;\n</code></pre>"},{"location":"wk_three/#combining-typedef-with-struct-definitions","title":"Combining <code>typedef</code> with <code>struct</code> Definitions","text":"<p>You can combine <code>typedef</code> with a <code>struct</code> declaration to make your code cleaner  and more readable.</p> <p>Tip</p> <pre><code>// Basic struct definition\nstruct card {\n    const char *face;\n    const char *suit;\n};\n\n// typedef struct definition\ntypedef struct {\n    const char *face;\n    const char *suit;\n} Card;\n\n// Create an instance of each\nstruct card basicCard;\nCard typeDefCard;\n</code></pre> <p>Using <code>typedef</code> in this way eliminates the need to repeatedly write <code>struct</code>  when declaring variables and clearly separates the definition of the structure  from its use as a type.</p> <p>Warning</p> <p>When using <code>typedef</code> in this manner, do not include variables in the  struct definition itself. Doing so would cause those variables to be  recreated every time the alias is used.</p> <p>If you need to define variables along with the structure, use the standard  <code>struct</code> definition and then follow it with a separate <code>typedef</code> alias, as  shown in the previous section.</p>"},{"location":"wk_three/#creating-readable-and-consistent-type-aliases","title":"Creating Readable and Consistent Type Aliases","text":"<p><code>typedef</code> is also used to create clear, platform-independent type names.  This is common in system-level programming and game development, where  developers want to ensure that integer sizes and data types are explicit and  consistent across compilers.</p> <p>For example, we can define type aliases like this:</p> <pre><code>typedef uint8_t  uint8;\ntypedef uint16_t uint16;\ntypedef uint32_t uint32;\ntypedef uint64_t uint64;\n\ntypedef int8_t  int8;\ntypedef int16_t int16;\ntypedef int32_t int32;\ntypedef int64_t int64;\n\ntypedef int32 bool32;\n\ntypedef float  real32;\ntypedef double real64;\n</code></pre> <p>These aliases improve clarity by clearly expressing the intended size  and purpose of each type, regardless of the compiler or platform.</p> <p>Info</p> <p>This technique helps:</p> <ul> <li>Make code explicit about the bit-width of each type.</li> <li>Improve portability, since <code>stdint.h</code> guarantees fixed-width integer  types like <code>int32_t</code> and <code>uint16_t</code>.</li> <li>Enhance readability, particularly in codebases where naming  consistency (like <code>real32</code> vs <code>float</code>) helps distinguish between conceptual  or mathematical types.</li> </ul>"},{"location":"wk_two/","title":"Week 2","text":"<p>This week covers formatted input using <code>scanf</code> and recursion.</p>"},{"location":"wk_two/#formatted-input-with-scanf","title":"Formatted Input with <code>scanf</code>","text":"<p><code>scanf</code> statements contain a format control string that specifies how input should be read, followed by pointers to variables where the input will be stored.</p> <p>Key capabilities:</p> <ol> <li>Inputting all types of data.</li> <li>Inputting specific characters from an input stream.</li> <li>Skipping specific characters in an input stream.</li> </ol>"},{"location":"wk_two/#scanf-syntax","title":"<code>scanf</code> Syntax","text":"<pre><code>scanf(format-control-string, other-arguments);\n</code></pre> <p>format-control-string \u2013 describes input formats using conversion specifiers. other-arguments \u2013 pointers to variables that will receive the input.</p> <p> * Prompt the user for one (or a few) items at a time. * Avoid asking for many inputs in one statement. * Always handle the possibility of incorrect data (e.g., invalid integers or   strings with missing punctuation).</p>"},{"location":"wk_two/#conversion-specifiers","title":"Conversion Specifiers","text":"<p>Like <code>printf</code>, <code>scanf</code> uses conversion specifiers to handle different data types. Some specifiers differ between input (<code>scanf</code>) and output (<code>printf</code>).</p> Specifier Description Integers <code>%d</code> Reads a signed decimal integer  <code>int*</code> <code>%i</code> Reads signed decimal, octal, or hexadecimal  <code>int*</code> <code>%o</code> Reads an octal integer  <code>unsigned int*</code> <code>%u</code> Reads an unsigned decimal integer  <code>unsigned int*</code> <code>%x</code> / <code>%X</code> Reads a hexadecimal integer  <code>unsigned int*</code> <code>h</code>, <code>l</code>, <code>ll</code> Length modifiers (<code>short</code>, <code>long</code>, <code>long long</code>) for integers Floating-point <code>%e</code>, <code>%E</code>, <code>%f</code>, <code>%F</code>, <code>%g</code>, <code>%G</code> Reads a floating-point value  <code>float*</code> / <code>double*</code> <code>l</code> or <code>L</code> Length modifiers for <code>double</code> or <code>long double</code> Characters &amp; Strings <code>%c</code> Reads a single character  <code>char*</code> (no <code>\\0</code> added) <code>%s</code> Reads a string  <code>char[]</code> (terminates with <code>\\0</code>) Scan set <code>%[...]</code> Reads a set of characters into a string Miscellaneous <code>%p</code> Reads an address (pointer format) <code>%n</code> Stores number of characters read so far  <code>int*</code> <code>%%</code> Skips a literal <code>%</code> in input"},{"location":"wk_two/#using-scan-sets","title":"Using Scan Sets","text":"<p>A scan set allows input of only certain characters, defined inside square brackets <code>[]</code> after a <code>%</code> in the format string. Input continues until a character not in the scan set is encountered.</p> <p>Example: using <code>%[aeiou]</code> reads only vowels.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char z[9] = \"\";\n    printf(\"%s\", \"Enter string: \");\n    scanf(\"%8[aeiou]\", z); // only vowels\n    printf(\"The input was \\\"%s\\\"\\n\", z);\n    return 0;\n}\n</code></pre> <p>Input: <code>oeeeooahah</code> \u2192 stops at <code>h</code>, outputs <code>oeeeooa</code>.</p>"},{"location":"wk_two/#inverting-the-scan-set","title":"Inverting the Scan Set","text":"<p>An inverted scan set matches characters not in the given set. Use a <code>^</code> inside the brackets to invert.</p> <p>Example: <code>%[^aeiou]</code> reads only consonants and other non-vowels.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char z[9] = \"\";\n    printf(\"%s\", \"Enter a string: \");\n    scanf(\"%8[^aeiou]\", z); // non-vowels\n    printf(\"The input was \\\"%s\\\"\\n\", z);\n    return 0;\n}\n</code></pre> <p>Input: <code>String</code> \u2192 stops at vowel <code>i</code>, outputs <code>Str</code>.</p>"},{"location":"wk_two/#using-field-widths","title":"Using Field Widths","text":"<p>A field width can be applied in a <code>scanf</code> conversion specifier to control how many characters are read from the input stream.</p> <ul> <li>Input is read as groups of digits/characters of the specified width.</li> <li>Useful when parsing fixed-length data such as IDs, phone numbers, or formatted strings.</li> </ul> <p>Example: <code>%2d</code> reads exactly 2 digits into one variable, then <code>%d</code> reads the rest.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    int x = 0;\n    int y = 0;\n\n    printf(\"%s\", \"Enter a six digit integer: \");\n    scanf(\"%2d%d\", &amp;x, &amp;y); // first 2 digits go to x, remaining go to y\n\n    printf(\"The integers input were %d and %d\\n\", x, y);\n    return 0;\n}\n</code></pre> <p>Input: <code>123456</code> \u2192 output: <code>12</code> and <code>3456</code>.</p>"},{"location":"wk_two/#skipping-characters-in-an-input-stream","title":"Skipping Characters in an Input Stream","text":"<p><code>scanf</code> can skip unnecessary characters in the input stream:</p> <ul> <li>Whitespace characters (space, tab, newline) are skipped automatically at the beginning of most format specifiers.</li> <li>Literal characters in the format string (like <code>-</code> or <code>/</code>) must match in the input and are discarded.</li> </ul> <p>Example:</p> <pre><code>scanf(\"%d-%d-%d\", &amp;month, &amp;day, &amp;year);\n</code></pre> <p>Input: <code>11-10-1999</code> \u2192 assigns 11, 10, 1999 while skipping the dashes.</p>"},{"location":"wk_two/#assignment-suppression-character","title":"Assignment Suppression Character","text":"<p>The <code>*</code> assignment suppression character allows <code>scanf</code> to read and discard input without storing it in a variable.</p> <p>Example: <code>%*c</code> reads and discards a single character.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    int month = 0;\n    int day = 0;\n    int year = 0;\n\n    printf(\"%s\", \"Enter a date in the form mm-dd-yyyy: \");\n    scanf(\"%d%*c%d%*c%d\", &amp;month, &amp;day, &amp;year); // ignores separators\n    printf(\"month = %d day = %d year = %d\\n\", month, day, year);\n\n    printf(\"%s\", \"Enter a date in the form mm/dd/yyyy: \");\n    scanf(\"%d%*c%d%*c%d\", &amp;month, &amp;day, &amp;year); // works with /\n    printf(\"month = %d day = %d year = %d\\n\", month, day, year);\n    return 0;\n}\n</code></pre> <p>Input: <code>07-04-2021</code> \u2192 output: <code>7 4 2021</code> Input: <code>01/01/2021</code> \u2192 output: <code>1 1 2021</code></p>"},{"location":"wk_two/#recursion","title":"Recursion","text":"<p>A recursive function is one that calls itself, either directly or indirectly through another function. Recursion is a common but complex topic; here we look at its basic structure.</p>"},{"location":"wk_two/#base-cases-and-recursive-calls","title":"Base Cases and Recursive Calls","text":"<p>A recursive function solves problems by dividing them into:</p> <ul> <li>A base case \u2013 the simplest case the function knows how to solve directly.</li> <li>A recursive case \u2013 a more complex problem broken down into smaller versions of itself.</li> </ul> <p>The recursive case must resemble the original problem but be simpler or smaller, ensuring progress toward the base case. Each recursive call works on the reduced problem until the base case is reached.</p>"},{"location":"wk_two/#recursive-step","title":"Recursive Step","text":"<p>When a recursive call is made:</p> <ul> <li>The function pauses its current execution and launches a fresh copy of itself to handle the smaller problem.</li> <li>This process can repeat many times, generating multiple recursive calls.</li> <li>Each call must eventually converge on the base case, where recursion stops.</li> </ul>"},{"location":"wk_two/#returning-results","title":"Returning Results","text":"<p>Each recursive call includes a <code>return</code> statement. When the base case is reached, the result is returned back to the previous call. This chain of returns continues until the result reaches the original caller.</p> <p>In summary:</p> <ul> <li>Base case: directly solvable, no further recursion.</li> <li>Recursive step: reduces the problem and calls the function again.</li> <li>Convergence: repeated recursion eventually reaches the base case, then unwinds with results.</li> </ul>"},{"location":"wk_two/#example-factorial","title":"Example: Factorial","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint factorial(int n) {\n    if (n == 0) {           // base case\n        return 1;\n    } else {\n        return n * factorial(n - 1); // recursive case\n    }\n}\n\nint main(void) {\n    int num = 5;\n    printf(\"Factorial of %d is %d\\n\", num, factorial(num));\n    return 0;\n}\n</code></pre> <p>Input: <code>5</code> \u2192 Output: <code>120</code></p>"},{"location":"wk_two/#stack-visualization","title":"Stack Visualization","text":"<p>Recursive calls can be visualized as a stack. Each new call is pushed onto the stack showing the pending computation, and results are popped once the base case is reached.</p> <p>Factorial(5):</p> <pre><code>Push (calls):\nFactorial(5) -&gt; 5 * Factorial(4)\n  Factorial(4) -&gt; 4 * Factorial(3)\n    Factorial(3) -&gt; 3 * Factorial(2)\n      Factorial(2) -&gt; 2 * Factorial(1)\n        Factorial(1) -&gt; 1 * Factorial(0)\n          Factorial(0) -&gt; 1  (base case)\n\nPop (returns):\n        Factorial(1) = 1 * Factorial(0) = 1 * 1 = 1\n      Factorial(2) = 2 * Factorial(1) = 2 * 1 = 2\n    Factorial(3) = 3 * Factorial(2) = 3 * 2 = 6\n  Factorial(4) = 4 * Factorial(3) = 4 * 6 = 24\nFactorial(5) = 5 * Factorial(4) = 5 * 24 = 120\n</code></pre>"}]}