{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"COMP2801 - Application Development with C Overview For full course information bcit.ca . Course taken in Fall 2025 term ( outline ) with Bob Langelaan . Midterm and Final in-person 4 quizzes, one each in weeks 3, 5, 8, and 11 right at the start of class 8 labs must be submitted to get a mark for labs There will be 4 assignments The course continues from COMP2701 and just follows C How to Program -- Ninth Edition .","title":"Home"},{"location":"#comp2801-application-development-with-c","text":"","title":"COMP2801 - Application Development with C"},{"location":"#overview","text":"For full course information bcit.ca . Course taken in Fall 2025 term ( outline ) with Bob Langelaan . Midterm and Final in-person 4 quizzes, one each in weeks 3, 5, 8, and 11 right at the start of class 8 labs must be submitted to get a mark for labs There will be 4 assignments The course continues from COMP2701 and just follows C How to Program -- Ninth Edition .","title":"Overview"},{"location":"wk_one/","text":"Week 1 Streams Streams are sequences of bytes used for input and output. Input : Data flows from a device (keyboard, disk, network, etc.) into main memory. Output : Data flows from main memory to a device (screen, printer, disk, network, etc.). At program start, three standard streams are available: Standard input ( stdin ) \u2013 usually from the keyboard. Standard output ( stdout ) \u2013 usually to the screen. Standard error ( stderr ) \u2013 also to the screen, for error messages. Redirection : Operating systems allow these streams to be redirected to other devices or files. printf Formatting As we learned in the previous course, printf can be used to format output to stdout using conversion specifications . We will now take a deeper look at some of the tools available to us. Integers There are a number of different conversion specifiers for integers. Specifier Description %d Signed decimal integer %i Signed decimal integer (same as %d ) %o Unsigned octal integer %u Unsigned decimal integer %x Unsigned hexadecimal integer (lowercase a\u2013f) %X Unsigned hexadecimal integer (uppercase A\u2013F) %hd / %ld / %lld Short, long, or long long integers (length modifiers) Note: if you are using any of the unsigned specifiers, don't pass it any negative numbers. If you are using any of the long length modifiers you should add a corresponding literal suffix ( L , LL ) to the value that you pass to printf . printf(\"%ld\\n\", 5000000000L); // long (suffix L required) printf(\"%lld\\n\", 9000000000000LL); // long long (suffix LL required) Floating-Point Numbers Specifier Description %e / %E Exponential (scientific) notation (e.g., 1.23e+02 or 1.23E+02 ) %f / %F Fixed-point notation %g / %G Uses either %f or %e ( %E ) depending on value\u2019s magnitude, with no trailing zeros %Lf / %Le / %Lg Long double (length modifier L ) The default precision is 6 digits after the decimal (for %f ) or 6 significant digits (for %g / %G ). Rounding : %e , %E , and %g perform rounding; %f shows exact decimals. %g / %G automatically chooses the shortest visual representation for a given number: Chooses %e if the exponent is < -4 or \u2265 precision. Otherwise chooses %f . Removes trailing zeros. Omits the decimal point if the fractional part is zero. #include <stdio.h> int main(void) { printf(\"%g\\n\", 87.0); // 87 // whole number, fractional part is zero so \".0\" is suppressed printf(\"%g\\n\", 87.50); // 87.5 // fractional part kept, trailing zero removed printf(\"%g\\n\", 87.25); // 87.25 // fractional part kept, no trailing zeros to remove printf(\"%g\\n\", 0.0000875); // 8.75e-05 // exponent < -4, so %e format is chosen printf(\"%g\\n\", 8750000.0); // 8.75e+06 // exponent \u2265 precision (6), so %e format is chosen printf(\"%#g\\n\", 87.0); // 87.0000 // '#' flag forces decimal point and trailing zeros up to precision return 0; } Strings and Characters (Review) %c \u2192 prints a single char %s \u2192 prints a null-terminated string ( char* ), stops at '\\0' Missing null terminator or wrong format specifier (e.g., %s with a char ) \u2192 undefined behavior, often a crash Compilers usually don\u2019t catch format string errors \u2014 they show up only at runtime. Pointers Specifier Description %p Displays a pointer (address) in an implementation-defined way (commonly hexadecimal) %p expects a pointer argument (e.g., &x , or a char* , int* , etc.). The exact format of the address depends on the system, but is typically hexadecimal. Useful for debugging to confirm memory addresses. Field Width You can control the minimum number of characters used when printing a value by specifying a field width . If the value has fewer characters than the field width then it is padded (by default with spaces). Note : If the value has more characters than the field width then the full value is printed (field width is ignored). That is to say, it does not truncate the output. #include <stdio.h> int main(void) { printf(\"%4d\\n\", 1); // 1 printf(\"%4d\\n\", 12); // 12 printf(\"%4d\\n\", 123); // 123 printf(\"%4d\\n\", 1234); // 1234 printf(\"%4d\\n\", 12345); // 12345 (too wide, prints fully) printf(\"%4d\\n\", -1); // -1 printf(\"%4d\\n\", -12); // -12 printf(\"%4d\\n\", -123); // -123 printf(\"%4d\\n\", -1234); // -1234 printf(\"%4d\\n\", -12345); // -12345 } Negative Values If the value has a negative sign, it will use up one of the field width characters: #include <stdio.h> int main(void) { printf(\"BEFORE%4dAFTER\\n\", 1); //BEFORE 1AFTER printf(\"BEFORE%4dAFTER\\n\", -1); //BEFORE -1AFTER // In the second example, there are only 2 spaces. } Dynamic Widths Instead of providing a number, you can pass * instead and then supply the width as one of the values passed instead. This works for precision as well. printf(\"BEFORE%*.*fAFTER\", 7, 2, 98.736); // BEFORE 98.74AFTER // 7 \u2192 total field width (minimum size, includes digits, decimal point, and padding) // 2 \u2192 precision (number of digits after the decimal point) Format Flags Alignment By default, values are right-aligned in the field. To make them left-aligned , add a - before the field width: #include <stdio.h> int main(void) { printf(\"BEFORE%4dAFTER\\n\", 1); //BEFORE 1AFTER printf(\"BEFORE%-4dAFTER\\n\", 1); //BEFORE1 AFTER } Sign Control (for numbers) By default, only negative numbers are printed with a sign ( - ). You can control how positive numbers appear using flags: + : always print a sign ( + for positive, - for negative). space ( ' ' ): print a space in front of positive numbers (negative numbers still get - ). This can be useful for aligning columns of positive and negative numbers. #include <stdio.h> int main(void) { printf(\"%d\\n\", 42); // 42 printf(\"%+d\\n\", 42); // +42 printf(\"% d\\n\", 42); // 42 (leading space) printf(\"%d\\n\", -42); // -42 printf(\"%+d\\n\", -42); // -42 printf(\"% d\\n\", -42); // -42 } Alternate Form (# Flag) The # flag modifies how certain values are displayed: Octal ( %o ) : prefixes the value with 0 . Hexadecimal ( %x / %X ) : prefixes the value with 0x or 0X . Floating-point ( %f , %e , %E , %g , %G ) : forces a decimal point to appear, even if the fractional part is zero. For %g / %G , it also prevents trailing zeros from being removed. Example #include <stdio.h> int main(void) { int c = 1427; double p = 1427.0; printf(\"%o\\n\", c); // 2623 printf(\"%#o\\n\", c); // 02623 printf(\"%x\\n\", c); // 593 printf(\"%#x\\n\", c); // 0x593 printf(\"%X\\n\", c); // 593 printf(\"%#X\\n\", c); // 0X593 printf(\"%g\\n\", p); // 1427 printf(\"%#g\\n\", p); // 1427.00 (decimal point forced, trailing zeros kept) }","title":"Week 1 - Introduction to C & Data Types"},{"location":"wk_one/#week-1","text":"","title":"Week 1"},{"location":"wk_one/#streams","text":"Streams are sequences of bytes used for input and output. Input : Data flows from a device (keyboard, disk, network, etc.) into main memory. Output : Data flows from main memory to a device (screen, printer, disk, network, etc.). At program start, three standard streams are available: Standard input ( stdin ) \u2013 usually from the keyboard. Standard output ( stdout ) \u2013 usually to the screen. Standard error ( stderr ) \u2013 also to the screen, for error messages. Redirection : Operating systems allow these streams to be redirected to other devices or files.","title":"Streams"},{"location":"wk_one/#printf-formatting","text":"As we learned in the previous course, printf can be used to format output to stdout using conversion specifications . We will now take a deeper look at some of the tools available to us.","title":"printf Formatting"},{"location":"wk_one/#integers","text":"There are a number of different conversion specifiers for integers. Specifier Description %d Signed decimal integer %i Signed decimal integer (same as %d ) %o Unsigned octal integer %u Unsigned decimal integer %x Unsigned hexadecimal integer (lowercase a\u2013f) %X Unsigned hexadecimal integer (uppercase A\u2013F) %hd / %ld / %lld Short, long, or long long integers (length modifiers) Note: if you are using any of the unsigned specifiers, don't pass it any negative numbers. If you are using any of the long length modifiers you should add a corresponding literal suffix ( L , LL ) to the value that you pass to printf . printf(\"%ld\\n\", 5000000000L); // long (suffix L required) printf(\"%lld\\n\", 9000000000000LL); // long long (suffix LL required)","title":"Integers"},{"location":"wk_one/#floating-point-numbers","text":"Specifier Description %e / %E Exponential (scientific) notation (e.g., 1.23e+02 or 1.23E+02 ) %f / %F Fixed-point notation %g / %G Uses either %f or %e ( %E ) depending on value\u2019s magnitude, with no trailing zeros %Lf / %Le / %Lg Long double (length modifier L ) The default precision is 6 digits after the decimal (for %f ) or 6 significant digits (for %g / %G ). Rounding : %e , %E , and %g perform rounding; %f shows exact decimals. %g / %G automatically chooses the shortest visual representation for a given number: Chooses %e if the exponent is < -4 or \u2265 precision. Otherwise chooses %f . Removes trailing zeros. Omits the decimal point if the fractional part is zero. #include <stdio.h> int main(void) { printf(\"%g\\n\", 87.0); // 87 // whole number, fractional part is zero so \".0\" is suppressed printf(\"%g\\n\", 87.50); // 87.5 // fractional part kept, trailing zero removed printf(\"%g\\n\", 87.25); // 87.25 // fractional part kept, no trailing zeros to remove printf(\"%g\\n\", 0.0000875); // 8.75e-05 // exponent < -4, so %e format is chosen printf(\"%g\\n\", 8750000.0); // 8.75e+06 // exponent \u2265 precision (6), so %e format is chosen printf(\"%#g\\n\", 87.0); // 87.0000 // '#' flag forces decimal point and trailing zeros up to precision return 0; }","title":"Floating-Point Numbers"},{"location":"wk_one/#strings-and-characters-review","text":"%c \u2192 prints a single char %s \u2192 prints a null-terminated string ( char* ), stops at '\\0' Missing null terminator or wrong format specifier (e.g., %s with a char ) \u2192 undefined behavior, often a crash Compilers usually don\u2019t catch format string errors \u2014 they show up only at runtime.","title":"Strings and Characters (Review)"},{"location":"wk_one/#pointers","text":"Specifier Description %p Displays a pointer (address) in an implementation-defined way (commonly hexadecimal) %p expects a pointer argument (e.g., &x , or a char* , int* , etc.). The exact format of the address depends on the system, but is typically hexadecimal. Useful for debugging to confirm memory addresses.","title":"Pointers"},{"location":"wk_one/#field-width","text":"You can control the minimum number of characters used when printing a value by specifying a field width . If the value has fewer characters than the field width then it is padded (by default with spaces). Note : If the value has more characters than the field width then the full value is printed (field width is ignored). That is to say, it does not truncate the output. #include <stdio.h> int main(void) { printf(\"%4d\\n\", 1); // 1 printf(\"%4d\\n\", 12); // 12 printf(\"%4d\\n\", 123); // 123 printf(\"%4d\\n\", 1234); // 1234 printf(\"%4d\\n\", 12345); // 12345 (too wide, prints fully) printf(\"%4d\\n\", -1); // -1 printf(\"%4d\\n\", -12); // -12 printf(\"%4d\\n\", -123); // -123 printf(\"%4d\\n\", -1234); // -1234 printf(\"%4d\\n\", -12345); // -12345 }","title":"Field Width"},{"location":"wk_one/#negative-values","text":"If the value has a negative sign, it will use up one of the field width characters: #include <stdio.h> int main(void) { printf(\"BEFORE%4dAFTER\\n\", 1); //BEFORE 1AFTER printf(\"BEFORE%4dAFTER\\n\", -1); //BEFORE -1AFTER // In the second example, there are only 2 spaces. }","title":"Negative Values"},{"location":"wk_one/#dynamic-widths","text":"Instead of providing a number, you can pass * instead and then supply the width as one of the values passed instead. This works for precision as well. printf(\"BEFORE%*.*fAFTER\", 7, 2, 98.736); // BEFORE 98.74AFTER // 7 \u2192 total field width (minimum size, includes digits, decimal point, and padding) // 2 \u2192 precision (number of digits after the decimal point)","title":"Dynamic Widths"},{"location":"wk_one/#format-flags","text":"","title":"Format Flags"},{"location":"wk_one/#alignment","text":"By default, values are right-aligned in the field. To make them left-aligned , add a - before the field width: #include <stdio.h> int main(void) { printf(\"BEFORE%4dAFTER\\n\", 1); //BEFORE 1AFTER printf(\"BEFORE%-4dAFTER\\n\", 1); //BEFORE1 AFTER }","title":"Alignment"},{"location":"wk_one/#sign-control-for-numbers","text":"By default, only negative numbers are printed with a sign ( - ). You can control how positive numbers appear using flags: + : always print a sign ( + for positive, - for negative). space ( ' ' ): print a space in front of positive numbers (negative numbers still get - ). This can be useful for aligning columns of positive and negative numbers. #include <stdio.h> int main(void) { printf(\"%d\\n\", 42); // 42 printf(\"%+d\\n\", 42); // +42 printf(\"% d\\n\", 42); // 42 (leading space) printf(\"%d\\n\", -42); // -42 printf(\"%+d\\n\", -42); // -42 printf(\"% d\\n\", -42); // -42 }","title":"Sign Control (for numbers)"},{"location":"wk_one/#alternate-form-flag","text":"The # flag modifies how certain values are displayed: Octal ( %o ) : prefixes the value with 0 . Hexadecimal ( %x / %X ) : prefixes the value with 0x or 0X . Floating-point ( %f , %e , %E , %g , %G ) : forces a decimal point to appear, even if the fractional part is zero. For %g / %G , it also prevents trailing zeros from being removed.","title":"Alternate Form (# Flag)"},{"location":"wk_one/#example","text":"#include <stdio.h> int main(void) { int c = 1427; double p = 1427.0; printf(\"%o\\n\", c); // 2623 printf(\"%#o\\n\", c); // 02623 printf(\"%x\\n\", c); // 593 printf(\"%#x\\n\", c); // 0x593 printf(\"%X\\n\", c); // 593 printf(\"%#X\\n\", c); // 0X593 printf(\"%g\\n\", p); // 1427 printf(\"%#g\\n\", p); // 1427.00 (decimal point forced, trailing zeros kept) }","title":"Example"}]}