{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"COMP2801 - Application Development with C","text":""},{"location":"#overview","title":"Overview","text":"<p>For full course information bcit.ca. Course taken in Fall 2025 term (outline) with Bob Langelaan.</p> <ul> <li>Midterm and Final in-person</li> <li>4 quizzes, one each in weeks 3, 5, 8, and 11<ul> <li>right at the start of class</li> </ul> </li> <li>8 labs<ul> <li>must be submitted to get a mark for labs</li> </ul> </li> <li>There will be 4 assignments</li> </ul> <p>The course continues from COMP2701 and just follows C How to Program -- Ninth Edition.</p>"},{"location":"wk_one/","title":"Week 1","text":"<p>This week covers the first half of Chapter 9 in the text. We look in depth at <code>printf</code> formatting including specifiers, field widths, formatting flags, and escape sequences which all help control how output is displayed.</p>"},{"location":"wk_one/#streams","title":"Streams","text":"<p>Streams are sequences of bytes used for input and output.</p> <ul> <li>Input: Data flows from a device (keyboard, disk, network, etc.) into main memory.</li> <li>Output: Data flows from main memory to a device (screen, printer, disk, network, etc.).</li> </ul> <p>At program start, three standard streams are available:</p> <ol> <li>Standard input (<code>stdin</code>) \u2013 usually from the keyboard.</li> <li>Standard output (<code>stdout</code>) \u2013 usually to the screen.</li> <li>Standard error (<code>stderr</code>) \u2013 also to the screen, for error messages.</li> </ol> <p>Redirection: Operating systems allow these streams to be redirected to other devices or files.</p>"},{"location":"wk_one/#printf-formatting","title":"<code>printf</code> Formatting","text":"<p>As we learned in the previous course, <code>printf</code> can be used to format output to <code>stdout</code> using conversion specifications.</p>"},{"location":"wk_one/#type-specifiers","title":"Type Specifiers","text":""},{"location":"wk_one/#integers","title":"Integers","text":"Specifier Description <code>%d</code> Signed decimal integer <code>%i</code> Signed decimal integer (same as <code>%d</code>) <code>%o</code> Unsigned octal integer <code>%u</code> Unsigned decimal integer <code>%x</code> Unsigned hexadecimal integer (lowercase a\u2013f) <code>%X</code> Unsigned hexadecimal integer (uppercase A\u2013F) <code>%hd</code> / <code>%ld</code> / <code>%lld</code> Short, long, or long long integers (length modifiers) <p>Note: if you are using any of the unsigned specifiers, don't pass it any negative numbers.</p> <p>If you are using any of the long length modifiers you should add a corresponding literal suffix (<code>L</code>, <code>LL</code>) to the value that you pass to <code>printf</code>.</p> <pre><code>printf(\"%ld\\n\", 5000000000L); // long (suffix L required)\nprintf(\"%lld\\n\", 9000000000000LL); // long long (suffix LL required)\n</code></pre>"},{"location":"wk_one/#floating-point-numbers","title":"Floating-Point Numbers","text":"Specifier Description <code>%e</code> / <code>%E</code> Exponential (scientific) notation (e.g., <code>1.23e+02</code> or <code>1.23E+02</code>) <code>%f</code> / <code>%F</code> Fixed-point notation <code>%g</code> / <code>%G</code> Uses either <code>%f</code> or <code>%e</code> (<code>%E</code>) depending on value\u2019s magnitude, with no trailing zeros <code>%Lf</code> / <code>%Le</code> / <code>%Lg</code> Long double (length modifier <code>L</code>) <p>The default precision is 6 digits after the decimal (for <code>%f</code>) or 6 significant digits (for <code>%g</code>/<code>%G</code>).</p> <p>Rounding: <code>%e</code>, <code>%E</code>, and <code>%g</code> perform rounding; <code>%f</code> shows exact decimals.</p> <p><code>%g</code>/<code>%G</code> automatically chooses the shortest visual representation for a given number:</p> <ul> <li>Chooses <code>%e</code> if the exponent is &lt; -4 or \u2265 precision.</li> <li>Otherwise chooses <code>%f</code>.</li> <li>Removes trailing zeros.</li> <li>Omits the decimal point if the fractional part is zero.</li> </ul> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"%g\\n\", 87.0);        // 87\n    // whole number, fractional part is zero so \".0\" is suppressed\n\n    printf(\"%g\\n\", 87.50);       // 87.5\n    // fractional part kept, trailing zero removed\n\n    printf(\"%g\\n\", 87.25);       // 87.25\n    // fractional part kept, no trailing zeros to remove\n\n    printf(\"%g\\n\", 0.0000875);   // 8.75e-05\n    // exponent &lt; -4, so %e format is chosen\n\n    printf(\"%g\\n\", 8750000.0);   // 8.75e+06\n    // exponent \u2265 precision (6), so %e format is chosen\n\n    printf(\"%#g\\n\", 87.0);       // 87.0000\n    // '#' flag forces decimal point and trailing zeros up to precision\n\n    return 0;\n}\n</code></pre>"},{"location":"wk_one/#strings-and-characters","title":"Strings and Characters","text":"<ul> <li><code>%c</code> prints a single <code>char</code></li> <li><code>%s</code> prints a null-terminated string (<code>char*</code>), stops at <code>\\0</code></li> <li>Missing null terminator or wrong format specifier (e.g., <code>%s</code> with a <code>char</code>) undefined behavior, often a crash</li> <li>Compilers usually don\u2019t catch format string errors \u2014 they show up only at runtime.</li> </ul>"},{"location":"wk_one/#pointers","title":"Pointers","text":"Specifier Description <code>%p</code> Displays a pointer (address) in an implementation-defined way (commonly hexadecimal) <p><code>%p</code> expects a pointer argument (e.g., <code>&amp;x</code>, or a <code>char*</code>, <code>int*</code>, etc.). The exact format of the address depends on the system, but is typically hexadecimal. Useful for debugging to confirm memory addresses.</p>"},{"location":"wk_one/#field-width","title":"Field Width","text":"<p>You can control the minimum number of characters used when printing a value by specifying a field width.</p> <p>If the value has fewer characters than the field width then it is padded (by default with spaces).</p> <p>Note: If the value has more characters than the field width then the full value is printed (field width is ignored). That is to say, it does not truncate the output.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"%4d\\n\", 1);       //    1\n    printf(\"%4d\\n\", 12);      //   12\n    printf(\"%4d\\n\", 123);     //  123\n    printf(\"%4d\\n\", 1234);    // 1234\n    printf(\"%4d\\n\", 12345);   // 12345 (too wide, prints fully)\n\n    printf(\"%4d\\n\", -1);      //   -1\n    printf(\"%4d\\n\", -12);     //  -12\n    printf(\"%4d\\n\", -123);    // -123\n    printf(\"%4d\\n\", -1234);   // -1234\n    printf(\"%4d\\n\", -12345);  // -12345\n}\n</code></pre>"},{"location":"wk_one/#negative-values","title":"Negative Values","text":"<p>If the value has a negative sign, it will use up one of the field width characters:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"BEFORE%4dAFTER\\n\", 1);        //BEFORE   1AFTER\n    printf(\"BEFORE%4dAFTER\\n\", -1);       //BEFORE  -1AFTER\n    // In the second example, there are only 2 spaces.\n}\n</code></pre>"},{"location":"wk_one/#dynamic-widths","title":"Dynamic Widths","text":"<p>Instead of providing a number, you can pass <code>*</code> instead and then supply the width as one of the values passed instead.</p> <p>This works for precision as well.</p> <pre><code>printf(\"BEFORE%*.*fAFTER\", 7, 2, 98.736); // BEFORE  98.74AFTER\n// 7 \u2192 total field width (minimum size, includes digits, decimal point, and padding)\n// 2 \u2192 precision (number of digits after the decimal point)\n</code></pre>"},{"location":"wk_one/#format-flags","title":"Format Flags","text":""},{"location":"wk_one/#alignment","title":"Alignment","text":"<p>By default, values are right-aligned in the field. To make them left-aligned, add a <code>-</code> before the field width:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"BEFORE%4dAFTER\\n\", 1);        //BEFORE   1AFTER\n    printf(\"BEFORE%-4dAFTER\\n\", 1);       //BEFORE1   AFTER\n}\n</code></pre>"},{"location":"wk_one/#sign-control-for-numbers","title":"Sign Control (for numbers)","text":"<p>By default, only negative numbers are printed with a sign (<code>-</code>). You can control how positive numbers appear using flags:</p> <ul> <li><code>+</code>: always print a sign (<code>+</code> for positive, <code>-</code> for negative).</li> <li>space (<code>' '</code>): print a space in front of positive numbers (negative numbers still get <code>-</code>).</li> </ul> <p>This can be useful for aligning columns of positive and negative numbers.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"%d\\n\", 42);     // 42\n    printf(\"%+d\\n\", 42);    // +42\n    printf(\"% d\\n\", 42);    //  42 (leading space)\n    printf(\"%d\\n\", -42);    // -42\n    printf(\"%+d\\n\", -42);   // -42\n    printf(\"% d\\n\", -42);   // -42\n}\n</code></pre>"},{"location":"wk_one/#alternate-form-flag","title":"Alternate Form (# Flag)","text":"<p>The <code>#</code> flag modifies how certain values are displayed:</p> <ul> <li>Octal (<code>%o</code>): prefixes the value with <code>0</code>.</li> <li>Hexadecimal (<code>%x</code> / <code>%X</code>): prefixes the value with <code>0x</code> or <code>0X</code>.</li> <li> <p>Floating-point (<code>%f</code>, <code>%e</code>, <code>%E</code>, <code>%g</code>, <code>%G</code>): forces a decimal point to appear, even if the fractional part is zero.</p> </li> <li> <p>For <code>%g</code> / <code>%G</code>, it also prevents trailing zeros from being removed.</p> </li> </ul> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    int c = 1427;\n    double p = 1427.0;\n\n    printf(\"%o\\n\", c);    // 2623\n    printf(\"%#o\\n\", c);   // 02623\n\n    printf(\"%x\\n\", c);    // 593\n    printf(\"%#x\\n\", c);   // 0x593\n\n    printf(\"%X\\n\", c);    // 593\n    printf(\"%#X\\n\", c);   // 0X593\n\n    printf(\"%g\\n\", p);    // 1427\n    printf(\"%#g\\n\", p);   // 1427.00 (decimal point forced, trailing zeros kept)\n}\n</code></pre>"},{"location":"wk_one/#zero-padding-0-flag","title":"Zero Padding (0 Flag)","text":"<p>By default, extra space in a field width is filled with spaces. The <code>0</code> flag changes this so that extra space is filled with leading zeros.</p> <ul> <li>Works with integers and floating-point numbers.</li> <li>Often combined with the <code>+</code> flag to show signs with padded numbers.</li> <li>Padding occurs after the sign, not before.</li> </ul>"},{"location":"wk_one/#example","title":"Example","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"%9d\\n\", 452);     // \"      452\" (spaces)\n    printf(\"%09d\\n\", 452);    // \"000000452\" (zeros)\n\n    printf(\"%+09d\\n\", 452);   // \"+00000452\"\n    printf(\"%09d\\n\", -452);   // \"-00000452\"\n}\n</code></pre>"},{"location":"wk_one/#literals-and-escape-sequences","title":"Literals and Escape Sequences","text":"<p>Characters in a format string that are not part of a conversion specification are printed literally.</p> <p>Escape sequences allow you to include special characters in strings that cannot be typed directly or would otherwise be ambiguous.</p> Escape Description <code>\\'</code> Single quote (<code>'</code>) <code>\\\"</code> Double quote (<code>\"</code>) <code>\\?</code> Question mark (<code>?</code>) <code>\\\\</code> Backslash (<code>\\\\</code>) <code>\\a</code> Alert (bell/flash) <code>\\b</code> Backspace <code>\\f</code> Form feed (new page) <code>\\n</code> Newline <code>\\r</code> Carriage return <code>\\t</code> Horizontal tab <code>\\v</code> Vertical tab <code>%%</code> Percent symbol (<code>%</code>) <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Hello\\tWorld\\n\");     // tab between words, newline at end\n    printf(\"Path: C:\\\\temp\\n\");   // prints: Path: C:\\temp\n    printf(\"Beep!\\a\\n\");          // may cause a sound or window flash\n    printf(\"CPU usage: 95%%\\n\");  // CPU usage: 95%\n}\n</code></pre> Why <code>%%</code> isn\u2019t like <code>\\\\n</code> <p>Backslash escapes (like <code>\\\\n</code>, <code>\\\\t</code>, <code>\\\\?</code>) are language features handled at compile time, because they solve parsing or representation issues in string literals.</p> <pre><code>Percent escapes (like `%d`, `%%`) are **library features**, defined only for functions such as `printf`/`scanf` and interpreted at runtime.\n\n**In short:** `\\\\n` is replaced by the compiler, while `%%` is handled later by `printf`.\n</code></pre>"},{"location":"wk_three/","title":"Week 3","text":"<p>This week covers structures and typedefs.</p>"},{"location":"wk_three/#structures","title":"Structures","text":"<p>A structure is a collection of related variables grouped under one name. In the C standard, structures are referred to as aggregates.</p> <p>The <code>struct</code> keyword is used to define a structure type:</p> <pre><code>// A structure for representing a playing card.\nstruct card {\n    const char *face;\n    const char *suit;\n};  // Note: a semicolon is required after the closing brace.\n</code></pre> <p>The example above defines a new structure type named <code>card</code>. The variables declared inside the braces (<code>face</code> and <code>suit</code>) are called members.</p> <p>Since this type definition is a declaration, a semicolon must follow the  closing brace.</p>"},{"location":"wk_three/#member-types","title":"Member Types","text":"<p>Structures can contain members of different types. However, a structure cannot contain a member that is an instance of its own type. For example, the following is invalid:</p> <pre><code>// Invalid: a structure cannot contain an instance of itself.\nstruct card {\n    const char *face;\n    const char *suit;\n    struct card nextCard;  // Invalid\n};\n</code></pre> <p>To work around this, use a pointer to the same type:</p> <pre><code>// Valid: a structure can contain a pointer to its own type.\nstruct card {\n    const char *face;\n    const char *suit;\n    struct card *nextCard;  // Valid\n};\n</code></pre> <p>This pattern is commonly used for creating nodes in a linked list.</p>"},{"location":"wk_three/#defining-variables-of-structure-types","title":"Defining Variables of Structure Types","text":"<p>Structure definitions alone only create a new type that can be used later in  code; they do not reserve any space in memory. A structure definition is  essentially a blueprint. To begin reserving memory for variables, use the  following syntax:</p> <pre><code>// create a new card struct\nstruct card myCard;\n\n// or create an array of card structs\nstruct card deck[52];\n\n// or create a pointer to a card struct\nstruct card *cardPtr;\n</code></pre> <p>You can also create variables of a struct during the definition of the struct  by providing a comma-separated list of variable names after the closing  brace of the struct but before the ending semicolon of the declaration:</p> <pre><code>struct card {\n    const char *face;\n    const char *suit;\n} myCard, deck[52], *cardPtr;\n</code></pre>"},{"location":"wk_three/#structures-without-tag-names","title":"Structures without Tag Names","text":"<p>You can define a struct without a tag name:</p> <pre><code>struct {    // NOTE: no \"card\" tag name\n    const char *face;\n    const char *suit;\n} exampleCard;\n</code></pre> <p>However, without a tag name, you cannot declare additional variables of this  type later in the program. Therefore, you must provide variable names during the declaration to use them.</p> <pre><code>// This defines and declares two variables immediately.\nstruct {\n    int x;\n    int y;\n} point1, point2;\n</code></pre>"},{"location":"wk_three/#comparing-structure-objects","title":"Comparing Structure Objects","text":"<p>Structures cannot be compared using the operators <code>==</code> or <code>!=</code> because  structure members may not be stored in consecutive bytes of memory. Compilers  often insert padding bytes (known as holes) to align data members according  to their type\u2019s alignment requirements.</p> <p>These holes can contain garbage values, which would cause comparisons between  two otherwise identical structures to fail.</p> Detailed example <p>Suppose we have a struct defined as follows, with two variables of that type named <code>sample1</code> and <code>sample2</code>.</p> <pre><code>struct example {\n    char c;\n    int i;\n} sample1, sample2;\n</code></pre> <p>Initially, the variables contain garbage values:</p> <p></p> <p>We then assign values to the members of <code>sample1</code>:</p> <pre><code>sample1.c = 'G';\nsample1.i = 42069;\n</code></pre> <p></p> <p>Notice that the <code>int</code> portion begins at byte 4. This is because integers must align on a 4-byte boundary, leaving a gap in bytes 1\u20133.</p> <p>Next, we assign the same values to the members of <code>sample2</code>:</p> <pre><code>sample2.c = 'G';\nsample2.i = 42069;\n</code></pre> <p></p> <p>When comparing the two, the visible members appear equivalent, but the hidden padding bytes contain different values. Therefore, the two structs are not equal when compared byte-for-byte.</p> <p></p> <p></p>"},{"location":"wk_three/#using-sizeof-with-structures","title":"Using <code>sizeof</code> with Structures","text":"<p>The <code>sizeof</code> operator can be used to determine the amount of memory a structure occupies. However, the value returned by <code>sizeof</code> a structure often exceeds the sum of its members' sizes due to padding and alignment.</p> <p>For example:</p> <pre><code>struct example {\n    char c;\n    int i;\n};\n\nprintf(\"%zu\\n\", sizeof(struct example));  // Likely prints 8, not 5\n</code></pre> <p>The <code>sizeof</code> value includes both the member data and any extra bytes the compiler adds to satisfy memory alignment requirements.</p> <p>Structure packing and alignment</p> <p>When structures are stored in memory, the compiler may insert padding bytes  between members to align data according to hardware requirements. This  improves access performance but can waste space.</p> <p>You can minimize wasted space by ordering structure members from largest to  smallest type (for example, <code>double</code> then <code>int</code> then <code>char</code>).</p> <p>Some compilers provide directives like <code>#pragma pack</code> to override default  alignment and reduce padding. However, this is compiler-specific and  may lead to portability or performance issues. </p> <p>It is generally recommended to avoid using <code>#pragma pack</code> unless you  have a clear and justified need, such as matching external binary data formats.</p>"},{"location":"wk_three/#typedef","title":"<code>typedef</code>","text":"<p><code>typedef</code> allows you to create synonyms (or aliases) for previously defined types.</p> <p>It is commonly used to create shorter names for struct types and simplify declarations of types like function pointers.</p> <p>Tip</p> <p>You can use typedef to avoid retyping out struct card each time you create a new variable of type card.</p> <pre><code>typedef struct card Card;\n// you can now declare a new card struct as follows\nCard newCard;\n</code></pre>"},{"location":"wk_three/#combining-typedef-with-struct-definitions","title":"Combining <code>typedef</code> with <code>struct</code> Definitions","text":"<p>You combine <code>typedef</code> with a <code>struct</code> declaration to clean up your code.</p> <p>Note</p> <pre><code>// basic struct definition\nstruct card {\nconst char *face;\nconst char *suit\n};\n\n// typedef struct definition\ntypedef struct {\nconst char *face;\nconst char *suit;\n} Card2;\n\n// create an instance of each\nstruct card newCardUsingBasicStruct;\nCard2 newCardUsingTypeDef;\n</code></pre> <p>This method helps to avoid rewriting struct all the time and makes it clear  when you are defining a struct and when you are using the type created by the  struct.</p>"},{"location":"wk_three/#combining-typedef-with-struct-definitions_1","title":"Combining <code>typedef</code> with <code>struct</code> Definitions","text":"<p>You can combine <code>typedef</code> with a <code>struct</code> declaration to make your code cleaner and more readable.</p> <p>Note</p> <pre><code>// Basic struct definition\nstruct card {\nconst char *face;\nconst char *suit;\n};\n\n// typedef struct definition\ntypedef struct {\n    const char *face;\n    const char *suit;\n} Card;\n\n// Create an instance of each\nstruct card basicCard;\nCard typeDefCard;\n</code></pre> <p>Using <code>typedef</code> in this way eliminates the need to repeatedly write <code>struct</code> when declaring variables and clearly separates the definition of the structure from its use as a type.</p>"},{"location":"wk_two/","title":"Week 2","text":"<p>This week covers formatted input using <code>scanf</code> and recursion.</p>"},{"location":"wk_two/#formatted-input-with-scanf","title":"Formatted Input with <code>scanf</code>","text":"<p><code>scanf</code> statements contain a format control string that specifies how input should be read, followed by pointers to variables where the input will be stored.</p> <p>Key capabilities:</p> <ol> <li>Inputting all types of data.</li> <li>Inputting specific characters from an input stream.</li> <li>Skipping specific characters in an input stream.</li> </ol>"},{"location":"wk_two/#scanf-syntax","title":"<code>scanf</code> Syntax","text":"<pre><code>scanf(format-control-string, other-arguments);\n</code></pre> <p>format-control-string \u2013 describes input formats using conversion specifiers. other-arguments \u2013 pointers to variables that will receive the input.</p> <p> * Prompt the user for one (or a few) items at a time. * Avoid asking for many inputs in one statement. * Always handle the possibility of incorrect data (e.g., invalid integers or   strings with missing punctuation).</p>"},{"location":"wk_two/#conversion-specifiers","title":"Conversion Specifiers","text":"<p>Like <code>printf</code>, <code>scanf</code> uses conversion specifiers to handle different data types. Some specifiers differ between input (<code>scanf</code>) and output (<code>printf</code>).</p> Specifier Description Integers <code>%d</code> Reads a signed decimal integer  <code>int*</code> <code>%i</code> Reads signed decimal, octal, or hexadecimal  <code>int*</code> <code>%o</code> Reads an octal integer  <code>unsigned int*</code> <code>%u</code> Reads an unsigned decimal integer  <code>unsigned int*</code> <code>%x</code> / <code>%X</code> Reads a hexadecimal integer  <code>unsigned int*</code> <code>h</code>, <code>l</code>, <code>ll</code> Length modifiers (<code>short</code>, <code>long</code>, <code>long long</code>) for integers Floating-point <code>%e</code>, <code>%E</code>, <code>%f</code>, <code>%F</code>, <code>%g</code>, <code>%G</code> Reads a floating-point value  <code>float*</code> / <code>double*</code> <code>l</code> or <code>L</code> Length modifiers for <code>double</code> or <code>long double</code> Characters &amp; Strings <code>%c</code> Reads a single character  <code>char*</code> (no <code>\\0</code> added) <code>%s</code> Reads a string  <code>char[]</code> (terminates with <code>\\0</code>) Scan set <code>%[...]</code> Reads a set of characters into a string Miscellaneous <code>%p</code> Reads an address (pointer format) <code>%n</code> Stores number of characters read so far  <code>int*</code> <code>%%</code> Skips a literal <code>%</code> in input"},{"location":"wk_two/#using-scan-sets","title":"Using Scan Sets","text":"<p>A scan set allows input of only certain characters, defined inside square brackets <code>[]</code> after a <code>%</code> in the format string. Input continues until a character not in the scan set is encountered.</p> <p>Example: using <code>%[aeiou]</code> reads only vowels.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char z[9] = \"\";\n    printf(\"%s\", \"Enter string: \");\n    scanf(\"%8[aeiou]\", z); // only vowels\n    printf(\"The input was \\\"%s\\\"\\n\", z);\n    return 0;\n}\n</code></pre> <p>Input: <code>oeeeooahah</code> \u2192 stops at <code>h</code>, outputs <code>oeeeooa</code>.</p>"},{"location":"wk_two/#inverting-the-scan-set","title":"Inverting the Scan Set","text":"<p>An inverted scan set matches characters not in the given set. Use a <code>^</code> inside the brackets to invert.</p> <p>Example: <code>%[^aeiou]</code> reads only consonants and other non-vowels.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char z[9] = \"\";\n    printf(\"%s\", \"Enter a string: \");\n    scanf(\"%8[^aeiou]\", z); // non-vowels\n    printf(\"The input was \\\"%s\\\"\\n\", z);\n    return 0;\n}\n</code></pre> <p>Input: <code>String</code> \u2192 stops at vowel <code>i</code>, outputs <code>Str</code>.</p>"},{"location":"wk_two/#using-field-widths","title":"Using Field Widths","text":"<p>A field width can be applied in a <code>scanf</code> conversion specifier to control how many characters are read from the input stream.</p> <ul> <li>Input is read as groups of digits/characters of the specified width.</li> <li>Useful when parsing fixed-length data such as IDs, phone numbers, or formatted strings.</li> </ul> <p>Example: <code>%2d</code> reads exactly 2 digits into one variable, then <code>%d</code> reads the rest.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    int x = 0;\n    int y = 0;\n\n    printf(\"%s\", \"Enter a six digit integer: \");\n    scanf(\"%2d%d\", &amp;x, &amp;y); // first 2 digits go to x, remaining go to y\n\n    printf(\"The integers input were %d and %d\\n\", x, y);\n    return 0;\n}\n</code></pre> <p>Input: <code>123456</code> \u2192 output: <code>12</code> and <code>3456</code>.</p>"},{"location":"wk_two/#skipping-characters-in-an-input-stream","title":"Skipping Characters in an Input Stream","text":"<p><code>scanf</code> can skip unnecessary characters in the input stream:</p> <ul> <li>Whitespace characters (space, tab, newline) are skipped automatically at the beginning of most format specifiers.</li> <li>Literal characters in the format string (like <code>-</code> or <code>/</code>) must match in the input and are discarded.</li> </ul> <p>Example:</p> <pre><code>scanf(\"%d-%d-%d\", &amp;month, &amp;day, &amp;year);\n</code></pre> <p>Input: <code>11-10-1999</code> \u2192 assigns 11, 10, 1999 while skipping the dashes.</p>"},{"location":"wk_two/#assignment-suppression-character","title":"Assignment Suppression Character","text":"<p>The <code>*</code> assignment suppression character allows <code>scanf</code> to read and discard input without storing it in a variable.</p> <p>Example: <code>%*c</code> reads and discards a single character.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    int month = 0;\n    int day = 0;\n    int year = 0;\n\n    printf(\"%s\", \"Enter a date in the form mm-dd-yyyy: \");\n    scanf(\"%d%*c%d%*c%d\", &amp;month, &amp;day, &amp;year); // ignores separators\n    printf(\"month = %d day = %d year = %d\\n\", month, day, year);\n\n    printf(\"%s\", \"Enter a date in the form mm/dd/yyyy: \");\n    scanf(\"%d%*c%d%*c%d\", &amp;month, &amp;day, &amp;year); // works with /\n    printf(\"month = %d day = %d year = %d\\n\", month, day, year);\n    return 0;\n}\n</code></pre> <p>Input: <code>07-04-2021</code> \u2192 output: <code>7 4 2021</code> Input: <code>01/01/2021</code> \u2192 output: <code>1 1 2021</code></p>"},{"location":"wk_two/#recursion","title":"Recursion","text":"<p>A recursive function is one that calls itself, either directly or indirectly through another function. Recursion is a common but complex topic; here we look at its basic structure.</p>"},{"location":"wk_two/#base-cases-and-recursive-calls","title":"Base Cases and Recursive Calls","text":"<p>A recursive function solves problems by dividing them into:</p> <ul> <li>A base case \u2013 the simplest case the function knows how to solve directly.</li> <li>A recursive case \u2013 a more complex problem broken down into smaller versions of itself.</li> </ul> <p>The recursive case must resemble the original problem but be simpler or smaller, ensuring progress toward the base case. Each recursive call works on the reduced problem until the base case is reached.</p>"},{"location":"wk_two/#recursive-step","title":"Recursive Step","text":"<p>When a recursive call is made:</p> <ul> <li>The function pauses its current execution and launches a fresh copy of itself to handle the smaller problem.</li> <li>This process can repeat many times, generating multiple recursive calls.</li> <li>Each call must eventually converge on the base case, where recursion stops.</li> </ul>"},{"location":"wk_two/#returning-results","title":"Returning Results","text":"<p>Each recursive call includes a <code>return</code> statement. When the base case is reached, the result is returned back to the previous call. This chain of returns continues until the result reaches the original caller.</p> <p>In summary:</p> <ul> <li>Base case: directly solvable, no further recursion.</li> <li>Recursive step: reduces the problem and calls the function again.</li> <li>Convergence: repeated recursion eventually reaches the base case, then unwinds with results.</li> </ul>"},{"location":"wk_two/#example-factorial","title":"Example: Factorial","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint factorial(int n) {\n    if (n == 0) {           // base case\n        return 1;\n    } else {\n        return n * factorial(n - 1); // recursive case\n    }\n}\n\nint main(void) {\n    int num = 5;\n    printf(\"Factorial of %d is %d\\n\", num, factorial(num));\n    return 0;\n}\n</code></pre> <p>Input: <code>5</code> \u2192 Output: <code>120</code></p>"},{"location":"wk_two/#stack-visualization","title":"Stack Visualization","text":"<p>Recursive calls can be visualized as a stack. Each new call is pushed onto the stack showing the pending computation, and results are popped once the base case is reached.</p> <p>Factorial(5):</p> <pre><code>Push (calls):\nFactorial(5) -&gt; 5 * Factorial(4)\n  Factorial(4) -&gt; 4 * Factorial(3)\n    Factorial(3) -&gt; 3 * Factorial(2)\n      Factorial(2) -&gt; 2 * Factorial(1)\n        Factorial(1) -&gt; 1 * Factorial(0)\n          Factorial(0) -&gt; 1  (base case)\n\nPop (returns):\n        Factorial(1) = 1 * Factorial(0) = 1 * 1 = 1\n      Factorial(2) = 2 * Factorial(1) = 2 * 1 = 2\n    Factorial(3) = 3 * Factorial(2) = 3 * 2 = 6\n  Factorial(4) = 4 * Factorial(3) = 4 * 6 = 24\nFactorial(5) = 5 * Factorial(4) = 5 * 24 = 120\n</code></pre>"}]}